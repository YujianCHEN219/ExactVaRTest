library(gridExtra)
install.packages("gridExtra")
library(gridExtra)
grid.arrange(p1, p2, ncol=2)
install.packages("patchwork")
library(patchwork)
p1 / p2
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  // initialization#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  // forward#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      // next state if we observe 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      // next state if we observe 1#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  // gather distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    // LRuc#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    // LRind#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
  if(n>1){#
    for(i in 2:n){#
      if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
      if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
      if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
      if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
    }#
  }#
  if(n>1){#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  } else {#
    LRind <- 0#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  # p-value = 1 - CDF(LRobs)#
  cdf_val <- sum(probvals[LRvals <= LRobs])#
  1 - cdf_val#
}#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15) #
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    # mean_abs_pval_diff: This is the average absolute difference between#
    # the exact p-value and the chi-square-based p-value across all simulations.#
#
    # prop_diff_in_decision: This is the proportion of simulated samples#
    # for which the exact method and the chi-square method give different#
    # reject/not-reject decisions at 5% significance.#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2)#
library(gridExtra)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results#
p1 / p2
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  // initialization#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  // forward#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      // next state if we observe 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      // next state if we observe 1#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  // gather distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    // LRuc#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    // LRind#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
  if(n>1){#
    for(i in 2:n){#
      if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
      if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
      if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
      if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
    }#
  }#
  if(n>1){#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  } else {#
    LRind <- 0#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  # p-value = 1 - CDF(LRobs)#
  cdf_val <- sum(probvals[LRvals <= LRobs])#
  1 - cdf_val#
}#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15) #
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    # mean_abs_pval_diff: This is the average absolute difference between#
    # the exact p-value and the chi-square-based p-value across all simulations.#
#
    # prop_diff_in_decision: This is the proportion of simulated samples#
    # for which the exact method and the chi-square method give different#
    # reject/not-reject decisions at 5% significance.#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results#
p1 / p2
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  // initialization#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  // forward#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      // next state if we observe 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      // next state if we observe 1#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  // gather distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    // LRuc#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    // LRind#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
  if(n>1){#
    for(i in 2:n){#
      if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
      if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
      if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
      if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
    }#
  }#
  if(n>1){#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  } else {#
    LRind <- 0#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  # p-value = 1 - CDF(LRobs)#
  cdf_val <- sum(probvals[LRvals <= LRobs])#
  1 - cdf_val#
}#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 10000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15) #
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    # mean_abs_pval_diff: This is the average absolute difference between#
    # the exact p-value and the chi-square-based p-value across all simulations.#
#
    # prop_diff_in_decision: This is the proportion of simulated samples#
    # for which the exact method and the chi-square method give different#
    # reject/not-reject decisions at 5% significance.#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results#
p1 / p2
p1/p2
set.seed(123)#
n_     <- 500#
alpha_ <- 0.01#
X      <- rbinom(n_, 1, alpha_)#
sum(X)       # 1 的个数#
table(X)     # 0 和 1 的频次
library(Rcpp)#
safe_log <- function(x) if(x>0) log(x) else 0#
LRuc_count <- function(x,n,p) {#
  if(x==0) phat <- 0 else if(x==n) phat <- 1 else phat <- x/n#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n-x)*safe_log(1-p_)#
  den <- x*safe_log(ph_) + (n-x)*safe_log(1-ph_)#
  -2*(num-den)#
}#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00+T10; T1 <- T01+T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
library(stats)#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){return x>0.0?std::log(x):0.0;}#
struct State {int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long S2=NMAX+10, S3=S2*(NMAX+10), S4=S3*(NMAX+10), S5=S4*(NMAX+10), S6=S5*(NMAX+10);#
  return la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
 // [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5; std::unordered_map<long long,State,LLHash> curMap;#
  { State s0={0,0,0,0,0,0,1.0-alpha}; curMap[encode6(0,0,0,0,0,0,NMAX)]=s0;#
    State s1={1,1,0,0,0,0,alpha}; curMap[encode6(1,1,0,0,0,0,NMAX)]=s1; }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap; newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob; if(p<prune_threshold) continue;#
      int la=kv.second.la,c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      { State ns=kv.second; if(la==0) ns.T00++; else ns.T10++; ns.la=0; ns.prob=p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c); if(it==newMap.end()) newMap[c]=ns; else it->second.prob+=ns.prob; }#
      { State ns=kv.second; if(la==0){ns.T01++; ns.c1++;} else {ns.T11++; ns.c1++;} ns.la=1; ns.prob=p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c); if(it==newMap.end()) newMap[c]=ns; else it->second.prob+=ns.prob; }#
    }#
    curMap.clear();#
    for(auto &km:newMap) if(km.second.prob>=prune_threshold) curMap[km.first]=km.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob; if(p<=0.0) continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double lruc,lrind;#
    { double phat=c1==0?0:(c1==n?1:(double)c1/n);#
      double eps=1e-15,p_=std::max(std::min(alpha,1.0-eps),eps),ph_=std::max(std::min(phat,1.0-eps),eps);#
      lruc=-2*(c1*std::log(p_)+(n-c1)*std::log(1-p_) - (c1*std::log(ph_)+(n-c1)*std::log(1-ph_)));#
    }#
    lrind=0; if(n>1){#
      int T0=T00+T10,T1=T01+T11; double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01,s11=T10+T11; double pi01=s01>0?((double)T01/s01):1,pi11=s11>0?((double)T11/s11):1;#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)+T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec; for(auto &kv:lrDist) vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15) curP+=vec[i].second;#
      else{ LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second; }#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15) fb_lrcc_fastcpp(n,alpha,prune_threshold)#
my_compute_LRcc <- function(X,alpha) {#
  n <- length(X); c1 <- sum(X); eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps); ph_ <- max(min(c1/n,1-eps),eps)#
  num_uc <- c1*log(p_)+(n-c1)*log(1-p_); den_uc <- c1*log(ph_)+(n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc-den_uc)#
  T00 <- T01 <- T10 <- T11 <- 0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00 <- T00+1#
    if(X[i-1]==0&&X[i]==1) T01 <- T01+1#
    if(X[i-1]==1&&X[i]==0) T10 <- T10+1#
    if(X[i-1]==1&&X[i]==1) T11 <- T11+1#
  }#
  LRind <- 0#
  if(n>1){#
    T0 <- T00+T10; T1 <- T01+T11; pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01 <- T00+T01; pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10+T11; pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind <- -2*(num-den)#
  }#
  LRuc+LRind#
}#
get_pval_exact <- function(LRvals,probvals,LRobs) 1-sum(probvals[LRvals<=LRobs])#
library(ggplot2)#
data <- read.csv("/Users/chenyujian/Downloads/VaR_99_exception.csv", row.names=1)#
X <- as.numeric(data[,1])#
n <- length(X); alpha <- 0.01#
dist_full <- fb_lrcc(n,alpha,1e-15)#
LRvals <- dist_full$LR; probvals <- dist_full$prob#
LRobs <- my_compute_LRcc(X,alpha)#
pval_exact <- get_pval_exact(LRvals,probvals,LRobs)#
pval_chi2 <- 1-pchisq(LRobs,df=2)#
results <- data.frame(n=n,alpha=alpha,LRobs=LRobs,pval_exact=pval_exact,pval_chi2=pval_chi2)#
df_dist <- data.frame(LR=LRvals,prob=probvals)#
p <- ggplot(df_dist,aes(x=LR,y=prob))+#
  geom_bar(stat="identity")+#
  geom_vline(xintercept=LRobs,color="red")+#
  labs(title=paste0("LR Distribution (n=",n,", alpha=",alpha,")"),#
       subtitle=paste0("LRobs=",round(LRobs,3),#
                       ", p_exact=",round(pval_exact,3),#
                       ", p_chi2=",round(pval_chi2,3)))+#
  theme_minimal()#
print(results)#
print(p)
library(Rcpp)#
library(stats)#
library(ggplot2)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) phat <- 0 else if(x==n) phat <- 1 else phat <- x/n#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n-x)*safe_log(1-p_)#
  den <- x*safe_log(ph_) + (n-x)*safe_log(1-ph_)#
  -2*(num-den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00+T10; T1 <- T01+T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num-den)#
}#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
static inline double s_log(double x){ return x>0.0 ? std::log(x) : 0.0; }#
#
struct State {#
  int la, c1, T00, T10, T01, T11;#
  double prob;#
};#
#
struct LLHash {#
  size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10;#
  long long S2 = M;#
  long long S3 = S2 * M;#
  long long S4 = S3 * M;#
  long long S5 = S4 * M;#
  long long S6 = S5 * M;#
  return la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1) return List::create(Named("LR")=NumericVector(0), Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long, State, LLHash> curMap;#
  State s0 = {0,0,0,0,0,0,1.0-alpha};#
  State s1 = {1,1,0,0,0,0,alpha};#
  curMap[encode6(0,0,0,0,0,0,NMAX)] = s0;#
  curMap[encode6(1,1,0,0,0,0,NMAX)] = s1;#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long, State, LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv : curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la = kv.second.la, c1 = kv.second.c1;#
      int T00 = kv.second.T00, T10 = kv.second.T10;#
      int T01 = kv.second.T01, T11 = kv.second.T11;#
      double p0 = 1.0 - alpha, p1 = alpha;#
      { State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0; ns.prob = p * p0;#
        long long code = encode6(ns.la, ns.c1, ns.T00, ns.T10, ns.T01, ns.T11, NMAX);#
        auto it = newMap.find(code);#
        if(it == newMap.end()) newMap[code] = ns; else it->second.prob += ns.prob;#
      }#
      { State ns = kv.second;#
        if(la==0) { ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la = 1; ns.prob = p * p1;#
        long long code = encode6(ns.la, ns.c1, ns.T00, ns.T10, ns.T01, ns.T11, NMAX);#
        auto it = newMap.find(code);#
        if(it == newMap.end()) newMap[code] = ns; else it->second.prob += ns.prob;#
      }#
    }#
    curMap.clear();#
    for(auto &kv : newMap) if(kv.second.prob >= prune_threshold) curMap[kv.first] = kv.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv : curMap){#
    double p = kv.second.prob;#
    if(p <= 0.0) continue;#
    int c1 = kv.second.c1;#
    int T00 = kv.second.T00, T10 = kv.second.T10;#
    int T01 = kv.second.T01, T11 = kv.second.T11;#
    double lruc, lrind = 0.0;#
    double phat = (c1==0?0:(c1==n?1:((double)c1/n)));#
    double eps = 1e-15;#
    double p_ = std::max(std::min(alpha,1.0-eps),eps);#
    double ph_ = std::max(std::min(phat,1.0-eps),eps);#
    lruc = -2.0 * (c1*std::log(p_) + (n-c1)*std::log(1-p_)#
                  - (c1*std::log(ph_) + (n-c1)*std::log(1-ph_)));#
    if(n>1){#
      int T0 = T00+T10, T1 = T01+T11;#
      double ph = (double)T1/(n-1);#
      double num = T0 * s_log(1-ph) + T1 * s_log(ph);#
      int s01 = T00+T01, s11 = T10+T11;#
      double pi01 = (s01>0?((double)T01/s01):1.0);#
      double pi11 = (s11>0?((double)T11/s11):1.0);#
      double den = T00 * s_log(1-pi01) + T01 * s_log(pi01)#
                 + T10 * s_log(1-pi11) + T11 * s_log(pi11);#
      lrind = -2.0 * (num - den);#
    }#
    lrDist[lruc + lrind] += p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  for(auto &kv : lrDist) vec.emplace_back(kv.first, kv.second);#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first, curP = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR) < 1e-15) curP += vec[i].second;#
      else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps)#
  ph_ <- max(min(c1/n,1-eps),eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- T01 <- T10 <- T11 <- 0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
    if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
    if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
    if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
  }#
  LRind <- 0#
  if(n>1){#
    T0 <- T00+T10#
    T1 <- T01+T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00+T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10+T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals <= LRobs])#
}#
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_99_exception.csv", row.names=1)#
X <- as.numeric(data[,1])#
n <- length(X)#
alpha <- 0.01#
#
dist_full <- fb_lrcc(n, alpha, 1e-15)#
LRvals <- dist_full$LR#
probvals <- dist_full$prob#
LRobs <- my_compute_LRcc(X, alpha)#
pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
pval_chi2 <- 1 - pchisq(LRobs, df=2)#
#
results <- data.frame(#
  n = n,#
  alpha = alpha,#
  LRobs = LRobs,#
  pval_exact = pval_exact,#
  pval_chi2 = pval_chi2#
)#
#
df_dist <- data.frame(LR = LRvals, prob = probvals)#
#
p <- ggplot(df_dist, aes(x = LR, y = prob)) +#
  geom_bar(stat = "identity") +#
  geom_vline(xintercept = LRobs, color = "red") +#
  labs(#
    title = paste0("LR Distribution (n=", n, ", alpha=", alpha, ")"),#
    subtitle = paste0(#
      "LRobs=", round(LRobs, 3),#
      ", p_exact=", round(pval_exact, 3),#
      ", p_chi2=", round(pval_chi2, 3)#
    )#
  ) +#
  theme_minimal()#
#
print(results)#
print(p)
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  // initialization#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  // forward#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      // next state if we observe 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      // next state if we observe 1#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  // gather distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    // LRuc#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    // LRind#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
  if(n>1){#
    for(i in 2:n){#
      if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
      if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
      if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
      if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
    }#
  }#
  if(n>1){#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  } else {#
    LRind <- 0#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  # p-value = 1 - CDF(LRobs)#
  cdf_val <- sum(probvals[LRvals <= LRobs])#
  1 - cdf_val#
}#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15) #
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    # mean_abs_pval_diff: This is the average absolute difference between#
    # the exact p-value and the chi-square-based p-value across all simulations.#
#
    # prop_diff_in_decision: This is the proportion of simulated samples#
    # for which the exact method and the chi-square method give different#
    # reject/not-reject decisions at 5% significance.#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results#
p1 / p2
library(Rcpp)#
library(stats)#
library(ggplot2)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){ return x>0.0 ? std::log(x) : 0.0; }#
struct State { int la,c1,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10;#
  long long S2 = M;#
  long long S3 = S2 * M;#
  long long S4 = S3 * M;#
  long long S5 = S4 * M;#
  long long S6 = S5 * M;#
  return la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  State s0={0,0,0,0,0,0,1.0-alpha}, s1={1,1,0,0,0,0,alpha};#
  curMap[encode6(0,0,0,0,0,0,NMAX)]=s0;#
  curMap[encode6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la=kv.second.la,c1=kv.second.c1;#
      int T00=kv.second.T00,T10=kv.second.T10;#
      int T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      { State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*p0;#
        long long code=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
      { State ns=kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1; ns.prob=p*p1;#
        long long code=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
    }#
    curMap.clear();#
    for(auto &kv:newMap) if(kv.second.prob>=prune_threshold) curMap[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob;#
    if(p<=0.0) continue;#
    int c1=kv.second.c1;#
    int T00=kv.second.T00,T10=kv.second.T10;#
    int T01=kv.second.T01,T11=kv.second.T11;#
    double lruc,lrind=0.0;#
    double phat=(c1==0?0:(c1==n?1:((double)c1/n)));#
    double eps=1e-15;#
    double p_ = std::max(std::min(alpha,1.0-eps),eps);#
    double ph_= std::max(std::min(phat,1.0-eps),eps);#
    lruc=-2*(c1*std::log(p_)+(n-c1)*std::log(1-p_)#
             -(c1*std::log(ph_)+(n-c1)*std::log(1-ph_)));#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=(s01>0?((double)T01/s01):1.0);#
      double pi11=(s11>0?((double)T11/s11):1.0);#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)#
                 +T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  for(auto &kv:lrDist) vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15) curP+=vec[i].second;#
      else{ LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second; }#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15) fb_lrcc_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRcc <- function(X,alpha) {#
  n <- length(X); c1 <- sum(X); eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps); ph_ <- max(min(c1/n,1-eps),eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_); den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc-den_uc)#
  T00 <- T01 <- T10 <- T11 <- 0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  LRind <- 0#
  if(n>1){#
    T0<-T00+T10; T1<-T01+T11; pHat<-T1/(n-1)#
    num<-T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01<-T00+T01; pi01<-if(s01>0)T01/s01 else 1#
    s11<-T10+T11; pi11<-if(s11>0)T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1 - sum(probvals[LRvals <= LRobs])#
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_99_exception.csv",row.names=1)#
X <- as.numeric(data[,1])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha <- 0.01#
K <- 2000#
N <- length(X)#
results_real <- data.frame()#
#
for(n_ in n_list) {#
  abs_diff <- numeric(K)#
  diff_dec <- numeric(K)#
  max_start <- N - n_ + 1#
  for(i in seq_len(K)) {#
    st <- sample.int(max_start,1)#
    seg <- X[st:(st+n_-1)]#
    LRobs <- my_compute_LRcc(seg,alpha)#
    dist_full <- fb_lrcc(n_,alpha,1e-15)#
    p_exact <- get_pval_exact(dist_full$LR,dist_full$prob,LRobs)#
    p_chi2 <- 1 - pchisq(LRobs,df=2)#
    abs_diff[i] <- abs(p_exact - p_chi2)#
    diff_dec[i] <- as.numeric((p_exact < 0.05) != (p_chi2 < 0.05))#
  }#
  results_real <- rbind(#
    results_real,#
    data.frame(#
      n = n_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_dec)#
    )#
  )#
}#
#
print(results_real)#
#
ggplot(results_real, aes(x=factor(n))) +#
  geom_col(aes(y=mean_abs_pval_diff, fill="Mean |Δp|")) +#
  geom_col(aes(y=prop_diff_in_decision, fill="Proportion Different Decisions"), position="dodge") +#
  scale_fill_manual("", #
    values = c("Mean |Δp|"="steelblue","Proportion Different Decisions"="salmon")#
  ) +#
  labs(x="Subsequence Length n",#
       y="",#
       title="Chi-square Approximation vs Exact p-value Differences") +#
  theme_minimal()
library(Rcpp)#
library(stats)#
library(ggplot2)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){ return x>0.0 ? std::log(x) : 0.0; }#
struct State { int la,c1,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10, S2=M, S3=S2*M, S4=S3*M, S5=S4*M, S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
 // [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  State s0={0,0,0,0,0,0,1.0-alpha}, s1={1,1,0,0,0,0,alpha};#
  curMap[encode6(0,0,0,0,0,0,NMAX)]=s0;#
  curMap[encode6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob; if(p<prune_threshold) continue;#
      int la=kv.second.la,c1=kv.second.c1;#
      int T00=kv.second.T00,T10=kv.second.T10;#
      int T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      { State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*p0;#
        long long code=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
      { State ns=kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1; ns.prob=p*p1;#
        long long code=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
    }#
    curMap.clear();#
    for(auto &kv:newMap) if(kv.second.prob>=prune_threshold) curMap[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob; if(p<=0) continue;#
    int c1=kv.second.c1;#
    int T00=kv.second.T00,T10=kv.second.T10;#
    int T01=kv.second.T01,T11=kv.second.T11;#
    double lruc, lrind=0.0;#
    double phat=(c1==0?0:(c1==n?1:((double)c1/n)));#
    double eps=1e-15;#
    double p_=std::max(std::min(alpha,1.0-eps),eps);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    lruc=-2*(c1*std::log(p_)+(n-c1)*std::log(1-p_)#
             -(c1*std::log(ph_)+(n-c1)*std::log(1-ph_)));#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=(s01>0?((double)T01/s01):1.0);#
      double pi11=(s11>0?((double)T11/s11):1.0);#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)#
                 +T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  for(auto &kv:lrDist) vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first, curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15) curP+=vec[i].second;#
      else{ LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second; }#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15) fb_lrcc_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRcc <- function(X,alpha) {#
  n <- length(X); c1 <- sum(X); eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps); ph_ <- max(min(c1/n,1-eps),eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_); den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc-den_uc)#
  T00 <- T01 <- T10 <- T11 <- 0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  LRind <- 0#
  if(n>1){#
    T0<-T00+T10; T1<-T01+T11; pHat<-T1/(n-1)#
    num<-T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
    s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1 - sum(probvals[LRvals <= LRobs])#
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_99_exception.csv",row.names=1)#
X <- as.numeric(data[,1])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha <- 0.01#
K <- 2000#
N <- length(X)#
results_real <- data.frame()#
#
for(n_ in n_list) {#
  dist_full <- fb_lrcc(n_,alpha,1e-15)#
  LRvals <- dist_full$LR#
  probvals <- dist_full$prob#
  abs_diff <- numeric(K)#
  diff_dec <- numeric(K)#
  max_start <- N - n_ + 1#
  for(i in seq_len(K)) {#
    st <- sample.int(max_start,1)#
    seg <- X[st:(st+n_-1)]#
    LRobs <- my_compute_LRcc(seg,alpha)#
    p_exact <- get_pval_exact(LRvals,probvals,LRobs)#
    p_chi2 <- 1 - pchisq(LRobs,df=2)#
    abs_diff[i] <- abs(p_exact - p_chi2)#
    diff_dec[i] <- as.numeric((p_exact < 0.05) != (p_chi2 < 0.05))#
  }#
  results_real <- rbind(#
    results_real,#
    data.frame(#
      n = n_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_dec)#
    )#
  )#
}#
#
print(results_real)#
#
ggplot(results_real, aes(x=factor(n))) +#
  geom_col(aes(y=mean_abs_pval_diff, fill="Mean |Δp|")) +#
  geom_col(aes(y=prop_diff_in_decision, fill="Proportion Different Decisions"), position="dodge") +#
  scale_fill_manual("", values=c("Mean |Δp|"="steelblue","Proportion Different Decisions"="salmon")) +#
  labs(x="Subsequence Length n", y="", title="Chi-square Approximation vs Exact p-value Differences") +#
  theme_minimal()
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){ return x>0.0 ? std::log(x) : 0.0; }#
struct State { int la,c1,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10, S2=M, S3=S2*M, S4=S3*M, S5=S4*M, S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
 // [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  State s0={0,0,0,0,0,0,1.0-alpha}, s1={1,1,0,0,0,0,alpha};#
  curMap[encode6(0,0,0,0,0,0,NMAX)]=s0;#
  curMap[encode6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob; if(p<prune_threshold) continue;#
      int la=kv.second.la,c1=kv.second.c1;#
      int T00=kv.second.T00,T10=kv.second.T10;#
      int T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      { State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*p0;#
        long long code=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
      { State ns=kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1; ns.prob=p*p1;#
        long long code=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
    }#
    curMap.clear();#
    for(auto &kv:newMap) if(kv.second.prob>=prune_threshold) curMap[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob; if(p<=0) continue;#
    int c1=kv.second.c1;#
    int T00=kv.second.T00,T10=kv.second.T10;#
    int T01=kv.second.T01,T11=kv.second.T11;#
    double lruc, lrind=0.0;#
    double phat=(c1==0?0:(c1==n?1:((double)c1/n)));#
    double eps=1e-15;#
    double p_=std::max(std::min(alpha,1.0-eps),eps);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    lruc=-2*(c1*std::log(p_)+(n-c1)*std::log(1-p_)#
             -(c1*std::log(ph_)+(n-c1)*std::log(1-ph_)));#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=(s01>0?((double)T01/s01):1.0);#
      double pi11=(s11>0?((double)T11/s11):1.0);#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)#
                 +T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  for(auto &kv:lrDist) vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first, curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15) curP+=vec[i].second;#
      else{ LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second; }#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15) fb_lrcc_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRcc <- function(X,alpha) {#
  n <- length(X); c1 <- sum(X); eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps); ph_ <- max(min(c1/n,1-eps),eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_); den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc-den_uc)#
  T00 <- T01 <- T10 <- T11 <- 0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  LRind <- 0#
  if(n>1){#
    T0<-T00+T10; T1<-T01+T11; pHat<-T1/(n-1)#
    num<-T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
    s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1 - sum(probvals[LRvals <= LRobs])#
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_99_exception.csv",row.names=1)#
X <- as.numeric(data[,1])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha <- 0.01#
K <- 2000#
N <- length(X)#
results_real <- data.frame()#
#
for(n_ in n_list) {#
  dist_full <- fb_lrcc(n_,alpha,1e-15)#
  LRvals <- dist_full$LR#
  probvals <- dist_full$prob#
  abs_diff <- numeric(K)#
  diff_dec <- numeric(K)#
  max_start <- N - n_ + 1#
  for(i in seq_len(K)) {#
    st <- sample.int(max_start,1)#
    seg <- X[st:(st+n_-1)]#
    LRobs <- my_compute_LRcc(seg,alpha)#
    p_exact <- get_pval_exact(LRvals,probvals,LRobs)#
    p_chi2 <- 1 - pchisq(LRobs,df=2)#
    abs_diff[i] <- abs(p_exact - p_chi2)#
    diff_dec[i] <- as.numeric((p_exact < 0.05) != (p_chi2 < 0.05))#
  }#
  results_real <- rbind(#
    results_real,#
    data.frame(#
      n = n_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_dec)#
    )#
  )#
}#
#
results_plot <- results_real#
results_plot$alpha <- factor(0.01)#
#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=alpha)) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=alpha)) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results_real#
p1 / p2
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  // initialization#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  // forward#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      // next state if we observe 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      // next state if we observe 1#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  // gather distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    // LRuc#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    // LRind#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
  if(n>1){#
    for(i in 2:n){#
      if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
      if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
      if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
      if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
    }#
  }#
  if(n>1){#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  } else {#
    LRind <- 0#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  # p-value = 1 - CDF(LRobs)#
  cdf_val <- sum(probvals[LRvals <= LRobs])#
  1 - cdf_val#
}#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15) #
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    # mean_abs_pval_diff: This is the average absolute difference between#
    # the exact p-value and the chi-square-based p-value across all simulations.#
#
    # prop_diff_in_decision: This is the proportion of simulated samples#
    # for which the exact method and the chi-square method give different#
    # reject/not-reject decisions at 5% significance.#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results#
p1 / p2
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){ return x>0.0 ? std::log(x) : 0.0; }#
struct State { int la,c1,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10, S2=M, S3=S2*M, S4=S3*M, S5=S4*M, S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
 // [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  State s0={0,0,0,0,0,0,1.0-alpha}, s1={1,1,0,0,0,0,alpha};#
  curMap[encode6(0,0,0,0,0,0,NMAX)]=s0;#
  curMap[encode6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob; if(p<prune_threshold) continue;#
      int la=kv.second.la,c1=kv.second.c1;#
      int T00=kv.second.T00,T10=kv.second.T10;#
      int T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      { State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*p0;#
        long long code=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
      { State ns=kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1; ns.prob=p*p1;#
        long long code=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
    }#
    curMap.clear();#
    for(auto &kv:newMap) if(kv.second.prob>=prune_threshold) curMap[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob; if(p<=0) continue;#
    int c1=kv.second.c1;#
    int T00=kv.second.T00,T10=kv.second.T10;#
    int T01=kv.second.T01,T11=kv.second.T11;#
    double lruc,lrind=0.0;#
    double phat=(c1==0?0:(c1==n?1:((double)c1/n)));#
    double eps=1e-15;#
    double p_=std::max(std::min(alpha,1.0-eps),eps);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    lruc=-2*(c1*std::log(p_)+(n-c1)*std::log(1-p_)#
             -(c1*std::log(ph_)+(n-c1)*std::log(1-ph_)));#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=(s01>0?((double)T01/s01):1.0);#
      double pi11=(s11>0?((double)T11/s11):1.0);#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)#
                 +T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  for(auto &kv:lrDist) vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15) curP+=vec[i].second;#
      else{ LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second; }#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15) fb_lrcc_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRcc <- function(X,alpha) {#
  n<-length(X); c1<-sum(X); eps<-1e-15#
  p_<-max(min(alpha,1-eps),eps); ph_<-max(min(c1/n,1-eps),eps)#
  num_uc<-c1*log(p_)+(n-c1)*log(1-p_); den_uc<-c1*log(ph_)+(n-c1)*log(1-ph_)#
  LRuc<- -2*(num_uc-den_uc)#
  T00<-T01<-T10<-T11<-0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  LRind<-0#
  if(n>1){#
    T0<-T00+T10; T1<-T01+T11; pHat<-T1/(n-1)#
    num<-T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01<-T00+T01; pi01<-if(s01>0)T01/s01 else 1#
    s11<-T10+T11; pi11<-if(s11>0)T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1 - sum(probvals[LRvals<=LRobs])#
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv",row.names=1)#
exception_df <- data#
alpha_list <- c(0.05,0.025,0.01)#
names(exception_df) <- as.character(alpha_list)#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
K <- 2000#
N <- nrow(exception_df)#
results <- data.frame()#
#
for(alpha in alpha_list){#
  X <- exception_df[[as.character(alpha)]]#
  for(n in n_list){#
    dist_full <- fb_lrcc(n,alpha,1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(K)#
    diff_dec <- numeric(K)#
    max_start <- N - n + 1#
    for(i in seq_len(K)){#
      st <- sample.int(max_start,1)#
      seg <- X[st:(st+n-1)]#
      LRobs <- my_compute_LRcc(seg,alpha)#
      p_exact <- get_pval_exact(LRvals,probvals,LRobs)#
      p_chi2 <- 1 - pchisq(LRobs,df=2)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.numeric((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,data.frame(#
      n=n,#
      alpha=alpha,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)#
    ))#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
print(results)#
print(p1 / p2)
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  // initialization#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  // forward#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      // next state if we observe 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      // next state if we observe 1#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  // gather distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    // LRuc#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    // LRind#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
  if(n>1){#
    for(i in 2:n){#
      if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
      if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
      if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
      if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
    }#
  }#
  if(n>1){#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  } else {#
    LRind <- 0#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  # p-value = 1 - CDF(LRobs)#
  cdf_val <- sum(probvals[LRvals <= LRobs])#
  1 - cdf_val#
}#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15) #
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    # mean_abs_pval_diff: This is the average absolute difference between#
    # the exact p-value and the chi-square-based p-value across all simulations.#
#
    # prop_diff_in_decision: This is the proportion of simulated samples#
    # for which the exact method and the chi-square method give different#
    # reject/not-reject decisions at 5% significance.#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results#
p1 / p2
# P-value Comparison via real data#
#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){ return x>0.0 ? std::log(x) : 0.0; }#
struct State { int la,c1,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10, S2=M, S3=S2*M, S4=S3*M, S5=S4*M, S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
 // [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  State s0={0,0,0,0,0,0,1.0-alpha}, s1={1,1,0,0,0,0,alpha};#
  curMap[encode6(0,0,0,0,0,0,NMAX)]=s0;#
  curMap[encode6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob; if(p<prune_threshold) continue;#
      int la=kv.second.la,c1=kv.second.c1;#
      int T00=kv.second.T00,T10=kv.second.T10;#
      int T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      { State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*p0;#
        long long code=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
      { State ns=kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1; ns.prob=p*p1;#
        long long code=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
    }#
    curMap.clear();#
    for(auto &kv:newMap) if(kv.second.prob>=prune_threshold) curMap[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob; if(p<=0) continue;#
    int c1=kv.second.c1;#
    int T00=kv.second.T00,T10=kv.second.T10;#
    int T01=kv.second.T01,T11=kv.second.T11;#
    double lruc,lrind=0.0;#
    double phat=(c1==0?0:(c1==n?1:((double)c1/n)));#
    double eps=1e-15;#
    double p_=std::max(std::min(alpha,1.0-eps),eps);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    lruc=-2*(c1*std::log(p_)+(n-c1)*std::log(1-p_)#
             -(c1*std::log(ph_)+(n-c1)*std::log(1-ph_)));#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=(s01>0?((double)T01/s01):1.0);#
      double pi11=(s11>0?((double)T11/s11):1.0);#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)#
                 +T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  for(auto &kv:lrDist) vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15) curP+=vec[i].second;#
      else{ LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second; }#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15) fb_lrcc_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRcc <- function(X,alpha) {#
  n<-length(X); c1<-sum(X); eps<-1e-15#
  p_<-max(min(alpha,1-eps),eps); ph_<-max(min(c1/n,1-eps),eps)#
  num_uc<-c1*log(p_)+(n-c1)*log(1-p_); den_uc<-c1*log(ph_)+(n-c1)*log(1-ph_)#
  LRuc<- -2*(num_uc-den_uc)#
  T00<-T01<-T10<-T11<-0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  LRind<-0#
  if(n>1){#
    T0<-T00+T10; T1<-T01+T11; pHat<-T1/(n-1)#
    num<-T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01<-T00+T01; pi01<-if(s01>0)T01/s01 else 1#
    s11<-T10+T11; pi11<-if(s11>0)T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1 - sum(probvals[LRvals<=LRobs])#
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv",row.names=1)#
exception_df <- data#
alpha_list <- c(0.05,0.025,0.01)#
names(exception_df) <- as.character(alpha_list)#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
K <- 2000#
N <- nrow(exception_df)#
results <- data.frame()#
#
for(alpha in alpha_list){#
  X <- exception_df[[as.character(alpha)]]#
  for(n in n_list){#
    dist_full <- fb_lrcc(n,alpha,1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(K)#
    diff_dec <- numeric(K)#
    max_start <- N - n + 1#
    for(i in seq_len(K)){#
      st <- sample.int(max_start,1)#
      seg <- X[st:(st+n-1)]#
      LRobs <- my_compute_LRcc(seg,alpha)#
      p_exact <- get_pval_exact(LRvals,probvals,LRobs)#
      p_chi2 <- 1 - pchisq(LRobs,df=2)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.numeric((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,data.frame(#
      n=n,#
      alpha=alpha,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)#
    ))#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
results#
p1 / p2
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  // initialization#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  // forward#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      // next state if we observe 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      // next state if we observe 1#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  // gather distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    // LRuc#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    // LRind#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
  if(n>1){#
    for(i in 2:n){#
      if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
      if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
      if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
      if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
    }#
  }#
  if(n>1){#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  } else {#
    LRind <- 0#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  # p-value = 1 - CDF(LRobs)#
  cdf_val <- sum(probvals[LRvals <= LRobs])#
  1 - cdf_val#
}#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15) #
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    # mean_abs_pval_diff: This is the average absolute difference between#
    # the exact p-value and the chi-square-based p-value across all simulations.#
#
    # prop_diff_in_decision: This is the proportion of simulated samples#
    # for which the exact method and the chi-square method give different#
    # reject/not-reject decisions at 5% significance.#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results#
p1 / p2
library(Rcpp)#
#
# 告诉 Rcpp 用 C++17 并打开 -O3 与 OpenMP#
Sys.setenv("PKG_CXXFLAGS"="-O3 -march=native -std=c++17 -fopenmp")#
cppFunction('#
  #include <Rcpp.h>#
  #include <unordered_map>#
  #include <cstdint>#
  #include <omp.h>#
  using namespace Rcpp;#
#
  // <<<<<<<<<<<<<<<<<<  位移参数  >>>>>>>>>>>>>>>>>>#
  // d,max <= 1023  (10 bits)        ->  << 0#
  // m,max <= 1023  (10 bits)        ->  << 10#
  // S1,max<= 65535 (16 bits)        ->  << 20#
  // S2,max<=  2^26-1≈6.7e7 (26 bits)->  << 36#
  inline uint64_t pack(int d,int m,int S1,int S2){#
    return  (uint64_t)d #
          | ((uint64_t)m  << 10)#
          | ((uint64_t)S1 << 20)#
          | ((uint64_t)S2 << 36);#
  }#
#
  struct State{ int d,m,S1,S2; double p; };#
#
  // ---------- exact distribution of score statistic ----------#
  // [[Rcpp::export]]#
  List fb_score_fastcpp(int n,double alpha=0.05,double prune=1e-12){#
    std::unordered_map<uint64_t,State> cur;#
    cur.reserve(1024);#
    cur[pack(0,0,0,0)] = {0,0,0,0,1.0};#
#
    const double p0 = 1.0 - alpha, p1 = alpha;#
#
    for(int t=0;t<n;++t){#
      std::unordered_map<uint64_t,State> nxt;#
      nxt.reserve(cur.size()*2);#
#
      #pragma omp parallel#
      {#
        std::unordered_map<uint64_t,State> local;#
        local.reserve(512);#
#
        #pragma omp for nowait#
        for(std::size_t i=0;i<cur.bucket_count();++i){#
          for(auto it=cur.begin(i); it!=cur.end(i); ++it){#
            const State &st = it->second;#
            if(st.p < prune) continue;#
#
            // 观测 0#
            State s0 = st;#
            s0.d += 1;#
            s0.p *= p0;#
            if(s0.p >= prune){#
              uint64_t k = pack(s0.d,s0.m,s0.S1,s0.S2);#
              auto &ref = local[k];#
              if(ref.p==0) ref = s0; else ref.p += s0.p;#
            }#
#
            // 观测 1#
            State s1 = st;#
            int dur = s1.d + 1;#
            s1.d  = 0;#
            s1.m += 1;#
            s1.S1+= dur;#
            s1.S2+= dur*dur;#
            s1.p *= p1;#
            if(s1.p >= prune){#
              uint64_t k = pack(s1.d,s1.m,s1.S1,s1.S2);#
              auto &ref = local[k];#
              if(ref.p==0) ref = s1; else ref.p += s1.p;#
            }#
          }#
        }#
#
        #pragma omp critical#
        {#
          for(auto &kv:local){#
            auto &ref = nxt[kv.first];#
            if(ref.p==0) ref = kv.second; else ref.p += kv.second.p;#
          }#
        }#
      } // end parallel#
#
      cur.swap(nxt);#
    }#
#
    std::unordered_map<double,double> dist;#
    dist.reserve(cur.size());#
#
    for(auto &kv:cur){#
      const State &st = kv.second;#
      if(st.m==0 || st.p<=0.0) continue;#
      double score = (double)st.S2 * st.m / ((double)st.S1 * st.S1);#
      dist[score] += st.p;#
    }#
#
    std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
    std::sort(vec.begin(),vec.end(),#
              [](auto&a,auto&b){return a.first<b.first;});#
#
    NumericVector stat(vec.size()), prob(vec.size());#
    for(std::size_t i=0;i<vec.size();++i){#
      stat[i]=vec[i].first;#
      prob[i]=vec[i].second;#
    }#
    return List::create(_["stat"]=stat,_["prob"]=prob);#
  }#
', plugins = c("cpp17","openmp"))#
#
fb_score <- function(n, alpha=0.05, prune=1e-12){#
  fb_score_fastcpp(n, alpha, prune)#
}#
#
score_stat <- function(x){#
  d <- S1 <- S2 <- m <- 0L#
  for(v in x){#
    d <- d + 1L#
    if(v==1L){#
      m  <- m  + 1L#
      S1 <- S1 + d#
      S2 <- S2 + d*d#
      d  <- 0L#
    }#
  }#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact <- function(stat, prob, obs){#
  sum(prob[stat >= obs - 1e-12])#
}#
#
# ---------------- quick sanity check ----------------#
set.seed(42)#
n   <- 300#
alp <- 0.05#
#
t0  <- system.time(dist <- fb_score(n, alp))[3]#
cat("time =", t0, "sec  (sumProb=", sum(dist$prob), ")\n")#
#
x <- rbinom(n, 1, alp)#
obs <- score_stat(x)#
cat("score =", obs, "  p_exact =", p_exact(dist$stat, dist$prob, obs), "\n")
library(Rcpp)#
#
Sys.setenv("PKG_CXXFLAGS"="-O3 -march=native -std=c++17 -fopenmp")#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cstdint>#
#include <omp.h>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
#
inline uint64_t pack(int d,int m,int S1,int S2){#
  return (uint64_t)d#
       | ((uint64_t)m  << 9)#
       | ((uint64_t)S1 << 18)#
       | ((uint64_t)S2 << 35);#
}#
#
// [[Rcpp::export]]#
List fb_dur_score_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  std::unordered_map<uint64_t,State,std::hash<uint64_t>> cur;#
  cur.reserve(1024);#
  cur[pack(0,0,0,0)] = {0,0,0,0,1.0};#
  const double p0 = 1.0 - alpha, p1 = alpha;#
#
  for(int t=0;t<n;++t){#
    std::vector<std::unordered_map<uint64_t,State,std::hash<uint64_t>>> locals(omp_get_max_threads());#
    for(auto &mp:locals) mp.reserve(cur.size()/locals.size()+16);#
#
    std::vector<std::pair<uint64_t,State>> nodes;#
    nodes.reserve(cur.size());#
    for(auto &kv:cur) nodes.push_back(kv);#
#
    #pragma omp parallel for schedule(static)#
    for(std::size_t i=0;i<nodes.size();++i){#
      int tid = omp_get_thread_num();#
      auto &local = locals[tid];#
      const State &st = nodes[i].second;#
      if(st.p < prune) continue;#
#
      State s0 = st;#
      s0.d += 1;#
      s0.p *= p0;#
      if(s0.p >= prune){#
        uint64_t key0 = pack(s0.d,s0.m,s0.S1,s0.S2);#
        auto &ref0 = local[key0];#
        if(ref0.p==0) ref0 = s0; else ref0.p += s0.p;#
      }#
#
      State s1 = st;#
      int dur = s1.d + 1;#
      s1.d  = 0;#
      s1.m += 1;#
      s1.S1+= dur;#
      s1.S2+= dur*dur;#
      s1.p *= p1;#
      if(s1.p >= prune){#
        uint64_t key1 = pack(s1.d,s1.m,s1.S1,s1.S2);#
        auto &ref1 = local[key1];#
        if(ref1.p==0) ref1 = s1; else ref1.p += s1.p;#
      }#
    }#
#
    std::unordered_map<uint64_t,State,std::hash<uint64_t>> nxt;#
    std::size_t total_sz = 0;#
    for(auto &mp:locals) total_sz += mp.size();#
    nxt.reserve(total_sz);#
#
    for(auto &mp:locals)#
      for(auto &kv:mp){#
        auto &ref = nxt[kv.first];#
        if(ref.p==0) ref = kv.second; else ref.p += kv.second.p;#
      }#
#
    cur.swap(nxt);#
  }#
#
  std::unordered_map<double,double> dist;#
  dist.reserve(cur.size());#
  for(auto &kv:cur){#
    const State &st = kv.second;#
    if(st.m==0 || st.p<=0.0) continue;#
    double stat = (double)st.S2 * st.m / ((double)st.S1 * st.S1);#
    dist[stat] += st.p;#
  }#
#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),#
            [](const auto &a,const auto &b){return a.first<b.first;});#
  NumericVector stat(vec.size()),prob(vec.size());#
  for(std::size_t i=0;i<vec.size();++i){ stat[i]=vec[i].first; prob[i]=vec[i].second; }#
  return List::create(Named("stat")=stat,Named("prob")=prob);#
}#
', plugins=c("cpp17","openmp"))#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15) fb_dur_score_fastcpp(n,alpha,prune)#
#
compute_score_stat <- function(x){#
  d <- S1 <- S2 <- m <- 0L#
  for(v in x){#
    d <- d + 1L#
    if(v==1L){#
      m  <- m  + 1L#
      S1 <- S1 + d#
      S2 <- S2 + d*d#
      d  <- 0L#
    }#
  }#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact_score <- function(stat,prob,obs) sum(prob[stat >= obs - 1e-15])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_dur_score(n_,alpha_)#
    stat_vals <- dist$stat#
    prob_vals <- dist$prob#
    abs_diff <- numeric(Nrep)#
    diff_dec <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_,1,alpha_)#
      obs <- compute_score_stat(X)#
      p_exact <- p_exact_score(stat_vals,prob_vals,obs)#
      p_chi   <- 1 - pchisq((obs-1)*alpha_*(n_-1),df=1)#
      abs_diff[i]   <- abs(p_exact - p_chi)#
      diff_decision <- (p_exact < 0.05)!=(p_chi < 0.05)#
      diff_dec[i]   <- diff_decision#
    }#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)#
    ))#
  }#
}#
#
results_plot <- subset(results,!is.na(mean_abs_pval_diff)&!is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot,aes(x=factor(n),y=mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p2 <- ggplot(results_plot,aes(x=factor(n),y=prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
p1/p2#
results
library(Rcpp)#
#
Sys.setenv("PKG_CXXFLAGS"="-O3 -march=native -std=c++17 -fopenmp")#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cstdint>#
#include <omp.h>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
#
inline uint64_t pack(int d,int m,int S1,int S2){#
  return (uint64_t)d#
       | ((uint64_t)m  << 9)#
       | ((uint64_t)S1 << 18)#
       | ((uint64_t)S2 << 35);#
}#
#
// [[Rcpp::export]]#
List fb_dur_score_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  std::unordered_map<uint64_t,State,std::hash<uint64_t>> cur;#
  cur.reserve(1024);#
  cur[pack(0,0,0,0)] = {0,0,0,0,1.0};#
  const double p0 = 1.0 - alpha, p1 = alpha;#
#
  for(int t=0;t<n;++t){#
    std::vector<std::unordered_map<uint64_t,State,std::hash<uint64_t>>> locals(omp_get_max_threads());#
    for(auto &mp:locals) mp.reserve(cur.size()/locals.size()+16);#
#
    std::vector<std::pair<uint64_t,State>> nodes;#
    nodes.reserve(cur.size());#
    for(auto &kv:cur) nodes.push_back(kv);#
#
    #pragma omp parallel for schedule(static)#
    for(std::size_t i=0;i<nodes.size();++i){#
      int tid = omp_get_thread_num();#
      auto &local = locals[tid];#
      const State &st = nodes[i].second;#
      if(st.p < prune) continue;#
#
      State s0 = st;#
      s0.d += 1;#
      s0.p *= p0;#
      if(s0.p >= prune){#
        uint64_t key0 = pack(s0.d,s0.m,s0.S1,s0.S2);#
        auto &ref0 = local[key0];#
        if(ref0.p==0) ref0 = s0; else ref0.p += s0.p;#
      }#
#
      State s1 = st;#
      int dur = s1.d + 1;#
      s1.d  = 0;#
      s1.m += 1;#
      s1.S1+= dur;#
      s1.S2+= dur*dur;#
      s1.p *= p1;#
      if(s1.p >= prune){#
        uint64_t key1 = pack(s1.d,s1.m,s1.S1,s1.S2);#
        auto &ref1 = local[key1];#
        if(ref1.p==0) ref1 = s1; else ref1.p += s1.p;#
      }#
    }#
#
    std::unordered_map<uint64_t,State,std::hash<uint64_t>> nxt;#
    std::size_t total_sz = 0;#
    for(auto &mp:locals) total_sz += mp.size();#
    nxt.reserve(total_sz);#
#
    for(auto &mp:locals)#
      for(auto &kv:mp){#
        auto &ref = nxt[kv.first];#
        if(ref.p==0) ref = kv.second; else ref.p += kv.second.p;#
      }#
#
    cur.swap(nxt);#
  }#
#
  std::unordered_map<double,double> dist;#
  dist.reserve(cur.size());#
  for(auto &kv:cur){#
    const State &st = kv.second;#
    if(st.m==0 || st.p<=0.0) continue;#
    double stat = (double)st.S2 * st.m / ((double)st.S1 * st.S1);#
    dist[stat] += st.p;#
  }#
#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),#
            [](const auto &a,const auto &b){return a.first<b.first;});#
  NumericVector stat(vec.size()),prob(vec.size());#
  for(std::size_t i=0;i<vec.size();++i){ stat[i]=vec[i].first; prob[i]=vec[i].second; }#
  return List::create(Named("stat")=stat,Named("prob")=prob);#
}#
', plugins=c("cpp17","openmp"))#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15) fb_dur_score_fastcpp(n,alpha,prune)#
#
compute_score_stat <- function(x){#
  d <- S1 <- S2 <- m <- 0L#
  for(v in x){#
    d <- d + 1L#
    if(v==1L){#
      m  <- m  + 1L#
      S1 <- S1 + d#
      S2 <- S2 + d*d#
      d  <- 0L#
    }#
  }#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact_score <- function(stat,prob,obs) sum(prob[stat >= obs - 1e-15])
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
#
inline uint64_t pack(int d,int m,int S1,int S2){#
  return (uint64_t)d#
       | ((uint64_t)m  << 9)#
       | ((uint64_t)S1 << 18)#
       | ((uint64_t)S2 << 35);#
}#
#
static inline void push(std::vector<State>& v,const State& s,double prune){#
  if(s.p>=prune) v.push_back(s);#
}#
#
// [[Rcpp::export]]#
List fb_dur_score_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  std::vector<State> cur; cur.reserve(1024);#
  cur.push_back({0,0,0,0,1.0});#
  std::vector<State> nxt; nxt.reserve(1024);#
  const double p0=1.0-alpha, p1=alpha;#
#
  for(int t=0;t<n;++t){#
    nxt.clear();#
    nxt.reserve(cur.size()*2);#
    for(const State& st:cur){#
      if(st.p<prune) continue;#
#
      State s0=st;#
      s0.d+=1;#
      s0.p*=p0;#
      push(nxt,s0,prune);#
#
      State s1=st;#
      int dur=s1.d+1;#
      s1.d=0;#
      s1.m+=1;#
      s1.S1+=dur;#
      s1.S2+=dur*dur;#
      s1.p*=p1;#
      push(nxt,s1,prune);#
    }#
#
    std::sort(nxt.begin(),nxt.end(),[](const State&a,const State&b){#
      return pack(a.d,a.m,a.S1,a.S2)<pack(b.d,b.m,b.S1,b.S2);#
    });#
#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i+1;#
      double ps=nxt[i].p;#
      while(j<nxt.size()&&pack(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==pack(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2)){#
        ps+=nxt[j].p; ++j;#
      }#
      State merged=nxt[i]; merged.p=ps;#
      cur.push_back(merged);#
      i=j;#
    }#
  }#
#
  std::vector<std::pair<double,double>> dist; dist.reserve(cur.size());#
  for(const State& st:cur){#
    if(st.m==0||st.p<=0.0) continue;#
    double stat=(double)st.S2*st.m/((double)st.S1*st.S1);#
    dist.emplace_back(stat,st.p);#
  }#
  std::sort(dist.begin(),dist.end(),[](auto&a,auto&b){return a.first<b.first;});#
#
  std::vector<double> stat,prob; stat.reserve(dist.size()); prob.reserve(dist.size());#
  for(size_t i=0;i<dist.size();){#
    size_t j=i+1;#
    double ps=dist[i].second;#
    while(j<dist.size()&&std::fabs(dist[j].first-dist[i].first)<1e-15){#
      ps+=dist[j].second; ++j;#
    }#
    stat.push_back(dist[i].first); prob.push_back(ps); i=j;#
  }#
  return List::create(_["stat"]=NumericVector(stat.begin(),stat.end()),#
                      _["prob"]=NumericVector(prob.begin(),prob.end()));#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15) fb_dur_score_fastcpp(n,alpha,prune)#
#
compute_score_stat <- function(x){#
  d<-S1<-S2<-m<-0L#
  for(v in x){#
    d<-d+1L#
    if(v==1L){#
      m<-m+1L#
      S1<-S1+d#
      S2<-S2+d*d#
      d<-0L#
    }#
  }#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact_score <- function(stat,prob,obs) sum(prob[stat>=obs-1e-15])
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_dur_score(n_,alpha_)#
    stat_vals <- dist$stat#
    prob_vals <- dist$prob#
    abs_diff <- numeric(Nrep)#
    diff_dec <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_,1,alpha_)#
      obs <- compute_score_stat(X)#
      p_exact <- p_exact_score(stat_vals,prob_vals,obs)#
      p_chi   <- 1 - pchisq((obs-1)*alpha_*(n_-1),df=1)#
      abs_diff[i]   <- abs(p_exact - p_chi)#
      diff_decision <- (p_exact < 0.05)!=(p_chi < 0.05)#
      diff_dec[i]   <- diff_decision#
    }#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)#
    ))#
  }#
}#
#
results_plot <- subset(results,!is.na(mean_abs_pval_diff)&!is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot,aes(x=factor(n),y=mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p2 <- ggplot(results_plot,aes(x=factor(n),y=prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
p1/p2#
results
library(Rcpp)#
library(ggplot2)#
library(patchwork)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
inline uint64_t pack(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<9) | ((uint64_t)S1<<18) | ((uint64_t)S2<<35);#
}#
static inline void push(std::vector<State>&v,const State&s,double prune){ if(s.p>=prune) v.push_back(s); }#
#
// [[Rcpp::export]]#
List fb_dur_score_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  std::vector<State> cur; cur.reserve(1024); cur.push_back({0,0,0,0,1.0});#
  std::vector<State> nxt; nxt.reserve(1024);#
  const double p0=1.0-alpha,p1=alpha;#
  for(int t=0;t<n;++t){#
    nxt.clear(); nxt.reserve(cur.size()*2);#
    for(const State&st:cur){#
      if(st.p<prune) continue;#
      State s0=st; s0.d+=1; s0.p*=p0; push(nxt,s0,prune);#
      State s1=st; int dur=s1.d+1; s1.d=0; s1.m+=1; s1.S1+=dur; s1.S2+=dur*dur; s1.p*=p1; push(nxt,s1,prune);#
    }#
    std::sort(nxt.begin(),nxt.end(),[](const State&a,const State&b){return pack(a.d,a.m,a.S1,a.S2)<pack(b.d,b.m,b.S1,b.S2);});#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i+1; double ps=nxt[i].p;#
      while(j<nxt.size()&&pack(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==pack(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2)){ ps+=nxt[j].p; ++j; }#
      State merged=nxt[i]; merged.p=ps; cur.push_back(merged); i=j;#
    }#
  }#
  std::vector<std::pair<double,double>> dist; dist.reserve(cur.size());#
  for(const State&st:cur){#
    if(st.m==0||st.p<=0.0) continue;#
    double stat=(double)st.S2*st.m/((double)st.S1*st.S1);#
    dist.emplace_back(stat,st.p);#
  }#
  std::sort(dist.begin(),dist.end(),[](auto&a,auto&b){return a.first<b.first;});#
  std::vector<double> stat,prob; stat.reserve(dist.size()); prob.reserve(dist.size());#
  for(size_t i=0;i<dist.size();){#
    size_t j=i+1; double ps=dist[i].second;#
    while(j<dist.size()&&fabs(dist[j].first-dist[i].first)<1e-15){ ps+=dist[j].second; ++j; }#
    stat.push_back(dist[i].first); prob.push_back(ps); i=j;#
  }#
  return List::create(_["stat"]=NumericVector(stat.begin(),stat.end()),#
                      _["prob"]=NumericVector(prob.begin(),prob.end()));#
}#
#
// [[Rcpp::export]]#
NumericVector scores_sim(int n,int B,double alpha){#
  NumericVector out(B);#
  for(int b=0;b<B;++b){#
    IntegerVector x = Rcpp::rbinom(n,1,alpha);#
    int d=0,m=0,S1=0,S2=0;#
    for(int v:x){#
      d+=1;#
      if(v==1){ ++m; S1+=d; S2+=d*d; d=0; }#
    }#
    out[b] = m==0?0.0 : (double)S2*m/((double)S1*S1);#
  }#
  return out;#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15) fb_dur_score_fastcpp(n,alpha,prune)#
p_exact_fast <- function(obs,stat_vals,tail_cdf){#
  idx <- findInterval(obs,stat_vals) + 1L#
  tail_cdf[idx]#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_dur_score(n_,alpha_)#
    stat_vals <- dist$stat#
    tail_cdf <- rev(cumsum(rev(dist$prob)))#
    sim_scores <- scores_sim(n_,Nrep,alpha_)#
    p_exact <- p_exact_fast(sim_scores,stat_vals,tail_cdf)#
    chi_arg <- (sim_scores-1)*alpha_*(n_-1)#
    p_chi <- 1 - pchisq(chi_arg,df=1)#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      mean_abs_pval_diff=mean(abs(p_exact-p_chi)),#
      prop_diff_in_decision=mean((p_exact<0.05)!=(p_chi<0.05))#
    ))#
  }#
}#
#
results_plot <- subset(results,!is.na(mean_abs_pval_diff)&!is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot,aes(x=factor(n),y=mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p2 <- ggplot(results_plot,aes(x=factor(n),y=prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
print(p1/p2)#
print(results)
library(Rcpp)#
library(ggplot2)#
library(patchwork)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
#include <cmath>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
#
inline uint64_t pack(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<9) | ((uint64_t)S1<<18) | ((uint64_t)S2<<35);#
}#
#
static inline void push(std::vector<State>& v,const State& s,double prune){#
  if(s.p>=prune) v.push_back(s);#
}#
#
// [[Rcpp::export]]#
List fb_dur_score_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  std::vector<State> cur; cur.reserve(1024);#
  cur.push_back({0,0,0,0,1.0});#
  std::vector<State> nxt; nxt.reserve(1024);#
  const double p0 = 1.0 - alpha, p1 = alpha;#
#
  for(int t=0; t<n; ++t){#
    nxt.clear(); nxt.reserve(cur.size()*2);#
    for(const State& st : cur){#
      if(st.p < prune) continue;#
#
      State s0 = st;#
      s0.d += 1;#
      s0.p *= p0;#
      push(nxt,s0,prune);#
#
      State s1 = st;#
      int dur = s1.d + 1;#
      s1.d  = 0;#
      s1.m += 1;#
      s1.S1+= dur;#
      s1.S2+= dur*dur;#
      s1.p *= p1;#
      push(nxt,s1,prune);#
    }#
#
    std::sort(nxt.begin(),nxt.end(),#
      [](const State&a,const State&b){ return pack(a.d,a.m,a.S1,a.S2) < pack(b.d,b.m,b.S1,b.S2); });#
#
    cur.clear();#
    for(std::size_t i=0;i<nxt.size();){#
      std::size_t j=i+1;#
      double ps=nxt[i].p;#
      while(j<nxt.size() && pack(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==#
                            pack(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2)){#
        ps += nxt[j].p; ++j;#
      }#
      State merged = nxt[i]; merged.p = ps;#
      cur.push_back(merged);#
      i = j;#
    }#
  }#
#
  std::vector<std::pair<double,double>> dist; dist.reserve(cur.size());#
  for(const State& st : cur){#
    if(st.m==0 || st.p<=0.0) continue;#
    double stat = (double)st.S2*st.m / ((double)st.S1*st.S1);#
    dist.emplace_back(stat,st.p);#
  }#
  std::sort(dist.begin(),dist.end(),#
            [](auto&a,auto&b){ return a.first < b.first; });#
#
  std::vector<double> stat,prob;#
  for(std::size_t i=0;i<dist.size();){#
    std::size_t j=i+1; double ps=dist[i].second;#
    while(j<dist.size() && std::fabs(dist[j].first - dist[i].first) < 1e-15){#
      ps += dist[j].second; ++j;#
    }#
    stat.push_back(dist[i].first);#
    prob.push_back(ps);#
    i=j;#
  }#
  return List::create(_["stat"]=NumericVector(stat.begin(),stat.end()),#
                      _["prob"]=NumericVector(prob.begin(),prob.end()));#
}#
#
// [[Rcpp::export]]#
NumericVector scores_sim(int n,int B,double alpha){#
  NumericVector out(B);#
  for(int b=0;b<B;++b){#
    IntegerVector x = Rcpp::rbinom(n,1,alpha);#
    int d=0,m=0,S1=0,S2=0;#
    for(int v : x){#
      d += 1;#
      if(v==1){#
        ++m; S1 += d; S2 += d*d; d = 0;#
      }#
    }#
    out[b] = m==0 ? 0.0 : (double)S2*m / ((double)S1*S1);#
  }#
  return out;#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15) fb_dur_score_fastcpp(n,alpha,prune)#
#
p_exact_fast <- function(obs,stat_vals,tail_cdf){#
  idx <- findInterval(obs,stat_vals) + 1L#
  tail_cdf[idx]#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_dur_score(n_,alpha_)#
    stat_vals <- dist$stat#
    tail_cdf <- rev(cumsum(rev(dist$prob)))#
#
    sim_scores <- scores_sim(n_,Nrep,alpha_)#
    p_exact <- p_exact_fast(sim_scores,stat_vals,tail_cdf)#
#
    chi_arg <- (sim_scores - 1) * alpha_ * (n_ - 1)#
    p_chi <- 1 - pchisq(chi_arg, df = 1)#
#
    results <- rbind(results,#
                     data.frame(n = n_,#
                                alpha = alpha_,#
                                mean_abs_pval_diff = mean(abs(p_exact - p_chi)),#
                                prop_diff_in_decision = mean((p_exact < 0.05) != (p_chi < 0.05))))#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x = factor(n), y = mean_abs_pval_diff, fill = factor(alpha))) +#
  geom_bar(stat = "identity", position = "dodge") +#
  labs(x = "n", y = "mean_abs_pval_diff", fill = "alpha") +#
  theme_minimal()#
p2 <- ggplot(results_plot, aes(x = factor(n), y = prop_diff_in_decision, fill = factor(alpha))) +#
  geom_bar(stat = "identity", position = "dodge") +#
  labs(x = "n", y = "prop_diff_in_decision", fill = "alpha") +#
  theme_minimal()#
#
print(p1 / p2)#
print(results)
Sys.setenv("PKG_CXXFLAGS"="-O3 -march=native -std=c++17")#
#
library(Rcpp)#
library(ggplot2)#
library(patchwork)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
#include <cmath>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
inline uint64_t pack(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<9) | ((uint64_t)S1<<18) | ((uint64_t)S2<<35);#
}#
inline void push(std::vector<State>& v,const State& s,double pr){ if(s.p>=pr) v.push_back(s); }#
#
// [[Rcpp::export]]#
List fb_dur_score_fastcpp(int n,double alpha=0.05,double pr=1e-15){#
  std::vector<State> cur(1,{0,0,0,0,1.0}), nxt; const double p0=1-alpha,p1=alpha;#
  for(int t=0;t<n;++t){#
    nxt.clear(); nxt.reserve(cur.size()*2);#
    for(const State& st:cur){#
      if(st.p<pr) continue;#
      State a=st; a.d+=1; a.p*=p0; push(nxt,a,pr);#
      State b=st; int dur=b.d+1; b.d=0; b.m+=1; b.S1+=dur; b.S2+=dur*dur; b.p*=p1; push(nxt,b,pr);#
    }#
    std::sort(nxt.begin(),nxt.end(),#
      [](const State&x,const State&y){return pack(x.d,x.m,x.S1,x.S2)<pack(y.d,y.m,y.S1,y.S2);});#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i; double ps=0;#
      uint64_t key=pack(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2);#
      while(j<nxt.size() && pack(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==key) ps+=nxt[j++].p;#
      State merged=nxt[i]; merged.p=ps; cur.push_back(merged); i=j;#
    }#
  }#
  std::vector<double> stat,prob;#
  for(const State& st:cur){#
    if(st.m==0||st.p<=0) continue;#
    double s=(double)st.S2*st.m/((double)st.S1*st.S1);#
    stat.push_back(s); prob.push_back(st.p);#
  }#
  NumericVector sv(stat.begin(),stat.end()), pv(prob.begin(),prob.end());#
  IntegerVector ord = seq(0,sv.size()-1);#
  sort(sv.begin(),sv.end(),ord.begin());#
  pv = pv[ord];#
  return List::create(_["stat"]=sv,_["prob"]=pv);#
}#
#
// [[Rcpp::export]]#
NumericVector scores_sim(int n,int B,double alpha){#
  NumericVector out(B);#
  for(int b=0;b<B;++b){#
    NumericVector x = Rcpp::rbinom(n,1,alpha);   // 修正处#
    int d=0,m=0,S1=0,S2=0;#
    for(double v:x){#
      d+=1;#
      if(v>0.5){#
        ++m; S1+=d; S2+=d*d; d=0;#
      }#
    }#
    out[b]= m==0?0.0 : (double)S2*m/((double)S1*S1);#
  }#
  return out;#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15) fb_dur_score_fastcpp(n,alpha,prune)#
p_exact_fast <- function(obs,stat_vals,tail_cdf){#
  idx <- findInterval(obs,stat_vals) + 1L#
  tail_cdf[idx]#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_dur_score(n_,alpha_)#
    stat_vals <- dist$stat#
    tail_cdf <- rev(cumsum(rev(dist$prob)))#
    sim_scores <- scores_sim(n_,Nrep,alpha_)#
    p_exact <- p_exact_fast(sim_scores,stat_vals,tail_cdf)#
    chi_arg <- (sim_scores-1)*alpha_*(n_-1)#
    p_chi <- 1-pchisq(chi_arg,df=1)#
    results <- rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      mean_abs_pval_diff=mean(abs(p_exact-p_chi)),#
      prop_diff_in_decision=mean((p_exact<0.05)!=(p_chi<0.05))))#
  }#
}#
#
results_plot <- subset(results,!is.na(mean_abs_pval_diff)&!is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+theme_minimal()#
p2 <- ggplot(results_plot,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+theme_minimal()#
#
print(p1/p2)#
print(results)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
inline uint64_t k(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<10) | ((uint64_t)S1<<20) | ((uint64_t)S2<<36);#
}#
inline void add(std::vector<State>&v,const State&s,double pr){ if(s.p>=pr) v.push_back(s); }#
#
// [[Rcpp::export]]#
List fb_dur_score_beam(int n,double alpha=0.05,int K=50000,double pr=1e-15){#
  std::vector<State> cur(1,{0,0,0,0,1.0}), nxt;#
  const double p0=1-alpha, p1=alpha;#
  for(int t=0;t<n;++t){#
    nxt.clear(); nxt.reserve(std::min(K*2,(int)cur.size()*2));#
    for(const State& st:cur){#
      if(st.p<pr) continue;#
      State a=st; a.d+=1; a.p*=p0; add(nxt,a,pr);#
      State b=st; int dur=b.d+1; b.d=0; b.m+=1; b.S1+=dur; b.S2+=dur*dur; b.p*=p1; add(nxt,b,pr);#
    }#
    std::partial_sort(nxt.begin(),nxt.begin()+std::min(K,(int)nxt.size()),nxt.end(),#
                      [](const State&a,const State&b){return a.p>b.p;});#
    if((int)nxt.size()>K) nxt.resize(K);#
    std::sort(nxt.begin(),nxt.end(),#
              [](const State&a,const State&b){return k(a.d,a.m,a.S1,a.S2)<k(b.d,b.m,b.S1,b.S2);});#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i; double ps=0; uint64_t key=k(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2);#
      while(j<nxt.size()&&k(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==key){ps+=nxt[j].p;++j;}#
      State m=nxt[i]; m.p=ps; cur.push_back(m); i=j;#
    }#
  }#
  std::vector<std::pair<double,double>> vec; vec.reserve(cur.size());#
  for(const State& st:cur){#
    if(st.m==0||st.p<=0) continue;#
    double s=(double)st.S2*st.m/((double)st.S1*st.S1);#
    vec.emplace_back(s,st.p);#
  }#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  std::vector<double> stat,prob;#
  for(size_t i=0;i<vec.size();){#
    size_t j=i; double ps=0; double val=vec[i].first;#
    while(j<vec.size()&&fabs(vec[j].first-val)<1e-15){ps+=vec[j].second;++j;}#
    stat.push_back(val); prob.push_back(ps); i=j;#
  }#
  return List::create(_["stat"]=NumericVector(stat.begin(),stat.end()),#
                      _["prob"]=NumericVector(prob.begin(),prob.end()));#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15){#
  K <- 50000#
  if(n<=100) K <- 20000#
  fb_dur_score_beam(n,alpha,K,prune)#
}#
#
compute_score_stat <- function(X){#
  d<-S1<-S2<-m<-0L#
  for(v in X){d<-d+1L;if(v==1L){m<-m+1L;S1<-S1+d;S2<-S2+d*d;d<-0L}}#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact_score <- function(stat,prob,obs) sum(prob[stat>=obs-1e-15])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_dur_score(n_,alpha_)#
    stat_vals <- dist$stat#
    prob_vals <- dist$prob#
    abs_diff <- numeric(Nrep)#
    diff_dec <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_,1,alpha_)#
      obs <- compute_score_stat(X)#
      p_exact <- p_exact_score(stat_vals,prob_vals,obs)#
      p_chi   <- 1-pchisq((obs-1)*alpha_*(n_-1),df=1)#
      abs_diff[i] <- abs(p_exact-p_chi)#
      diff_dec[i] <- (p_exact<0.05)!=(p_chi<0.05)#
    }#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)))#
  }#
}#
#
results_plot <- subset(results,!is.na(mean_abs_pval_diff)&!is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+theme_minimal()#
p2 <- ggplot(results_plot,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+theme_minimal()#
p1/p2#
results
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
using namespace Rcpp;#
#
struct St{int d,m,S1,S2;double p;};#
inline uint64_t k(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<10) | ((uint64_t)S1<<20) | ((uint64_t)S2<<36);#
}#
inline void add(std::vector<St>&v,const St&s,double pr){ if(s.p>=pr) v.push_back(s); }#
#
// [[Rcpp::export]]#
List fb_dur_score_beam(int n,double a=0.05,int K=30000,double pr=1e-15){#
  std::vector<St> cur(1,{0,0,0,0,1.0}), nxt;#
  const double p0=1-a,p1=a;#
  for(int t=0;t<n;++t){#
    nxt.clear(); nxt.reserve(std::min(K*2,(int)cur.size()*2));#
    for(const St& st:cur){#
      if(st.p<pr) continue;#
      St u=st; u.d+=1; u.p*=p0; add(nxt,u,pr);#
      St v=st; int dur=v.d+1; v.d=0; v.m+=1; v.S1+=dur; v.S2+=dur*dur; v.p*=p1; add(nxt,v,pr);#
    }#
    std::partial_sort(nxt.begin(),nxt.begin()+std::min(K,(int)nxt.size()),nxt.end(),#
                      [](const St&a,const St&b){return a.p>b.p;});#
    if((int)nxt.size()>K) nxt.resize(K);#
    std::sort(nxt.begin(),nxt.end(),#
      [](const St&a,const St&b){return k(a.d,a.m,a.S1,a.S2)<k(b.d,b.m,b.S1,b.S2);});#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i; double ps=0; uint64_t key=k(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2);#
      while(j<nxt.size()&&k(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==key){ps+=nxt[j].p;++j;}#
      St m=nxt[i]; m.p=ps; cur.push_back(m); i=j;#
    }#
  }#
  std::vector<double> stat,prob;#
  for(const St& st:cur){#
    if(st.m==0||st.p<=0) continue;#
    double s=(double)st.S2*st.m/((double)st.S1*st.S1);#
    stat.push_back(s); prob.push_back(st.p);#
  }#
  NumericVector sv(stat.begin(),stat.end()), pv(prob.begin(),prob.end());#
  IntegerVector ord = seq(0,sv.size()-1);#
  sort(sv.begin(),sv.end(),ord.begin());#
  pv = pv[ord];#
  return List::create(_["stat"]=sv,_["prob"]=pv);#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15){#
  K <- if(n<=100) 20000 else 30000#
  fb_dur_score_beam(n,alpha,K,prune)#
}#
#
compute_score_stat <- function(x){#
  d<-S1<-S2<-m<-0L#
  for(v in x){d<-d+1L;if(v==1L){m<-m+1L;S1<-S1+d;S2<-S2+d*d;d<-0L}}#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact_tail <- function(obs,stat,tail){tail[findInterval(obs,stat)+1L]}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_dur_score(n_,alpha_)#
    stat_vals <- dist$stat#
    tail_cdf  <- rev(cumsum(rev(dist$prob)))#
    abs_diff <- numeric(Nrep)#
    diff_dec <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_,1,alpha_)#
      obs <- compute_score_stat(X)#
      p_exact <- p_exact_tail(obs,stat_vals,tail_cdf)#
      p_chi   <- 1-pchisq((obs-1)*alpha_*(n_-1),df=1)#
      abs_diff[i] <- abs(p_exact-p_chi)#
      diff_dec[i] <- (p_exact<0.05)!=(p_chi<0.05)#
    }#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)))#
  }#
}#
#
rp <- results#
p1 <- ggplot(rp,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
        geom_bar(stat="identity",position="dodge")+theme_minimal()#
p2 <- ggplot(rp,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
        geom_bar(stat="identity",position="dodge")+theme_minimal()#
print(p1/p2)#
print(results)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
inline uint64_t k(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<10) | ((uint64_t)S1<<20) | ((uint64_t)S2<<36);#
}#
inline void add(std::vector<State>&v,const State&s,double pr){ if(s.p>=pr) v.push_back(s); }#
#
// [[Rcpp::export]]#
List fb_dur_score_beam(int n,double alpha=0.05,int K=30000,double pr=1e-15){#
  std::vector<State> cur(1,{0,0,0,0,1.0}), nxt;#
  const double p0=1-alpha, p1=alpha;#
  for(int t=0;t<n;++t){#
    nxt.clear(); nxt.reserve(std::min(K*2,(int)cur.size()*2));#
    for(const State& st:cur){#
      if(st.p<pr) continue;#
      State a=st; a.d+=1; a.p*=p0; add(nxt,a,pr);#
      State b=st; int dur=b.d+1; b.d=0; b.m+=1; b.S1+=dur; b.S2+=dur*dur; b.p*=p1; add(nxt,b,pr);#
    }#
    std::partial_sort(nxt.begin(),nxt.begin()+std::min(K,(int)nxt.size()),nxt.end(),#
                      [](const State&a,const State&b){return a.p>b.p;});#
    if((int)nxt.size()>K) nxt.resize(K);#
    std::sort(nxt.begin(),nxt.end(),#
              [](const State&a,const State&b){return k(a.d,a.m,a.S1,a.S2)<k(b.d,b.m,b.S1,b.S2);});#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i; double ps=0; uint64_t key=k(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2);#
      while(j<nxt.size()&&k(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==key){ps+=nxt[j].p;++j;}#
      State m=nxt[i]; m.p=ps; cur.push_back(m); i=j;#
    }#
  }#
  std::vector<std::pair<double,double>> vec; vec.reserve(cur.size());#
  for(const State& st:cur){#
    if(st.m==0||st.p<=0) continue;#
    double s=(double)st.S2*st.m/((double)st.S1*st.S1);#
    vec.emplace_back(s,st.p);#
  }#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  std::vector<double> stat,prob;#
  for(size_t i=0;i<vec.size();){#
    size_t j=i; double ps=0; double val=vec[i].first;#
    while(j<vec.size()&&std::fabs(vec[j].first-val)<1e-15){ps+=vec[j].second;++j;}#
    stat.push_back(val); prob.push_back(ps); i=j;#
  }#
  return List::create(_["stat"]=NumericVector(stat.begin(),stat.end()),#
                      _["prob"]=NumericVector(prob.begin(),prob.end()));#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15){#
  K <- if(n<=100) 20000 else 30000#
  fb_dur_score_beam(n,alpha,K,prune)#
}#
#
compute_score_stat <- function(x){#
  d<-S1<-S2<-m<-0L#
  for(v in x){d<-d+1L;if(v==1L){m<-m+1L;S1<-S1+d;S2<-S2+d*d;d<-0L}}#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact_score <- function(stat,prob,obs) sum(prob[stat>=obs-1e-15])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    t0 <- proc.time()[3]#
    dist <- fb_dur_score(n_,alpha_)#
    gen_time <- proc.time()[3]-t0#
#
    stat_vals <- dist$stat#
    prob_vals <- dist$prob#
#
    t1 <- proc.time()[3]#
    abs_diff <- numeric(Nrep)#
    diff_dec <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_,1,alpha_)#
      obs <- compute_score_stat(X)#
      p_exact <- p_exact_score(stat_vals,prob_vals,obs)#
      p_chi   <- 1-pchisq((obs-1)*alpha_*(n_-1),df=1)#
      abs_diff[i] <- abs(p_exact-p_chi)#
      diff_dec[i] <- (p_exact<0.05)!=(p_chi<0.05)#
    }#
    sim_time <- proc.time()[3]-t1#
#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      gen_time=gen_time,#
      sim_time=sim_time,#
      total_time=gen_time+sim_time,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)))#
  }#
}#
#
p_time <- ggplot(results,aes(factor(n),total_time,fill=factor(alpha)))+#
            geom_bar(stat="identity",position="dodge")+theme_minimal()+#
            labs(y="seconds",title="Total runtime")#
#
p1 <- ggplot(results,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
        geom_bar(stat="identity",position="dodge")+theme_minimal()#
p2 <- ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
        geom_bar(stat="identity",position="dodge")+theme_minimal()#
#
print(p_time)#
print(p1/p2)#
print(results)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
inline uint64_t k(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<10) | ((uint64_t)S1<<20) | ((uint64_t)S2<<36);#
}#
inline void add(std::vector<State>&v,const State&s,double pr){ if(s.p>=pr) v.push_back(s); }#
#
// [[Rcpp::export]]#
List fb_dur_score_beam(int n,double alpha=0.05,int K=30000,double pr=1e-15){#
  std::vector<State> cur(1,{0,0,0,0,1.0}), nxt;#
  const double p0=1-alpha, p1=alpha;#
  for(int t=0;t<n;++t){#
    nxt.clear(); nxt.reserve(std::min(K*2,(int)cur.size()*2));#
    for(const State& st:cur){#
      if(st.p<pr) continue;#
      State a=st; a.d+=1; a.p*=p0; add(nxt,a,pr);#
      State b=st; int dur=b.d+1; b.d=0; b.m+=1; b.S1+=dur; b.S2+=dur*dur; b.p*=p1; add(nxt,b,pr);#
    }#
    std::partial_sort(nxt.begin(),nxt.begin()+std::min(K,(int)nxt.size()),nxt.end(),#
                      [](const State&a,const State&b){return a.p>b.p;});#
    if((int)nxt.size()>K) nxt.resize(K);#
    std::sort(nxt.begin(),nxt.end(),#
              [](const State&a,const State&b){return k(a.d,a.m,a.S1,a.S2)<k(b.d,b.m,b.S1,b.S2);});#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i; double ps=0; uint64_t key=k(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2);#
      while(j<nxt.size()&&k(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==key){ps+=nxt[j].p;++j;}#
      State m=nxt[i]; m.p=ps; cur.push_back(m); i=j;#
    }#
  }#
  std::vector<std::pair<double,double>> vec; vec.reserve(cur.size());#
  for(const State& st:cur){#
    if(st.m==0||st.p<=0) continue;#
    double s=(double)st.S2*st.m/((double)st.S1*st.S1);#
    vec.emplace_back(s,st.p);#
  }#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  std::vector<double> stat,prob;#
  for(size_t i=0;i<vec.size();){#
    size_t j=i; double ps=0; double val=vec[i].first;#
    while(j<vec.size()&&std::fabs(vec[j].first-val)<1e-15){ps+=vec[j].second;++j;}#
    stat.push_back(val); prob.push_back(ps); i=j;#
  }#
  return List::create(_["stat"]=NumericVector(stat.begin(),stat.end()),#
                      _["prob"]=NumericVector(prob.begin(),prob.end()));#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15){#
  K <- if(n<=100) 20000 else 30000#
  fb_dur_score_beam(n,alpha,K,prune)#
}#
#
compute_score_stat <- function(x){#
  d<-S1<-S2<-m<-0L#
  for(v in x){d<-d+1L;if(v==1L){m<-m+1L;S1<-S1+d;S2<-S2+d*d;d<-0L}}#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact_score <- function(stat,prob,obs) sum(prob[stat>=obs-1e-15])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    t0 <- proc.time()[3]#
    dist <- fb_dur_score(n_,alpha_)#
    gen_time <- proc.time()[3]-t0#
#
    stat_vals <- dist$stat#
    prob_vals <- dist$prob#
    prob_sum  <- sum(prob_vals)#
#
    t1 <- proc.time()[3]#
    abs_diff <- numeric(Nrep)#
    diff_dec <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_,1,alpha_)#
      obs <- compute_score_stat(X)#
      p_exact <- p_exact_score(stat_vals,prob_vals,obs)#
      p_chi   <- 1-pchisq((obs-1)*alpha_*(n_-1),df=1)#
      abs_diff[i] <- abs(p_exact-p_chi)#
      diff_dec[i] <- (p_exact<0.05)!=(p_chi<0.05)#
    }#
    sim_time <- proc.time()[3]-t1#
#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      prob_sum=prob_sum,#
      gen_time=gen_time,#
      sim_time=sim_time,#
      total_time=gen_time+sim_time,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)))#
  }#
}#
#
p_time <- ggplot(results,aes(factor(n),total_time,fill=factor(alpha)))+#
            geom_bar(stat="identity",position="dodge")+theme_minimal()+#
            labs(y="seconds",title="Total runtime")#
#
p1 <- ggplot(results,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
        geom_bar(stat="identity",position="dodge")+theme_minimal()#
p2 <- ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
        geom_bar(stat="identity",position="dodge")+theme_minimal()#
#
print(p_time)#
print(p1/p2)#
print(results)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
inline uint64_t k(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<10) | ((uint64_t)S1<<20) | ((uint64_t)S2<<36);#
}#
inline void add(std::vector<State>&v,const State&s,double pr){ if(s.p>=pr) v.push_back(s); }#
#
// [[Rcpp::export]]#
List fb_dur_score_beam(int n,double alpha,int K,double pr){#
  std::vector<State> cur(1,{0,0,0,0,1.0}), nxt;#
  const double p0=1-alpha, p1=alpha;#
  for(int t=0;t<n;++t){#
    nxt.clear(); nxt.reserve(std::min(K*2,(int)cur.size()*2));#
    for(const State& st:cur){#
      if(st.p<pr) continue;#
      State a=st; a.d+=1; a.p*=p0; add(nxt,a,pr);#
      State b=st; int dur=b.d+1; b.d=0; b.m+=1; b.S1+=dur; b.S2+=dur*dur; b.p*=p1; add(nxt,b,pr);#
    }#
    std::partial_sort(nxt.begin(),nxt.begin()+std::min(K,(int)nxt.size()),nxt.end(),#
                      [](const State&a,const State&b){return a.p>b.p;});#
    if((int)nxt.size()>K) nxt.resize(K);#
    std::sort(nxt.begin(),nxt.end(),#
      [](const State&a,const State&b){return k(a.d,a.m,a.S1,a.S2)<k(b.d,b.m,b.S1,b.S2);});#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i; double ps=0; uint64_t key=k(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2);#
      while(j<nxt.size()&&k(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==key){ps+=nxt[j].p;++j;}#
      State m=nxt[i]; m.p=ps; cur.push_back(m); i=j;#
    }#
  }#
  std::vector<std::pair<double,double>> vec; vec.reserve(cur.size());#
  for(const State& st:cur){#
    if(st.m==0||st.p<=0) continue;#
    double s=(double)st.S2*st.m/((double)st.S1*st.S1);#
    vec.emplace_back(s,st.p);#
  }#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  std::vector<double> stat,prob;#
  for(size_t i=0;i<vec.size();){#
    size_t j=i; double ps=0; double val=vec[i].first;#
    while(j<vec.size()&&std::fabs(vec[j].first-val)<1e-15){ps+=vec[j].second;++j;}#
    stat.push_back(val); prob.push_back(ps); i=j;#
  }#
  return List::create(_["stat"]=NumericVector(stat.begin(),stat.end()),#
                      _["prob"]=NumericVector(prob.begin(),prob.end()));#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,prune=1e-15,eps=1e-6){#
  K <- 20000#
  repeat{#
    dist <- fb_dur_score_beam(n,alpha,K,prune)#
    if(sum(dist$prob) >= 1-eps || K > 500000) return(dist)#
    K <- K*2#
  }#
}#
#
compute_score_stat <- function(x){#
  d<-S1<-S2<-m<-0L#
  for(v in x){d<-d+1L;if(v==1L){m<-m+1L;S1<-S1+d;S2<-S2+d*d;d<-0L}}#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact_score <- function(stat,prob,obs) sum(prob[stat>=obs-1e-15])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    t0 <- proc.time()[3]#
    dist <- fb_dur_score(n_,alpha_)#
    gen_time <- proc.time()[3]-t0#
    prob_sum <- sum(dist$prob)#
#
    stat_vals <- dist$stat#
    prob_vals <- dist$prob#
#
    t1 <- proc.time()[3]#
    abs_diff <- numeric(Nrep)#
    diff_dec <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_,1,alpha_)#
      obs <- compute_score_stat(X)#
      p_exact <- p_exact_score(stat_vals,prob_vals,obs)#
      p_chi   <- 1-pchisq((obs-1)*alpha_*(n_-1),df=1)#
      abs_diff[i] <- abs(p_exact-p_chi)#
      diff_dec[i] <- (p_exact<0.05)!=(p_chi<0.05)#
    }#
    sim_time <- proc.time()[3]-t1#
#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      prob_sum=prob_sum,#
      gen_time=gen_time,#
      sim_time=sim_time,#
      total_time=gen_time+sim_time,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)))#
  }#
}#
#
p_time <- ggplot(results,aes(factor(n),total_time,fill=factor(alpha)))+#
            geom_bar(stat="identity",position="dodge")+theme_minimal()+#
            labs(y="seconds",title="Total runtime")#
#
p1 <- ggplot(results,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
        geom_bar(stat="identity",position="dodge")+theme_minimal()#
p2 <- ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
        geom_bar(stat="identity",position="dodge")+theme_minimal()#
#
print(p_time)#
print(p1/p2)#
print(results)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
using namespace Rcpp;#
#
struct State{int d;int m;int S1;int S2;double p;};#
inline uint64_t key(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<10) | ((uint64_t)S1<<20) | ((uint64_t)S2<<36);#
}#
inline void push(std::vector<State>&v,const State&s,double pr){ if(s.p>=pr) v.push_back(s); }#
#
// [[Rcpp::export]]#
List fb_dur_score_thresh(int n,double alpha=0.05,double eps_layer=1e-9,double pr=1e-15){#
  std::vector<State> cur(1,{0,0,0,0,1.0}), nxt;#
  const double p0=1-alpha, p1=alpha;#
#
  for(int t=0;t<n;++t){#
    nxt.clear();#
    nxt.reserve(cur.size()*2);#
#
    for(const State& st:cur){#
      if(st.p<pr) continue;#
      State a=st; a.d+=1; a.p*=p0; push(nxt,a,pr);#
      State b=st; int dur=b.d+1; b.d=0; b.m+=1; b.S1+=dur; b.S2+=dur*dur; b.p*=p1; push(nxt,b,pr);#
    }#
#
    std::sort(nxt.begin(),nxt.end(),#
              [](const State&a,const State&b){return a.p>b.p;});#
#
    double acc=0.0;#
    size_t keep=0;#
    while(keep<nxt.size() && acc<1.0-eps_layer){acc+=nxt[keep].p;++keep;}#
    nxt.resize(keep);#
#
    std::sort(nxt.begin(),nxt.end(),#
              [](const State&a,const State&b){return key(a.d,a.m,a.S1,a.S2)<key(b.d,b.m,b.S1,b.S2);});#
#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i; double ps=0; uint64_t k=key(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2);#
      while(j<nxt.size() && key(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==k){ps+=nxt[j].p;++j;}#
      State m=nxt[i]; m.p=ps; cur.push_back(m); i=j;#
    }#
  }#
#
  std::vector<std::pair<double,double>> vec; vec.reserve(cur.size());#
  for(const State& st:cur){#
    if(st.m==0||st.p<=0.0) continue;#
    double s=(double)st.S2*st.m/((double)st.S1*st.S1);#
    vec.emplace_back(s,st.p);#
  }#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
#
  std::vector<double> stat,prob;#
  for(size_t i=0;i<vec.size();){#
    size_t j=i; double ps=0; double v=vec[i].first;#
    while(j<vec.size() && std::fabs(vec[j].first-v)<1e-15){ps+=vec[j].second;++j;}#
    stat.push_back(v); prob.push_back(ps); i=j;#
  }#
  return List::create(_["stat"]=NumericVector(stat.begin(),stat.end()),#
                      _["prob"]=NumericVector(prob.begin(),prob.end()));#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,eps_layer=1e-9,prune=1e-15){#
  fb_dur_score_thresh(n,alpha,eps_layer,prune)#
}#
#
compute_score_stat <- function(x){#
  d<-S1<-S2<-m<-0L#
  for(v in x){d<-d+1L;if(v==1L){m<-m+1L;S1<-S1+d;S2<-S2+d*d;d<-0L}}#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact_score <- function(stat,prob,obs) sum(prob[stat>=obs-1e-15])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    t0 <- proc.time()[3]#
    dist <- fb_dur_score(n_,alpha_)#
    gen_time <- proc.time()[3]-t0#
    prob_sum <- sum(dist$prob)#
#
    stat_vals <- dist$stat#
    prob_vals <- dist$prob#
#
    t1 <- proc.time()[3]#
    abs_diff <- numeric(Nrep)#
    diff_dec <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_,1,alpha_)#
      obs <- compute_score_stat(X)#
      p_exact <- p_exact_score(stat_vals,prob_vals,obs)#
      p_chi   <- 1-pchisq((obs-1)*alpha_*(n_-1),df=1)#
      abs_diff[i] <- abs(p_exact-p_chi)#
      diff_dec[i] <- (p_exact<0.05)!=(p_chi<0.05)#
    }#
    sim_time <- proc.time()[3]-t1#
#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      prob_sum=prob_sum,#
      gen_time=gen_time,#
      sim_time=sim_time,#
      total_time=gen_time+sim_time,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)))#
  }#
}#
#
p_time <- ggplot(results,aes(factor(n),total_time,fill=factor(alpha)))+#
            geom_bar(stat="identity",position="dodge")+theme_minimal()+#
            labs(y="seconds",title="Total runtime")#
#
p1 <- ggplot(results,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
        geom_bar(stat="identity",position="dodge")+theme_minimal()#
p2 <- ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
        geom_bar(stat="identity",position="dodge")+theme_minimal()#
#
print(p_time)#
print(p1/p2)#
print(results)
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
using namespace Rcpp;#
#
struct S{int d,m,S1,S2;double p;};#
inline uint64_t k(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<10) | ((uint64_t)S1<<20) | ((uint64_t)S2<<36);#
}#
inline void add(std::vector<S>&v,const S&s,double pr){ if(s.p>=pr) v.push_back(s); }#
#
// [[Rcpp::export]]#
List fb_dur_score_mass(int n,double alpha,double mass_target=0.999,double pr=1e-15){#
  double eps_layer = (1.0 - mass_target) / n;#
  std::vector<S> cur(1,{0,0,0,0,1.0}), nxt;#
  const double p0 = 1-alpha, p1 = alpha;#
#
  for(int t=0;t<n;++t){#
    nxt.clear(); nxt.reserve(cur.size()*2);#
    for(const S& st:cur){#
      if(st.p<pr) continue;#
      S a=st; a.d+=1; a.p*=p0; add(nxt,a,pr);#
      S b=st; int dur=b.d+1; b.d=0; b.m+=1; b.S1+=dur; b.S2+=dur*dur; b.p*=p1; add(nxt,b,pr);#
    }#
    std::sort(nxt.begin(),nxt.end(),[](const S&a,const S&b){return a.p>b.p;});#
    double acc=0.0; size_t keep=0;#
    while(keep<nxt.size() && acc < 1.0-eps_layer){acc += nxt[keep].p; ++keep;}#
    nxt.resize(keep);#
#
    std::sort(nxt.begin(),nxt.end(),[](const S&a,const S&b){return k(a.d,a.m,a.S1,a.S2)<k(b.d,b.m,b.S1,b.S2);});#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i; double ps=0; uint64_t key=k(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2);#
      while(j<nxt.size() && k(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==key){ps+=nxt[j].p;++j;}#
      S m=nxt[i]; m.p=ps; cur.push_back(m); i=j;#
    }#
  }#
#
  std::vector<double> stat,prob;#
  for(const S& st:cur){#
    if(st.m==0||st.p<=0) continue;#
    double s=(double)st.S2*st.m/((double)st.S1*st.S1);#
    stat.push_back(s); prob.push_back(st.p);#
  }#
  NumericVector sv(stat.begin(),stat.end()), pv(prob.begin(),prob.end());#
  IntegerVector ord = seq(0,sv.size()-1);#
  sort(sv.begin(),sv.end(),ord.begin());#
  pv = pv[ord];#
  return List::create(_["stat"]=sv,_["prob"]=pv);#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,mass_target=0.999,prune=1e-15){#
  fb_dur_score_mass(n,alpha,mass_target,prune)#
}#
#
compute_score <- function(x){#
  d<-S1<-S2<-m<-0L#
  for(v in x){d<-d+1L;if(v==1L){m<-m+1L;S1<-S1+d;S2<-S2+d*d;d<-0L}}#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact <- function(stat,prob,obs) prob[stat>=obs-1e-15] |> sum()#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
res <- data.frame()#
#
for(n in n_list){#
  for(a in alpha_list){#
    t0 <- proc.time()[3]#
    dist <- fb_dur_score(n,a,0.999)        # total mass ≥ 99.9 %#
    gen <- proc.time()[3]-t0#
    mass <- sum(dist$prob)#
#
    stat <- dist$stat; prob <- dist$prob#
    absd <- difd <- numeric(Nrep)#
#
    for(i in 1:Nrep){#
      X   <- rbinom(n,1,a)#
      s   <- compute_score(X)#
      pE  <- p_exact(stat,prob,s)#
      pχ  <- 1-pchisq((s-1)*a*(n-1),df=1)#
      absd[i] <- abs(pE-pχ)#
      difd[i] <- (pE<0.05)!=(pχ<0.05)#
    }#
    sim <- proc.time()[3]-t0-gen#
#
    res <- rbind(res,data.frame(n,alpha=a,prob_sum=mass,#
                                gen_time=gen,sim_time=sim,#
                                total=gen+sim,#
                                mean_abs=mean(absd),#
                                diff_dec=mean(difd)))#
  }#
}#
#
print(res)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
cppFunction('#
#include <Rcpp.h>#
#include <vector>#
#include <algorithm>#
#include <cstdint>#
#include <cmath>#
using namespace Rcpp;#
#
struct St{int d,m,S1,S2;double p;};#
inline uint64_t key(int d,int m,int S1,int S2){#
  return (uint64_t)d | ((uint64_t)m<<10) | ((uint64_t)S1<<20) | ((uint64_t)S2<<36);#
}#
inline void keep(std::vector<St>&v,const St&s,double pr){ if(s.p>=pr) v.push_back(s); }#
#
// [[Rcpp::export]]#
List fb_dur_score_mass(int n,double a=0.05,double mass=0.999,double pr=1e-15){#
  double eps = (1.0-mass)/n;#
  std::vector<St> cur(1,{0,0,0,0,1.0}), nxt;#
  const double p0=1-a, p1=a;#
#
  for(int t=0;t<n;++t){#
    nxt.clear(); nxt.reserve(cur.size()*2);#
    for(const St& st:cur){#
      if(st.p<pr) continue;#
      St u=st; u.d+=1; u.p*=p0; keep(nxt,u,pr);#
      St v=st; int dur=v.d+1; v.d=0; v.m+=1; v.S1+=dur; v.S2+=dur*dur; v.p*=p1; keep(nxt,v,pr);#
    }#
    std::sort(nxt.begin(),nxt.end(),[](auto&a,auto&b){return a.p>b.p;});#
    double acc=0.0; size_t keepN=0;#
    while(keepN<nxt.size() && acc<1.0-eps){acc+=nxt[keepN].p;++keepN;}#
    nxt.resize(keepN);#
#
    std::sort(nxt.begin(),nxt.end(),#
              [](auto&a,auto&b){return key(a.d,a.m,a.S1,a.S2)<key(b.d,b.m,b.S1,b.S2);});#
    cur.clear();#
    for(size_t i=0;i<nxt.size();){#
      size_t j=i; double ps=0; uint64_t k=key(nxt[i].d,nxt[i].m,nxt[i].S1,nxt[i].S2);#
      while(j<nxt.size() && key(nxt[j].d,nxt[j].m,nxt[j].S1,nxt[j].S2)==k){ps+=nxt[j].p;++j;}#
      St w=nxt[i]; w.p=ps; cur.push_back(w); i=j;#
    }#
  }#
#
  std::vector<double> sv,pv;#
  sv.reserve(cur.size()); pv.reserve(cur.size());#
  for(const St& st:cur){#
    if(st.m==0||st.p<=0) continue;#
    sv.push_back((double)st.S2*st.m/((double)st.S1*st.S1));#
    pv.push_back(st.p);#
  }#
  return List::create(_["stat"]=NumericVector(sv.begin(),sv.end()),#
                      _["prob"]=NumericVector(pv.begin(),pv.end()));#
}#
')#
#
fb_dur_score <- function(n,alpha=0.05,mass=0.999,prune=1e-15){#
  fb_dur_score_mass(n,alpha,mass,prune)#
}#
#
compute_score <- function(x){#
  d<-S1<-S2<-m<-0L#
  for(v in x){d<-d+1L;if(v==1L){m<-m+1L;S1<-S1+d;S2<-S2+d*d;d<-0L}}#
  if(m==0L) return(0)#
  (S2*m)/(S1*S1)#
}#
#
p_exact <- function(stat,prob,obs) sum(prob[stat>=obs-1e-15])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n in n_list){#
  for(a in alpha_list){#
    t0 <- proc.time()[3]#
    dist <- fb_dur_score(n,a,0.999)#
    gen <- proc.time()[3]-t0#
    mass <- sum(dist$prob)#
#
    stat <- dist$stat; prob <- dist$prob#
    absd <- difd <- numeric(Nrep)#
#
    t1 <- proc.time()[3]#
    for(i in 1:Nrep){#
      X <- rbinom(n,1,a)#
      s <- compute_score(X)#
      pE <- p_exact(stat,prob,s)#
      pC <- 1-pchisq((s-1)*a*(n-1),df=1)#
      absd[i] <- abs(pE-pC)#
      difd[i] <- (pE<0.05)!=(pC<0.05)#
    }#
    sim <- proc.time()[3]-t1#
#
    results <- rbind(results,data.frame(#
      n=n,alpha=a,prob_sum=mass,#
      gen_time=gen,sim_time=sim,total=gen+sim,#
      mean_abs_pval_diff=mean(absd),#
      prop_diff_in_decision=mean(difd)))#
  }#
}#
#
print(results)
# LRcc: P-value Comparison via simulated data#
#
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
  if(n>1){#
    for(i in 2:n){#
      if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
      if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
      if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
      if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
    }#
  }#
  if(n>1){#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  } else {#
    LRind <- 0#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  cdf_val <- sum(probvals[LRvals <= LRobs])#
  1 - cdf_val#
}#
#
library(rugarch)#
spec <- ugarchspec(#
  variance.model = list(model = "sGARCH", garchOrder = c(1,1)),#
  mean.model     = list(armaOrder = c(0,0), include.mean = FALSE),#
  distribution.model = "std"#
)#
setfixed(spec) <- list(omega = 1e-6, alpha1 = 0.05, beta1 = 0.9, shape = 6, mu = 0)#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15) #
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    qt_alpha <- qt(alpha_, df = 6)#
    for(i in seq_len(Nrep)) {#
      sim <- ugarchpath(spec, n.sim = n_)#
      ret <- fitted(sim)#
      sigma_t <- sigma(sim)#
      VaR_t <- -sigma_t * qt_alpha#
      X <- as.integer(ret < VaR_t)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results#
p1 / p2
library(Rcpp)#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p){#
  if(x==0){phat <- 0}else if(x==n){phat <- 1}else{phat <- x/n}#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_)+(n-x)*safe_log(1-p_)#
  den <- x*safe_log(ph_)+(n-x)*safe_log(1-ph_)#
  -2*(num-den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n){#
  if(n<=1) return(0)#
  T0 <- T00+T10#
  T1 <- T01+T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+#
         T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){return x>0.0?std::log(x):0.0;}#
struct State{int la;int c1;int T00;int T10;int T01;int T11;double prob;};#
struct LLHash{std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2=NMAX+10;#
  long long SHIFT3=SHIFT2*(NMAX+10);#
  long long SHIFT4=SHIFT3*(NMAX+10);#
  long long SHIFT5=SHIFT4*(NMAX+10);#
  long long SHIFT6=SHIFT5*(NMAX+10);#
  return (long long)la+SHIFT2*(long long)c1+SHIFT3*(long long)T00+#
         SHIFT4*(long long)T10+SHIFT5*(long long)T01+SHIFT6*(long long)T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1){NumericVector LR(0),prob(0);return List::create(Named("LR")=LR,Named("prob")=prob);}#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {State s0{0,0,0,0,0,0,1.0-alpha};curMap[encode6(0,0,0,0,0,0,NMAX)]=s0;#
   State s1{1,1,0,0,0,0,alpha};curMap[encode6(1,1,0,0,0,0,NMAX)]=s1;}#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob;if(p<prune_threshold)continue;#
      int la=kv.second.la,c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      {State ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.prob=p*p0;#
       long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
       auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;}#
      {State ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.prob=p*p1;#
       long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
       auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;}#
    }#
    curMap.clear();#
    for(auto &km:newMap)if(km.second.prob>=prune_threshold)curMap[km.first]=km.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob;if(p<=0.0)continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,p_=std::max(std::min(alpha,1.0-eps),eps);#
    double phat=(c1==0)?0.0:((c1==n)?1.0:(double)c1/n);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2.0*(c1*std::log(p_)+(n-c1)*std::log(1.0-p_)-c1*std::log(ph_)-(n-c1)*std::log(1.0-ph_));#
    double lrind=0.0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1.0-ph)+T1*s_log(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=(s01>0)?(double)T01/s01:1.0,pi11=(s11>0)?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind=-2.0*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;vec.reserve(lrDist.size());#
  for(auto &kv:lrDist)vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15)curP+=vec[i].second;#
      else{LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second;}#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15)fb_lrcc_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRcc <- function(X,alpha){#
  n <- length(X);c1 <- sum(X);eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps);ph_ <- max(min(c1/n,1-eps),eps)#
  LRuc <- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00 <- 0;T01 <- 0;T10 <- 0;T11 <- 0#
  if(n>1)for(i in 2:n){if(X[i-1]==0&&X[i]==0)T00<-T00+1#
                       if(X[i-1]==0&&X[i]==1)T01<-T01+1#
                       if(X[i-1]==1&&X[i]==0)T10<-T10+1#
                       if(X[i-1]==1&&X[i]==1)T11<-T11+1}#
  if(n>1){#
    T0 <- T00+T10;T1 <- T01+T11;pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01 <- T00+T01;pi01 <- if(s01>0)T01/s01 else 1#
    s11 <- T10+T11;pi11 <- if(s11>0)T11/s11 else 1#
    den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind <- -2*(num-den)#
  }else LRind <- 0#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs){#
  cdf_val <- sum(probvals[LRvals<=LRobs]);1-cdf_val#
}#
#
library(rugarch)#
spec <- ugarchspec(#
  variance.model=list(model="sGARCH",garchOrder=c(1,1)),#
  mean.model=list(armaOrder=c(0,0),include.mean=FALSE),#
  distribution.model="std"#
)#
setfixed(spec) <- list(omega=1e-6,alpha1=0.05,beta1=0.9,shape=6)#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrcc(n_,alpha_,1e-15)#
    LRvals <- dist_full$LR;probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep);diff_decision <- numeric(Nrep)#
    qt_alpha <- qt(alpha_,df=6)#
    for(i in seq_len(Nrep)){#
      sim <- ugarchpath(spec,n.sim=n_)#
      ret <- fitted(sim);sigma_t <- sigma(sim)#
      VaR_t <- -sigma_t*qt_alpha#
      X <- as.integer(ret < VaR_t)#
      LRobs <- my_compute_LRcc(X,alpha_)#
      pval_exact <- get_pval_exact(LRvals,probvals,LRobs)#
      pval_chi2 <- 1-pchisq(LRobs,df=2)#
      abs_diff[i] <- abs(pval_exact-pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact<0.05)!=(pval_chi2<0.05))#
    }#
    results <- rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
results_plot <- subset(results,!is.na(mean_abs_pval_diff)&!is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot,aes(x=factor(n),y=mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p2 <- ggplot(results_plot,aes(x=factor(n),y=prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
results#
p1/p2
# LRcc: P-value Comparison via simulated data#
#
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  // initialization#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  // forward#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      // next state if we observe 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      // next state if we observe 1#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  // gather distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    // LRuc#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    // LRind#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
  if(n>1){#
    for(i in 2:n){#
      if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
      if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
      if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
      if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
    }#
  }#
  if(n>1){#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  } else {#
    LRind <- 0#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  # p-value = 1 - CDF(LRobs)#
  cdf_val <- sum(probvals[LRvals <= LRobs])#
  1 - cdf_val#
}#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15) #
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    # mean_abs_pval_diff: This is the average absolute difference between#
    # the exact p-value and the chi-square-based p-value across all simulations.#
#
    # prop_diff_in_decision: This is the proportion of simulated samples#
    # for which the exact method and the chi-square method give different#
    # reject/not-reject decisions at 5% significance.#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results#
p1 / p2
library(Rcpp)#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p){#
  if(x==0){phat <- 0}else if(x==n){phat <- 1}else{phat <- x/n}#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_)+(n-x)*safe_log(1-p_)#
  den <- x*safe_log(ph_)+(n-x)*safe_log(1-ph_)#
  -2*(num-den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n){#
  if(n<=1) return(0)#
  T0 <- T00+T10#
  T1 <- T01+T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+#
         T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){return x>0.0?std::log(x):0.0;}#
struct State{int la;int c1;int T00;int T10;int T01;int T11;double prob;};#
struct LLHash{std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2=NMAX+10;#
  long long SHIFT3=SHIFT2*(NMAX+10);#
  long long SHIFT4=SHIFT3*(NMAX+10);#
  long long SHIFT5=SHIFT4*(NMAX+10);#
  long long SHIFT6=SHIFT5*(NMAX+10);#
  return (long long)la+SHIFT2*(long long)c1+SHIFT3*(long long)T00+#
         SHIFT4*(long long)T10+SHIFT5*(long long)T01+SHIFT6*(long long)T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1){NumericVector LR(0),prob(0);return List::create(Named("LR")=LR,Named("prob")=prob);}#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {State s0{0,0,0,0,0,0,1.0-alpha};curMap[encode6(0,0,0,0,0,0,NMAX)]=s0;#
   State s1{1,1,0,0,0,0,alpha};curMap[encode6(1,1,0,0,0,0,NMAX)]=s1;}#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob;if(p<prune_threshold)continue;#
      int la=kv.second.la,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      {State ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.prob=p*p0;#
       long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
       auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;}#
      {State ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.prob=p*p1;#
       long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
       auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;}#
    }#
    curMap.clear();#
    for(auto &km:newMap)if(km.second.prob>=prune_threshold)curMap[km.first]=km.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob;if(p<=0.0)continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,p_=std::max(std::min(alpha,1.0-eps),eps);#
    double phat=(c1==0)?0.0:((c1==n)?1.0:(double)c1/n);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2.0*(c1*std::log(p_)+(n-c1)*std::log(1.0-p_)-c1*std::log(ph_)-(n-c1)*std::log(1.0-ph_));#
    double lrind=0.0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1.0-ph)+T1*s_log(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=(s01>0)?(double)T01/s01:1.0,pi11=(s11>0)?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind=-2.0*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;vec.reserve(lrDist.size());#
  for(auto &kv:lrDist)vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15)curP+=vec[i].second;#
      else{LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second;}#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15)fb_lrcc_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRcc <- function(X,alpha){#
  n <- length(X);c1 <- sum(X);eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps);ph_ <- max(min(c1/n,1-eps),eps)#
  LRuc <- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00 <- 0;T01 <- 0;T10 <- 0;T11 <- 0#
  if(n>1)for(i in 2:n){if(X[i-1]==0&&X[i]==0)T00<-T00+1#
                       if(X[i-1]==0&&X[i]==1)T01<-T01+1#
                       if(X[i-1]==1&&X[i]==0)T10<-T10+1#
                       if(X[i-1]==1&&X[i]==1)T11<-T11+1}#
  if(n>1){#
    T0 <- T00+T10;T1 <- T01+T11;pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01 <- T00+T01;pi01 <- if(s01>0)T01/s01 else 1#
    s11 <- T10+T11;pi11 <- if(s11>0)T11/s11 else 1#
    den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind <- -2*(num-den)#
  }else LRind <- 0#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs){#
  cdf_val <- sum(probvals[LRvals<=LRobs]);1-cdf_val#
}#
#
library(rugarch)#
spec <- ugarchspec(#
  variance.model=list(model="sGARCH",garchOrder=c(1,1)),#
  mean.model=list(armaOrder=c(0,0),include.mean=FALSE),#
  distribution.model="std"#
)#
setfixed(spec) <- list(omega=1e-6,alpha1=0.05,beta1=0.9,shape=6)#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrcc(n_,alpha_,1e-15)#
    LRvals <- dist_full$LR;probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep);diff_decision <- numeric(Nrep)#
    qn_alpha <- qnorm(alpha_)#
    for(i in seq_len(Nrep)){#
      sim <- ugarchpath(spec,n.sim=n_)#
      ret <- fitted(sim);sigma_t <- sigma(sim)#
      VaR_t <- -sigma_t * qn_alpha#
      X <- as.integer(ret < VaR_t)#
      LRobs <- my_compute_LRcc(X,alpha_)#
      pval_exact <- get_pval_exact(LRvals,probvals,LRobs)#
      pval_chi2 <- 1-pchisq(LRobs,df=2)#
      abs_diff[i] <- abs(pval_exact-pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact<0.05)!=(pval_chi2<0.05))#
    }#
    results <- rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
results_plot <- subset(results,!is.na(mean_abs_pval_diff)&!is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot,aes(x=factor(n),y=mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p2 <- ggplot(results_plot,aes(x=factor(n),y=prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
results#
p1/p2
library(Rcpp)#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){return x>0.0?std::log(x):0.0;}#
struct State{int la;int c1;int T00;int T10;int T01;int T11;double prob;};#
struct LLHash{std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2=NMAX+10,SHIFT3=SHIFT2*(NMAX+10),SHIFT4=SHIFT3*(NMAX+10),#
            SHIFT5=SHIFT4*(NMAX+10),SHIFT6=SHIFT5*(NMAX+10);#
  return (long long)la+SHIFT2*(long long)c1+SHIFT3*(long long)T00+#
         SHIFT4*(long long)T10+SHIFT5*(long long)T01+SHIFT6*(long long)T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1){NumericVector LR(0),prob(0);return List::create(Named("LR")=LR,Named("prob")=prob);}#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  curMap[encode6(0,0,0,0,0,0,NMAX)]={0,0,0,0,0,0,1.0-alpha};#
  curMap[encode6(1,1,0,0,0,0,NMAX)]={1,1,0,0,0,0,alpha};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob;if(p<prune_threshold)continue;#
      int la=kv.second.la;#
      double p0=1.0-alpha,p1=alpha;#
      {State ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.prob=p*p0;#
       long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
       auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;}#
      {State ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.prob=p*p1;#
       long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
       auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;}#
    }#
    curMap.clear();#
    for(auto &km:newMap)if(km.second.prob>=prune_threshold)curMap[km.first]=km.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob;if(p<=0.0)continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,p_=std::max(std::min(alpha,1.0-eps),eps);#
    double phat=(c1==0)?0.0:((c1==n)?1.0:(double)c1/n);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2.0*(c1*std::log(p_)+(n-c1)*std::log(1.0-p_)-c1*std::log(ph_)-(n-c1)*std::log(1.0-ph_));#
    double lrind=0.0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1.0-ph)+T1*s_log(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=(s01>0)?(double)T01/s01:1.0,pi11=(s11>0)?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind=-2.0*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;vec.reserve(lrDist.size());#
  for(auto &kv:lrDist)vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15)curP+=vec[i].second;#
      else{LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second;}#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15)fb_lrcc_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRcc <- function(X,alpha){#
  n <- length(X);c1 <- sum(X);eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps);ph_ <- max(min(c1/n,1-eps),eps)#
  LRuc <- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00 <- 0;T01 <- 0;T10 <- 0;T11 <- 0#
  if(n>1)for(i in 2:n){if(X[i-1]==0&&X[i]==0)T00<-T00+1#
                       if(X[i-1]==0&&X[i]==1)T01<-T01+1#
                       if(X[i-1]==1&&X[i]==0)T10<-T10+1#
                       if(X[i-1]==1&&X[i]==1)T11<-T11+1}#
  if(n>1){#
    T0 <- T00+T10;T1 <- T01+T11;pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01 <- T00+T01;pi01 <- if(s01>0)T01/s01 else 1#
    s11 <- T10+T11;pi11 <- if(s11>0)T11/s11 else 1#
    den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind <- -2*(num-den)#
  }else LRind <- 0#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs){#
  cdf_val <- sum(probvals[LRvals<=LRobs]);1-cdf_val#
}#
#
library(rugarch)#
spec <- ugarchspec(#
  variance.model=list(model="sGARCH",garchOrder=c(1,1)),#
  mean.model=list(armaOrder=c(0,0),include.mean=FALSE),#
  distribution.model="std"#
)#
setfixed(spec) <- list(omega=1e-6,alpha1=0.05,beta1=0.9,shape=6)#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrcc(n_,alpha_,1e-15)#
    LRvals <- dist_full$LR;probvals <- dist_full$prob#
    reject_exact <- numeric(Nrep);reject_chi2 <- numeric(Nrep);diff_decision <- numeric(Nrep)#
    qn_alpha <- qnorm(alpha_)#
    for(i in seq_len(Nrep)){#
      sim <- ugarchpath(spec,n.sim=n_)#
      ret <- fitted(sim);sigma_t <- sigma(sim)#
      sig_hat <- c(sigma_t[1], head(sigma_t, -1))#
      VaR_t <- -sig_hat * qn_alpha#
      X <- as.integer(ret < VaR_t)#
      LRobs <- my_compute_LRcc(X,alpha_)#
      pval_exact <- get_pval_exact(LRvals,probvals,LRobs)#
      pval_chi2 <- 1-pchisq(LRobs,df=2)#
      reject_exact[i] <- pval_exact < 0.05#
      reject_chi2[i]  <- pval_chi2  < 0.05#
      diff_decision[i] <- as.numeric(reject_exact[i]!=reject_chi2[i])#
    }#
    results <- rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      power_exact=mean(reject_exact),#
      power_chi2=mean(reject_chi2),#
      diff_decision=mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
results_plot <- subset(results,!is.na(power_exact))#
p1 <- ggplot(results_plot,aes(x=factor(n),y=power_exact,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_exact",fill="alpha")+theme_minimal()#
p2 <- ggplot(results_plot,aes(x=factor(n),y=power_chi2,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_chi2",fill="alpha")+theme_minimal()#
p3 <- ggplot(results_plot,aes(x=factor(n),y=diff_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="diff_decision",fill="alpha")+theme_minimal()#
results#
p1/p2/p3
library(Rcpp)#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){return x>0.0?std::log(x):0.0;}#
struct State{int la;int c1;int T00;int T10;int T01;int T11;double prob;};#
struct LLHash{std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long S2=NMAX+10,S3=S2*(NMAX+10),S4=S3*(NMAX+10),S5=S4*(NMAX+10),S6=S5*(NMAX+10);#
  return (long long)la+S2*(long long)c1+S3*(long long)T00+S4*(long long)T10+S5*(long long)T01+S6*(long long)T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1){NumericVector LR(0),prob(0);return List::create(Named("LR")=LR,Named("prob")=prob);}#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  curMap[encode6(0,0,0,0,0,0,NMAX)]={0,0,0,0,0,0,1.0-alpha};#
  curMap[encode6(1,1,0,0,0,0,NMAX)]={1,1,0,0,0,0,alpha};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob;if(p<prune_threshold)continue;#
      int la=kv.second.la;#
      double p0=1.0-alpha,p1=alpha;#
      {State ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.prob=p*p0;#
       long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
       auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;}#
      {State ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.prob=p*p1;#
       long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
       auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;}#
    }#
    curMap.clear();#
    for(auto &km:newMap)if(km.second.prob>=prune_threshold)curMap[km.first]=km.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob;if(p<=0.0)continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,p_=std::max(std::min(alpha,1.0-eps),eps);#
    double phat=(c1==0)?0:(c1==n?1:(double)c1/n);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2*(c1*std::log(p_)+(n-c1)*std::log(1-p_)-c1*std::log(ph_)-(n-c1)*std::log(1-ph_));#
    double lrind=0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=(s01>0)?(double)T01/s01:1,pi11=(s11>0)?(double)T11/s11:1;#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)+T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;vec.reserve(lrDist.size());#
  for(auto &kv:lrDist)vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15)curP+=vec[i].second;#
      else{LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second;}#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15)fb_lrcc_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRcc <- function(X,alpha){#
  n <- length(X);c1 <- sum(X);eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps);ph_ <- max(min(c1/n,1-eps),eps)#
  LRuc <- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00 <- 0;T01 <- 0;T10 <- 0;T11 <- 0#
  if(n>1)for(i in 2:n){if(X[i-1]==0&&X[i]==0)T00<-T00+1#
                       if(X[i-1]==0&&X[i]==1)T01<-T01+1#
                       if(X[i-1]==1&&X[i]==0)T10<-T10+1#
                       if(X[i-1]==1&&X[i]==1)T11<-T11+1}#
  if(n>1){#
    T0 <- T00+T10;T1 <- T01+T11;pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01 <- T00+T01;pi01 <- if(s01>0)T01/s01 else 1#
    s11 <- T10+T11;pi11 <- if(s11>0)T11/s11 else 1#
    den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind <- -2*(num-den)#
  }else LRind <- 0#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs){#
  cdf_val <- sum(probvals[LRvals<=LRobs]);1-cdf_val#
}#
#
library(rugarch)#
spec <- ugarchspec(#
  variance.model=list(model="sGARCH",garchOrder=c(1,1)),#
  mean.model=list(armaOrder=c(0,0),include.mean=FALSE),#
  distribution.model="std"#
)#
setfixed(spec) <- list(omega=1e-6,alpha1=0.05,beta1=0.9,shape=8)#
#
set.seed(123)#
n_list <- c(20,30,40,50,100,150,200)#
alpha_list <- c(0.005,0.01,0.025,0.05)#
Nrep <- 2000#
lambda <- 0.94#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrcc(n_,alpha_,1e-15)#
    LRvals <- dist_full$LR;probvals <- dist_full$prob#
    reject_exact <- numeric(Nrep);reject_chi2 <- numeric(Nrep);diff_decision <- numeric(Nrep)#
    qn_alpha <- qnorm(alpha_)#
    for(i in seq_len(Nrep)){#
      sim <- ugarchpath(spec,n.sim=n_)#
      ret <- fitted(sim);sigma_t <- sigma(sim)#
      sig_hat <- numeric(n_)#
      sig_hat[1] <- sigma_t[1]#
      for(t in 2:n_) sig_hat[t] <- sqrt(lambda*sig_hat[t-1]^2 + (1-lambda)*ret[t-1]^2)#
      VaR_t <- -sig_hat * qn_alpha#
      X <- as.integer(ret < VaR_t)#
      LRobs <- my_compute_LRcc(X,alpha_)#
      pval_exact <- get_pval_exact(LRvals,probvals,LRobs)#
      pval_chi2 <- 1-pchisq(LRobs,df=2)#
      reject_exact[i] <- pval_exact < 0.05#
      reject_chi2[i]  <- pval_chi2  < 0.05#
      diff_decision[i] <- as.numeric(reject_exact[i]!=reject_chi2[i])#
    }#
    results <- rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      power_exact=mean(reject_exact),#
      power_chi2=mean(reject_chi2),#
      diff_decision=mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
results_plot <- subset(results,!is.na(power_exact))#
p1 <- ggplot(results_plot,aes(x=factor(n),y=power_exact,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_exact",fill="alpha")+theme_minimal()#
p2 <- ggplot(results_plot,aes(x=factor(n),y=power_chi2,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_chi2",fill="alpha")+theme_minimal()#
p3 <- ggplot(results_plot,aes(x=factor(n),y=diff_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="diff_decision",fill="alpha")+theme_minimal()#
results#
p1/p2/p3
library(Rcpp)#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){return x>0.0?std::log(x):0.0;}#
struct State{int la;int c1;int T00;int T10;int T01;int T11;double prob;};#
struct LLHash{std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long S2=NMAX+10,S3=S2*(NMAX+10),S4=S3*(NMAX+10),S5=S4*(NMAX+10),S6=S5*(NMAX+10);#
  return (long long)la+S2*(long long)c1+S3*(long long)T00+S4*(long long)T10+S5*(long long)T01+S6*(long long)T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1){NumericVector LR(0),prob(0);return List::create(Named("LR")=LR,Named("prob")=prob);}#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  curMap[encode6(0,0,0,0,0,0,NMAX)]={0,0,0,0,0,0,1.0-alpha};#
  curMap[encode6(1,1,0,0,0,0,NMAX)]={1,1,0,0,0,0,alpha};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob;if(p<prune_threshold)continue;#
      int la=kv.second.la;#
      double p0=1.0-alpha,p1=alpha;#
      {State ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.prob=p*p0;#
       long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
       auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;}#
      {State ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.prob=p*p1;#
       long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
       auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;}#
    }#
    curMap.clear();#
    for(auto &km:newMap)if(km.second.prob>=prune_threshold)curMap[km.first]=km.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob;if(p<=0.0)continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,p_=std::max(std::min(alpha,1.0-eps),eps);#
    double phat=(c1==0)?0:(c1==n?1:(double)c1/n);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2*(c1*std::log(p_)+(n-c1)*std::log(1-p_)-c1*std::log(ph_)-(n-c1)*std::log(1-ph_));#
    double lrind=0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=(s01>0)?(double)T01/s01:1,pi11=(s11>0)?(double)T11/s11:1;#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)+T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;vec.reserve(lrDist.size());#
  for(auto &kv:lrDist)vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15)curP+=vec[i].second;#
      else{LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second;}#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,prune_threshold=1e-15)fb_lrcc_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRcc <- function(X,alpha){#
  n <- length(X);c1 <- sum(X);eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps);ph_ <- max(min(c1/n,1-eps),eps)#
  LRuc <- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00 <- 0;T01 <- 0;T10 <- 0;T11 <- 0#
  if(n>1)for(i in 2:n){if(X[i-1]==0&&X[i]==0)T00<-T00+1#
                       if(X[i-1]==0&&X[i]==1)T01<-T01+1#
                       if(X[i-1]==1&&X[i]==0)T10<-T10+1#
                       if(X[i-1]==1&&X[i]==1)T11<-T11+1}#
  if(n>1){#
    T0 <- T00+T10;T1 <- T01+T11;pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01 <- T00+T01;pi01 <- if(s01>0)T01/s01 else 1#
    s11 <- T10+T11;pi11 <- if(s11>0)T11/s11 else 1#
    den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind <- -2*(num-den)#
  }else LRind <- 0#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs){#
  cdf_val <- sum(probvals[LRvals<=LRobs]);1-cdf_val#
}#
#
library(rugarch)#
spec <- ugarchspec(#
  variance.model=list(model="sGARCH",garchOrder=c(1,1)),#
  mean.model=list(armaOrder=c(0,0),include.mean=FALSE),#
  distribution.model="std"#
)#
setfixed(spec) <- list(omega=1e-6,alpha1=0.05,beta1=0.9,shape=20)#
#
set.seed(123)#
n_list <- c(20,30,40,50,100,150,200)#
alpha_list <- c(0.005,0.01,0.025,0.05)#
Nrep <- 2000#
lambda <- 0.94#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrcc(n_,alpha_,1e-15)#
    LRvals <- dist_full$LR;probvals <- dist_full$prob#
    reject_exact <- numeric(Nrep);reject_chi2 <- numeric(Nrep);diff_decision <- numeric(Nrep)#
    qn_alpha <- qnorm(alpha_)#
    for(i in seq_len(Nrep)){#
      sim <- ugarchpath(spec,n.sim=n_)#
      ret <- fitted(sim);sigma_t <- sigma(sim)#
      sig_hat <- numeric(n_)#
      sig_hat[1] <- sigma_t[1]#
      for(t in 2:n_) sig_hat[t] <- sqrt(lambda*sig_hat[t-1]^2 + (1-lambda)*ret[t-1]^2)#
      VaR_t <- -sig_hat * 1.1 * qnorm(alpha_)#
      X <- as.integer(ret < VaR_t)#
      LRobs <- my_compute_LRcc(X,alpha_)#
      pval_exact <- get_pval_exact(LRvals,probvals,LRobs)#
      pval_chi2 <- 1-pchisq(LRobs,df=2)#
      reject_exact[i] <- pval_exact < 0.05#
      reject_chi2[i]  <- pval_chi2  < 0.05#
      diff_decision[i] <- as.numeric(reject_exact[i]!=reject_chi2[i])#
    }#
    results <- rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      power_exact=mean(reject_exact),#
      power_chi2=mean(reject_chi2),#
      diff_decision=mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
results_plot <- subset(results,!is.na(power_exact))#
p1 <- ggplot(results_plot,aes(x=factor(n),y=power_exact,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_exact",fill="alpha")+theme_minimal()#
p2 <- ggplot(results_plot,aes(x=factor(n),y=power_chi2,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_chi2",fill="alpha")+theme_minimal()#
p3 <- ggplot(results_plot,aes(x=factor(n),y=diff_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="diff_decision",fill="alpha")+theme_minimal()#
results#
p1/p2/p3
library(Rcpp)#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double sl(double x){return x>0.0?std::log(x):0.0;}#
struct S{int la,c1,T00,T10,T01,T11;double pr;};#
struct H{std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long enc(int la,int c1,int T00,int T10,int T01,int T11,int N){#
  long long b=N+10,c=b*(N+10),d=c*(N+10),e=d*(N+10),f=e*(N+10);#
  return (long long)la+b*c1+c*T00+d*T10+e*T01+f*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double a=0.05,double th=1e-15){#
  if(n<1){NumericVector LR(0),pr(0);return List::create(Named("LR")=LR,Named("prob")=pr);}#
  int N=n+5;#
  std::unordered_map<long long,S,H> cur;#
  cur[enc(0,0,0,0,0,0,N)]={0,0,0,0,0,0,1.0-a};#
  cur[enc(1,1,0,0,0,0,N)]={1,1,0,0,0,0,a};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,S,H> nxt;nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.pr;if(p<th)continue;#
      int la=kv.second.la;#
      double p0=1.0-a,p1=a;#
      {S ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.pr=p*p0;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
      {S ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.pr=p*p1;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
    }#
    cur.clear();#
    for(auto &kv:nxt)if(kv.second.pr>=th)cur[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.pr;if(p<=0)continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,pp=std::max(std::min(a,1.0-eps),eps);#
    double phat=c1==0?0:(c1==n?1:(double)c1/n);#
    double ph=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2*(c1*std::log(pp)+(n-c1)*std::log(1-pp)-c1*std::log(ph)-(n-c1)*std::log(1-ph));#
    double lrind=0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*sl(1-ph)+T1*sl(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1,pi11=s11>0?(double)T11/s11:1;#
      double den=T00*sl(1-pi01)+T01*sl(pi01)+T10*sl(1-pi11)+T11*sl(pi11);#
      lrind=-2*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> v;v.reserve(dist.size());#
  for(auto &kv:dist)v.emplace_back(kv.first,kv.second);#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,PR;#
  if(!v.empty()){#
    double cl=v[0].first,cp=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(std::fabs(v[i].first-cl)<1e-15)cp+=v[i].second;#
      else{LR.push_back(cl);PR.push_back(cp);cl=v[i].first;cp=v[i].second;}#
    }#
    LR.push_back(cl);PR.push_back(cp);#
  }#
  return List::create(Named("LR")=LR,Named("prob")=PR);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,pr=1e-15)fb_lrcc_fastcpp(n,alpha,pr)#
#
my_LRcc <- function(X,alpha){#
  n<-length(X);c1<-sum(X);eps<-1e-15#
  p_<-max(min(alpha,1-eps),eps);ph_<-max(min(c1/n,1-eps),eps)#
  LRuc<- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00<-T01<-T10<-T11<-0#
  if(n>1)for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0)T00<-T00+1#
    if(X[i-1]==0&&X[i]==1)T01<-T01+1#
    if(X[i-1]==1&&X[i]==0)T10<-T10+1#
    if(X[i-1]==1&&X[i]==1)T11<-T11+1#
  }#
  if(n>1){#
    T0<-T00+T10;T1<-T01+T11;pH<-T1/(n-1)#
    num<-T0*safe_log(1-pH)+T1*safe_log(pH)#
    s01<-T00+T01;pi01<-if(s01>0)T01/s01 else 1#
    s11<-T10+T11;pi11<-if(s11>0)T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }else LRind<-0#
  LRuc+LRind#
}#
#
p_exact <- function(LR,prob,obs){1-sum(prob[LR<=obs])}#
#
gen_markov <- function(n,alpha,kappa=1.3,phi=0.6){#
  p_bar<-kappa*alpha#
  p01<-p_bar*(1-phi)/(1-p_bar)#
  p11<-phi#
  x<-numeric(n)#
  x[1]<-rbinom(1,1,p_bar)#
  for(i in 2:n){#
    if(x[i-1]==0)x[i]<-rbinom(1,1,p01)#
    else x[i]<-rbinom(1,1,p11)#
  }#
  x#
}#
#
set.seed(123)#
n_list<-c(20,30,40,50,100,150,200)#
alpha_list<-c(0.005,0.01,0.025,0.05)#
Nrep<-2000#
results<-data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrcc(n_,alpha_,1e-15)#
    LRv<-dist$LR;Pv<-dist$prob#
    re<-rc<-dd<-numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X<-gen_markov(n_,alpha_)#
      LRobs<-my_LRcc(X,alpha_)#
      pe<-p_exact(LRv,Pv,LRobs)#
      pc<-1-pchisq(LRobs,df=2)#
      re[i]<-pe<0.05#
      rc[i]<-pc<0.05#
      dd[i]<-as.numeric(re[i]!=rc[i])#
    }#
    results<-rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      power_exact=mean(re),#
      power_chi2=mean(rc),#
      diff_decision=mean(dd)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
p1<-ggplot(results,aes(factor(n),power_exact,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_exact",fill="alpha")+theme_minimal()#
p2<-ggplot(results,aes(factor(n),power_chi2,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_chi2",fill="alpha")+theme_minimal()#
p3<-ggplot(results,aes(factor(n),diff_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="diff_decision",fill="alpha")+theme_minimal()#
results#
p1/p2/p3
library(Rcpp)#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double sl(double x){return x>0.0?std::log(x):0.0;}#
struct S{int la,c1,T00,T10,T01,T11;double pr;};#
struct H{std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long enc(int la,int c1,int T00,int T10,int T01,int T11,int N){#
  long long b=N+10,c=b*(N+10),d=c*(N+10),e=d*(N+10),f=e*(N+10);#
  return (long long)la+b*c1+c*T00+d*T10+e*T01+f*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double a=0.05,double th=1e-15){#
  if(n<1){NumericVector LR(0),pr(0);return List::create(Named("LR")=LR,Named("prob")=pr);}#
  int N=n+5;#
  std::unordered_map<long long,S,H> cur;#
  cur[enc(0,0,0,0,0,0,N)]={0,0,0,0,0,0,1.0-a};#
  cur[enc(1,1,0,0,0,0,N)]={1,1,0,0,0,0,a};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,S,H> nxt;nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.pr;if(p<th)continue;#
      int la=kv.second.la;#
      double p0=1.0-a,p1=a;#
      {S ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.pr=p*p0;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
      {S ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.pr=p*p1;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
    }#
    cur.clear();#
    for(auto &kv:nxt)if(kv.second.pr>=th)cur[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.pr;if(p<=0)continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,pp=std::max(std::min(a,1.0-eps),eps);#
    double phat=c1==0?0:(c1==n?1:(double)c1/n);#
    double ph=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2*(c1*std::log(pp)+(n-c1)*std::log(1-pp)-c1*std::log(ph)-(n-c1)*std::log(1-ph));#
    double lrind=0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*sl(1-ph)+T1*sl(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1,pi11=s11>0?(double)T11/s11:1;#
      double den=T00*sl(1-pi01)+T01*sl(pi01)+T10*sl(1-pi11)+T11*sl(pi11);#
      lrind=-2*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> v;v.reserve(dist.size());#
  for(auto &kv:dist)v.emplace_back(kv.first,kv.second);#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,PR;#
  if(!v.empty()){#
    double cl=v[0].first,cp=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(std::fabs(v[i].first-cl)<1e-15)cp+=v[i].second;#
      else{LR.push_back(cl);PR.push_back(cp);cl=v[i].first;cp=v[i].second;}#
    }#
    LR.push_back(cl);PR.push_back(cp);#
  }#
  return List::create(Named("LR")=LR,Named("prob")=PR);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,pr=1e-15)fb_lrcc_fastcpp(n,alpha,pr)#
#
my_LRcc <- function(X,alpha){#
  n<-length(X);c1<-sum(X);eps<-1e-15#
  p_<-max(min(alpha,1-eps),eps);ph_<-max(min(c1/n,1-eps),eps)#
  LRuc<- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00<-T01<-T10<-T11<-0#
  if(n>1)for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0)T00<-T00+1#
    if(X[i-1]==0&&X[i]==1)T01<-T01+1#
    if(X[i-1]==1&&X[i]==0)T10<-T10+1#
    if(X[i-1]==1&&X[i]==1)T11<-T11+1#
  }#
  if(n>1){#
    T0<-T00+T10;T1<-T01+T11;pH<-T1/(n-1)#
    num<-T0*safe_log(1-pH)+T1*safe_log(pH)#
    s01<-T00+T01;pi01<-if(s01>0)T01/s01 else 1#
    s11<-T10+T11;pi11<-if(s11>0)T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }else LRind<-0#
  LRuc+LRind#
}#
#
p_exact <- function(LR,prob,obs){1-sum(prob[LR<=obs])}#
#
gen_markov <- function(n,alpha,kappa=1.3,phi=0.6){#
  p_bar<-kappa*alpha#
  p01<-p_bar*(1-phi)/(1-p_bar)#
  p11<-phi#
  x<-numeric(n)#
  x[1]<-rbinom(1,1,p_bar)#
  for(i in 2:n){#
    if(x[i-1]==0)x[i]<-rbinom(1,1,p01)#
    else x[i]<-rbinom(1,1,p11)#
  }#
  x#
}#
#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results<-data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrcc(n_,alpha_,1e-15)#
    LRv<-dist$LR;Pv<-dist$prob#
    re<-rc<-dd<-numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X<-gen_markov(n_,alpha_)#
      LRobs<-my_LRcc(X,alpha_)#
      pe<-p_exact(LRv,Pv,LRobs)#
      pc<-1-pchisq(LRobs,df=2)#
      re[i]<-pe<0.05#
      rc[i]<-pc<0.05#
      dd[i]<-as.numeric(re[i]!=rc[i])#
    }#
    results<-rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      power_exact=mean(re),#
      power_chi2=mean(rc),#
      diff_decision=mean(dd)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
p1<-ggplot(results,aes(factor(n),power_exact,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_exact",fill="alpha")+theme_minimal()#
p2<-ggplot(results,aes(factor(n),power_chi2,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_chi2",fill="alpha")+theme_minimal()#
p3<-ggplot(results,aes(factor(n),diff_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="diff_decision",fill="alpha")+theme_minimal()#
results#
p1/p2/p3
# LRcc: P-value Comparison via simulated data#
#
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <cmath>#
using namespace Rcpp;#
static inline double sl(double x){return x>0?log(x):0;}#
struct S{int la,c1,T00,T10,T01,T11;double pr;};#
struct H{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
#
static inline long long enc(int la,int c1,int T00,int T10,int T01,int T11,int N){#
  long long b=N+10,c=b*(N+10),d=c*(N+10),e=d*(N+10),f=e*(N+10);#
  return la+b*c1+c*T00+d*T10+e*T01+f*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double a=0.05,double th=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int N=n+5;#
  std::unordered_map<long long,S,H> cur;#
  cur[enc(0,0,0,0,0,0,N)]={0,0,0,0,0,0,1.0-a};#
  cur[enc(1,1,0,0,0,0,N)]={1,1,0,0,0,0,a};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,S,H> nxt;nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.pr;if(p<th)continue;#
      int la=kv.second.la;#
      double p0=1.0-a,p1=a;#
      {S ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.pr=p*p0;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
      {S ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.pr=p*p1;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
    }#
    cur.clear();#
    for(auto &kv:nxt)if(kv.second.pr>=th)cur[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.pr;if(p<=0)continue;#
    int n1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,p_=std::max(std::min(a,1.0-eps),eps);#
    double phat=n1==0?0:(n1==n?1:(double)n1/n);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2*(n1*log(p_)+(n-n1)*log(1-p_)-n1*log(ph_)-(n-n1)*log(1-ph_));#
    double lrind=0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*sl(1-ph)+T1*sl(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1,pi11=s11>0?(double)T11/s11:1;#
      double den=T00*sl(1-pi01)+T01*sl(pi01)+T10*sl(1-pi11)+T11*sl(pi11);#
      lrind=-2*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  NumericVector LR,PR;#
  if(!dist.empty()){#
    std::vector<std::pair<double,double>> v(dist.begin(),dist.end());#
    std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
    double cl=v[0].first,cp=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(fabs(v[i].first-cl)<1e-15)cp+=v[i].second;#
      else{LR.push_back(cl);PR.push_back(cp);cl=v[i].first;cp=v[i].second;}#
    }#
    LR.push_back(cl);PR.push_back(cp);#
  }#
  return List::create(Named("LR")=LR,Named("prob")=PR);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,pr=1e-15) fb_lrcc_fastcpp(n,alpha,pr)#
#
my_LRcc <- function(X,alpha){#
  n<-length(X);c1<-sum(X);eps<-1e-15#
  p_<-max(min(alpha,1-eps),eps);ph_<-max(min(c1/n,1-eps),eps)#
  LRuc<- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00<-T01<-T10<-T11<-0#
  if(n>1)for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0)T00<-T00+1#
    if(X[i-1]==0&&X[i]==1)T01<-T01+1#
    if(X[i-1]==1&&X[i]==0)T10<-T10+1#
    if(X[i-1]==1&&X[i]==1)T11<-T11+1}#
  if(n>1){#
    T0<-T00+T10;T1<-T01+T11;pH<-T1/(n-1)#
    num<-T0*safe_log(1-pH)+T1*safe_log(pH)#
    s01<-T00+T01;pi01<-if(s01>0)T01/s01 else 1#
    s11<-T10+T11;pi11<-if(s11>0)T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }else LRind<-0#
  LRuc+LRind#
}#
#
p_exact <- function(LR,prob,obs) 1-sum(prob[LR<=obs])#
#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results<-data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrcc(n_,alpha_,1e-15)#
    LRv<-dist$LR;Pv<-dist$prob#
    abs_diff<-diff_dec<-rej_e<-rej_c<-numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X<-rbinom(n_,1,alpha_)#
      LRobs<-my_LRcc(X,alpha_)#
      pe<-p_exact(LRv,Pv,LRobs)#
      pc<-1-pchisq(LRobs,df=2)#
      abs_diff[i]<-abs(pe-pc)#
      diff_dec[i]<-as.numeric((pe<0.05)!=(pc<0.05))#
      rej_e[i]<-pe<0.05#
      rej_c[i]<-pc<0.05#
    }#
    results<-rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec),#
      size_exact=mean(rej_e),#
      size_chi2=mean(rej_c),#
      delta_size=mean(rej_e)-mean(rej_c)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
#
r1<-subset(results)#
p1<-ggplot(r1,aes(factor(n),size_exact,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+geom_hline(yintercept=0.05,lty=2)+#
  labs(x="n",y="size_exact",fill="alpha")+theme_minimal()#
p2<-ggplot(r1,aes(factor(n),size_chi2,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+geom_hline(yintercept=0.05,lty=2)+#
  labs(x="n",y="size_chi2",fill="alpha")+theme_minimal()#
p3<-ggplot(r1,aes(factor(n),delta_size,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+#
  labs(x="n",y="delta_size",fill="alpha")+theme_minimal()#
p4<-ggplot(r1,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p5<-ggplot(r1,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
#
results#
(p1|p2)/(p3|p4|p5)
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <cmath>#
using namespace Rcpp;#
static inline double sl(double x){return x>0?log(x):0;}#
struct S{int la,c1,T00,T10,T01,T11;double pr;};#
struct H{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
#
static inline long long enc(int la,int c1,int T00,int T10,int T01,int T11,int N){#
  long long b=N+10,c=b*(N+10),d=c*(N+10),e=d*(N+10),f=e*(N+10);#
  return la+b*c1+c*T00+d*T10+e*T01+f*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double a=0.05,double th=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int N=n+5;#
  std::unordered_map<long long,S,H> cur;#
  cur[enc(0,0,0,0,0,0,N)]={0,0,0,0,0,0,1.0-a};#
  cur[enc(1,1,0,0,0,0,N)]={1,1,0,0,0,0,a};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,S,H> nxt;nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.pr;if(p<th)continue;#
      int la=kv.second.la;#
      double p0=1.0-a,p1=a;#
      {S ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.pr=p*p0;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
      {S ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.pr=p*p1;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
    }#
    cur.clear();#
    for(auto &kv:nxt)if(kv.second.pr>=th)cur[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.pr;if(p<=0)continue;#
    int n1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,p_=std::max(std::min(a,1.0-eps),eps);#
    double phat=n1==0?0:(n1==n?1:(double)n1/n);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2*(n1*log(p_)+(n-n1)*log(1-p_)-n1*log(ph_)-(n-n1)*log(1-ph_));#
    double lrind=0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*sl(1-ph)+T1*sl(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1,pi11=s11>0?(double)T11/s11:1;#
      double den=T00*sl(1-pi01)+T01*sl(pi01)+T10*sl(1-pi11)+T11*sl(pi11);#
      lrind=-2*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  NumericVector LR,PR;#
  if(!dist.empty()){#
    std::vector<std::pair<double,double>> v(dist.begin(),dist.end());#
    std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
    double cl=v[0].first,cp=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(fabs(v[i].first-cl)<1e-15)cp+=v[i].second;#
      else{LR.push_back(cl);PR.push_back(cp);cl=v[i].first;cp=v[i].second;}#
    }#
    LR.push_back(cl);PR.push_back(cp);#
  }#
  return List::create(Named("LR")=LR,Named("prob")=PR);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,pr=1e-15) fb_lrcc_fastcpp(n,alpha,pr)#
#
my_LRcc <- function(X,alpha){#
  n<-length(X);c1<-sum(X);eps<-1e-15#
  p_<-max(min(alpha,1-eps),eps);ph_<-max(min(c1/n,1-eps),eps)#
  LRuc<- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00<-T01<-T10<-T11<-0#
  if(n>1)for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0)T00<-T00+1#
    if(X[i-1]==0&&X[i]==1)T01<-T01+1#
    if(X[i-1]==1&&X[i]==0)T10<-T10+1#
    if(X[i-1]==1&&X[i]==1)T11<-T11+1}#
  if(n>1){#
    T0<-T00+T10;T1<-T01+T11;pH<-T1/(n-1)#
    num<-T0*safe_log(1-pH)+T1*safe_log(pH)#
    s01<-T00+T01;pi01<-if(s01>0)T01/s01 else 1#
    s11<-T10+T11;pi11<-if(s11>0)T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }else LRind<-0#
  LRuc+LRind#
}#
#
p_exact <- function(LR,prob,obs) 1-sum(prob[LR<=obs])#
#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results<-data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrcc(n_,alpha_,1e-15)#
    LRv<-dist$LR;Pv<-dist$prob#
    abs_diff<-diff_dec<-rej_e<-rej_c<-numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X<-rbinom(n_,1,alpha_)#
      LRobs<-my_LRcc(X,alpha_)#
      pe<-p_exact(LRv,Pv,LRobs)#
      pc<-1-pchisq(LRobs,df=2)#
      abs_diff[i]<-abs(pe-pc)#
      diff_dec[i]<-as.numeric((pe<0.05)!=(pc<0.05))#
      rej_e[i]<-pe<0.05#
      rej_c[i]<-pc<0.05#
    }#
    results<-rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec),#
      size_exact=mean(rej_e),#
      size_chi2=mean(rej_c),#
      delta_size=mean(rej_e)-mean(rej_c)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
#
p1<-ggplot(results,aes(factor(n),size_exact,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+geom_hline(yintercept=0.05,lty=2)+#
  labs(x="n",y="size_exact",fill="alpha")+theme_minimal()#
p2<-ggplot(results,aes(factor(n),size_chi2,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+geom_hline(yintercept=0.05,lty=2)+#
  labs(x="n",y="size_chi2",fill="alpha")+theme_minimal()#
p3<-ggplot(results,aes(factor(n),delta_size,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+#
  labs(x="n",y="delta_size",fill="alpha")+theme_minimal()#
p4<-ggplot(results,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+#
  labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p5<-ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+#
  labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
#
results#
(p1|p2)/(p3|p4|p5)
library(Rcpp)#
library(ggplot2)#
library(patchwork)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0)      phat <- 0#
  else if(x==n) phat <- 1#
  else          phat <- x/n#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
static inline double s_log(double x){return x>0.0?std::log(x):0.0;}#
struct State {int la,c1,T00,T10,T01,T11;double prob;};#
struct LLHash {std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1) {#
    NumericVector LR(0), prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0={0,0,0,0,0,0,1.0-alpha};#
    curMap[encode6(0,0,0,0,0,0,NMAX)] = s0;#
    State s1={1,1,0,0,0,0,alpha};#
    curMap[encode6(1,1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob;if(p<prune_threshold)continue;#
      int la=kv.second.la,c1=kv.second.c1;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      {#
        State ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.prob=p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.prob=p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);if(it==newMap.end())newMap[c]=ns;else it->second.prob+=ns.prob;#
      }#
    }#
    curMap.clear();#
    for(auto &m:newMap) if(m.second.prob>=prune_threshold) curMap[m.first]=m.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob;if(p<=0)continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,lruc=0,lrind=0;#
    {#
      double phat=(c1==0?0:(c1==n?1.0:double(c1)/n));#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      lruc=-2*(c1*std::log(p_)+(n-c1)*std::log(1-p_)#
               - (c1*std::log(ph_)+(n-c1)*std::log(1-ph_)));#
    }#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=(s01>0?double(T01)/s01:1.0);#
      double pi11=(s11>0?double(T11)/s11:1.0);#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)#
                +T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    lrDist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;vec.reserve(lrDist.size());#
  for(auto &kv:lrDist)vec.push_back({kv.first,kv.second});#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15)curP+=vec[i].second;#
      else{LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second;}#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) fb_lrcc_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  LRuc <- -2*((c1*log(p_)+(n-c1)*log(1-p_)) - (c1*log(ph_)+(n-c1)*log(1-ph_)))#
  if(n<=1) return(LRuc)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
    if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
    if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
    if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- T1/(n-1)#
  num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  LRind <- -2*(num - den)#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals <= LRobs])#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff_vec <- numeric(Nrep)#
    diff_decision_vec <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff_vec[i] <- abs(pval_exact - pval_chi2)#
      diff_decision_vec[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    mean_abs_diff <- mean(abs_diff_vec)#
    sd_abs_diff <- sd(abs_diff_vec)#
    se_abs_diff <- sd_abs_diff / sqrt(Nrep)#
    ci_lower_diff <- mean_abs_diff - 1.96*se_abs_diff#
    ci_upper_diff <- mean_abs_diff + 1.96*se_abs_diff#
#
    prop_diff <- mean(diff_decision_vec)#
    # 二项近似#
    se_prop <- sqrt(prop_diff*(1-prop_diff)/Nrep)#
    ci_lower_prop <- prop_diff - 1.96*se_prop#
    ci_upper_prop <- prop_diff + 1.96*se_prop#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean_abs_diff,#
      diff_ci_low = ci_lower_diff,#
      diff_ci_up  = ci_upper_diff,#
      prop_diff_in_decision = prop_diff,#
      prop_ci_low = ci_lower_prop,#
      prop_ci_up  = ci_upper_prop#
    ))#
  }#
}#
#
results_plot <- results#
#
p1 <- ggplot(results_plot, aes(x = factor(n), y = mean_abs_pval_diff, fill = factor(alpha))) +#
  geom_col(position = position_dodge(width = 0.9)) +#
  geom_errorbar(aes(ymin = diff_ci_low, ymax = diff_ci_up),#
                position = position_dodge(width = 0.9), width = 0.2) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x = factor(n), y = prop_diff_in_decision, fill = factor(alpha))) +#
  geom_col(position = position_dodge(width = 0.9)) +#
  geom_errorbar(aes(ymin = prop_ci_low, ymax = prop_ci_up),#
                position = position_dodge(width = 0.9), width = 0.2) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <cmath>#
using namespace Rcpp;#
static inline double sl(double x){return x>0?log(x):0;}#
struct S{int la,c1,T00,T10,T01,T11;double pr;};#
struct H{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
#
static inline long long enc(int la,int c1,int T00,int T10,int T01,int T11,int N){#
  long long b=N+10,c=b*(N+10),d=c*(N+10),e=d*(N+10),f=e*(N+10);#
  return la+b*c1+c*T00+d*T10+e*T01+f*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double a=0.05,double th=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int N=n+5;#
  std::unordered_map<long long,S,H> cur;#
  cur[enc(0,0,0,0,0,0,N)]={0,0,0,0,0,0,1.0-a};#
  cur[enc(1,1,0,0,0,0,N)]={1,1,0,0,0,0,a};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,S,H> nxt;nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.pr;if(p<th)continue;#
      int la=kv.second.la;#
      double p0=1.0-a,p1=a;#
      {S ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.pr=p*p0;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
      {S ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.pr=p*p1;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
    }#
    cur.clear();#
    for(auto &kv:nxt)if(kv.second.pr>=th)cur[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.pr;if(p<=0)continue;#
    int n1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,p_=std::max(std::min(a,1.0-eps),eps);#
    double phat=n1==0?0:(n1==n?1:(double)n1/n);#
    double ph_=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2*(n1*log(p_)+(n-n1)*log(1-p_)-n1*log(ph_)-(n-n1)*log(1-ph_));#
    double lrind=0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*sl(1-ph)+T1*sl(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1,pi11=s11>0?(double)T11/s11:1;#
      double den=T00*sl(1-pi01)+T01*sl(pi01)+T10*sl(1-pi11)+T11*sl(pi11);#
      lrind=-2*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  NumericVector LR,PR;#
  if(!dist.empty()){#
    std::vector<std::pair<double,double>> v(dist.begin(),dist.end());#
    std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
    double cl=v[0].first,cp=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(fabs(v[i].first-cl)<1e-15)cp+=v[i].second;#
      else{LR.push_back(cl);PR.push_back(cp);cl=v[i].first;cp=v[i].second;}#
    }#
    LR.push_back(cl);PR.push_back(cp);#
  }#
  return List::create(Named("LR")=LR,Named("prob")=PR);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,pr=1e-15) fb_lrcc_fastcpp(n,alpha,pr)#
#
my_LRcc <- function(X,alpha){#
  n<-length(X);c1<-sum(X);eps<-1e-15#
  p_<-max(min(alpha,1-eps),eps);ph_<-max(min(c1/n,1-eps),eps)#
  LRuc<- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00<-T01<-T10<-T11<-0#
  if(n>1)for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0)T00<-T00+1#
    if(X[i-1]==0&&X[i]==1)T01<-T01+1#
    if(X[i-1]==1&&X[i]==0)T10<-T10+1#
    if(X[i-1]==1&&X[i]==1)T11<-T11+1}#
  if(n>1){#
    T0<-T00+T10;T1<-T01+T11;pH<-T1/(n-1)#
    num<-T0*safe_log(1-pH)+T1*safe_log(pH)#
    s01<-T00+T01;pi01<-if(s01>0)T01/s01 else 1#
    s11<-T10+T11;pi11<-if(s11>0)T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }else LRind<-0#
  LRuc+LRind#
}#
#
p_exact <- function(LR,prob,obs) 1-sum(prob[LR<=obs])#
#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results<-data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrcc(n_,alpha_,1e-15)#
    LRv<-dist$LR;Pv<-dist$prob#
    abs_diff<-diff_dec<-rej_e<-rej_c<-numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X<-rbinom(n_,1,alpha_)#
      LRobs<-my_LRcc(X,alpha_)#
      pe<-p_exact(LRv,Pv,LRobs)#
      pc<-1-pchisq(LRobs,df=2)#
      abs_diff[i]<-abs(pe-pc)#
      diff_dec[i]<-as.numeric((pe<0.05)!=(pc<0.05))#
      rej_e[i]<-pe<0.05#
      rej_c[i]<-pc<0.05#
    }#
    results<-rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec),#
      size_exact=mean(rej_e),#
      size_chi2=mean(rej_c),#
      delta_size=mean(rej_e)-mean(rej_c)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
#
p1<-ggplot(results,aes(factor(n),size_exact,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+geom_hline(yintercept=0.05,lty=2)+#
  labs(x="n",y="size_exact",fill="alpha")+theme_minimal()#
p2<-ggplot(results,aes(factor(n),size_chi2,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+geom_hline(yintercept=0.05,lty=2)+#
  labs(x="n",y="size_chi2",fill="alpha")+theme_minimal()#
p3<-ggplot(results,aes(factor(n),delta_size,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+#
  labs(x="n",y="delta_size",fill="alpha")+theme_minimal()#
p4<-ggplot(results,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+#
  labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p5<-ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+#
  labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
#
results#
(p1|p2)/(p3|p4|p5)
# LRcc: Comparison via Markov Bernoulli simulated data#
#
library(Rcpp)#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double sl(double x){return x>0.0?std::log(x):0.0;}#
struct S{int la,c1,T00,T10,T01,T11;double pr;};#
struct H{std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long enc(int la,int c1,int T00,int T10,int T01,int T11,int N){#
  long long b=N+10,c=b*(N+10),d=c*(N+10),e=d*(N+10),f=e*(N+10);#
  return (long long)la+b*c1+c*T00+d*T10+e*T01+f*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double a=0.05,double th=1e-15){#
  if(n<1){NumericVector LR(0),pr(0);return List::create(Named("LR")=LR,Named("prob")=pr);}#
  int N=n+5;#
  std::unordered_map<long long,S,H> cur;#
  cur[enc(0,0,0,0,0,0,N)]={0,0,0,0,0,0,1.0-a};#
  cur[enc(1,1,0,0,0,0,N)]={1,1,0,0,0,0,a};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,S,H> nxt;nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.pr;if(p<th)continue;#
      int la=kv.second.la;#
      double p0=1.0-a,p1=a;#
      {S ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.pr=p*p0;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
      {S ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.pr=p*p1;#
       long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
       auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;}#
    }#
    cur.clear();#
    for(auto &kv:nxt)if(kv.second.pr>=th)cur[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.pr;if(p<=0)continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,pp=std::max(std::min(a,1.0-eps),eps);#
    double phat=c1==0?0:(c1==n?1:(double)c1/n);#
    double ph=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2*(c1*std::log(pp)+(n-c1)*std::log(1-pp)-c1*std::log(ph)-(n-c1)*std::log(1-ph));#
    double lrind=0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*sl(1-ph)+T1*sl(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1,pi11=s11>0?(double)T11/s11:1;#
      double den=T00*sl(1-pi01)+T01*sl(pi01)+T10*sl(1-pi11)+T11*sl(pi11);#
      lrind=-2*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> v;v.reserve(dist.size());#
  for(auto &kv:dist)v.emplace_back(kv.first,kv.second);#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,PR;#
  if(!v.empty()){#
    double cl=v[0].first,cp=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(std::fabs(v[i].first-cl)<1e-15)cp+=v[i].second;#
      else{LR.push_back(cl);PR.push_back(cp);cl=v[i].first;cp=v[i].second;}#
    }#
    LR.push_back(cl);PR.push_back(cp);#
  }#
  return List::create(Named("LR")=LR,Named("prob")=PR);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,pr=1e-15)fb_lrcc_fastcpp(n,alpha,pr)#
#
my_LRcc <- function(X,alpha){#
  n<-length(X);c1<-sum(X);eps<-1e-15#
  p_<-max(min(alpha,1-eps),eps);ph_<-max(min(c1/n,1-eps),eps)#
  LRuc<- -2*((c1*log(p_)+(n-c1)*log(1-p_))-(c1*log(ph_)+(n-c1)*log(1-ph_)))#
  T00<-T01<-T10<-T11<-0#
  if(n>1)for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0)T00<-T00+1#
    if(X[i-1]==0&&X[i]==1)T01<-T01+1#
    if(X[i-1]==1&&X[i]==0)T10<-T10+1#
    if(X[i-1]==1&&X[i]==1)T11<-T11+1#
  }#
  if(n>1){#
    T0<-T00+T10;T1<-T01+T11;pH<-T1/(n-1)#
    num<-T0*safe_log(1-pH)+T1*safe_log(pH)#
    s01<-T00+T01;pi01<-if(s01>0)T01/s01 else 1#
    s11<-T10+T11;pi11<-if(s11>0)T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<- -2*(num-den)#
  }else LRind<-0#
  LRuc+LRind#
}#
#
p_exact <- function(LR,prob,obs){1-sum(prob[LR<=obs])}#
#
gen_markov <- function(n,alpha,kappa=1.3,phi=0.6){#
  p_bar<-kappa*alpha#
  p01<-p_bar*(1-phi)/(1-p_bar)#
  p11<-phi#
  x<-numeric(n)#
  x[1]<-rbinom(1,1,p_bar)#
  for(i in 2:n){#
    if(x[i-1]==0)x[i]<-rbinom(1,1,p01)#
    else x[i]<-rbinom(1,1,p11)#
  }#
  x#
}#
#
set.seed(123)#
n_list<-c(20,30,40,50,100,150,200)#
alpha_list<-c(0.005,0.01,0.025,0.05)#
Nrep<-2000#
results<-data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrcc(n_,alpha_,1e-15)#
    LRv<-dist$LR;Pv<-dist$prob#
    re<-rc<-dd<-numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X<-gen_markov(n_,alpha_)#
      LRobs<-my_LRcc(X,alpha_)#
      pe<-p_exact(LRv,Pv,LRobs)#
      pc<-1-pchisq(LRobs,df=2)#
      re[i]<-pe<0.05#
      rc[i]<-pc<0.05#
      dd[i]<-as.numeric(re[i]!=rc[i])#
    }#
    results<-rbind(results,data.frame(#
      n=n_,alpha=alpha_,#
      power_exact=mean(re),#
      power_chi2=mean(rc),#
      diff_decision=mean(dd)#
    ))#
  }#
}#
#
library(ggplot2);library(patchwork)#
p1<-ggplot(results,aes(factor(n),power_exact,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_exact",fill="alpha")+theme_minimal()#
p2<-ggplot(results,aes(factor(n),power_chi2,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="power_chi2",fill="alpha")+theme_minimal()#
p3<-ggplot(results,aes(factor(n),diff_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+labs(x="n",y="diff_decision",fill="alpha")+theme_minimal()#
results#
p1/p2/p3
library(Rcpp)#
library(ggplot2)#
library(patchwork)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double sl(double x){return x>0.0?std::log(x):0.0;}#
struct S{int la,c1,T00,T10,T01,T11;double pr;};#
struct H{std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long enc(int la,int c1,int T00,int T10,int T01,int T11,int N){#
  long long b=N+10,c=b*(N+10),d=c*(N+10),e=d*(N+10),f=e*(N+10);#
  return (long long)la+b*c1+c*T00+d*T10+e*T01+f*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double a=0.05,double th=1e-15){#
  if(n<1){NumericVector LR(0),pr(0);return List::create(Named("LR")=LR,Named("prob")=pr);}#
  int N=n+5;#
  std::unordered_map<long long,S,H> cur;#
  cur[enc(0,0,0,0,0,0,N)]={0,0,0,0,0,0,1.0-a};#
  cur[enc(1,1,0,0,0,0,N)]={1,1,0,0,0,0,a};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,S,H> nxt;nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.pr;if(p<th)continue;#
      int la=kv.second.la;#
      double p0=1.0-a,p1=a;#
      {#
        S ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.pr=p*p0;#
        long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
        auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;#
      }#
      {#
        S ns=kv.second;if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;}ns.la=1;ns.pr=p*p1;#
        long long c=enc(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
        auto it=nxt.find(c);if(it==nxt.end())nxt[c]=ns;else it->second.pr+=ns.pr;#
      }#
    }#
    cur.clear();#
    for(auto &m:nxt)if(m.second.pr>=th)cur[m.first]=m.second;#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.pr;if(p<=0)continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15,pp=std::max(std::min(a,1.0-eps),eps);#
    double phat=c1==0?0:(c1==n?1.0:double(c1)/n);#
    double ph=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2*(c1*std::log(pp)+(n-c1)*std::log(1-pp)-c1*std::log(ph)-(n-c1)*std::log(1-ph));#
    double lrind=0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph2=(double)T1/(n-1);#
      double num=T0*sl(1-ph2)+T1*sl(ph2);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0,pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*sl(1-pi01)+T01*sl(pi01)+T10*sl(1-pi11)+T11*sl(pi11);#
      lrind=-2*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> v;v.reserve(dist.size());#
  for(auto &kv:dist)v.emplace_back(kv.first,kv.second);#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,PR;#
  if(!v.empty()){#
    double cl=v[0].first,cp=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(std::fabs(v[i].first-cl)<1e-15)cp+=v[i].second;#
      else{LR.push_back(cl);PR.push_back(cp);cl=v[i].first;cp=v[i].second;}#
    }#
    LR.push_back(cl);PR.push_back(cp);#
  }#
  return List::create(Named("LR")=LR,Named("prob")=PR);#
}')#
#
fb_lrcc <- function(n,alpha=0.05,pr=1e-15) fb_lrcc_fastcpp(n,alpha,pr)#
#
my_LRcc <- function(X,alpha){#
  n<-length(X); c1<-sum(X); eps<-1e-15#
  p_<-max(min(alpha,1-eps),eps); ph_<-max(min(c1/n,1-eps),eps)#
  LRuc<- -2*((c1*log(p_)+(n-c1)*log(1-p_)) - (c1*log(ph_)+(n-c1)*log(1-ph_)))#
  if(n<=1) return(LRuc)#
  T00<-T01<-T10<-T11<-0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  T0<-T00+T10; T1<-T01+T11#
  pH<-T1/(n-1)#
  num<-T0*safe_log(1-pH)+T1*safe_log(pH)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  LRind<- -2*(num - den)#
  LRuc + LRind#
}#
#
p_exact <- function(LR,prob,obs) 1 - sum(prob[LR <= obs])#
#
gen_markov <- function(n,alpha,kappa=1.3,phi=0.6){#
  p_bar<-kappa*alpha#
  p01<-p_bar*(1-phi)/(1-p_bar)#
  p11<-phi#
  x<-numeric(n)#
  x[1]<-rbinom(1,1,p_bar)#
  for(i in 2:n){#
    if(x[i-1]==0) x[i]<-rbinom(1,1,p01)#
    else x[i]<-rbinom(1,1,p11)#
  }#
  x#
}#
#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results<-data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrcc(n_,alpha_,1e-15)#
    LRv<-dist$LR; Pv<-dist$prob#
    re<-rc<-numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X<-gen_markov(n_,alpha_)#
      LRobs<-my_LRcc(X,alpha_)#
      pe<-p_exact(LRv,Pv,LRobs)#
      pc<-1-pchisq(LRobs,df=2)#
      re[i]<-as.numeric(pe<0.05)#
      rc[i]<-as.numeric(pc<0.05)#
    }#
    results<-rbind(results, data.frame(#
      n=n_,#
      alpha=alpha_,#
      power_diff = mean(re) - mean(rc), #
      prop_diff_in_decision = mean(re != rc)#
    ))#
  }#
}#
#
p1<-ggplot(results,aes(factor(n),power_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+#
  labs(x="n",#
       y="Power difference (Exact - Chi2)",#
       fill="alpha",#
       subtitle="A positive value indicates higher power by the exact LRcc method")+#
  theme_minimal()#
#
p2<-ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position="dodge")+#
  labs(x="n",y="prop_diff_in_decision",fill="alpha")+#
  theme_minimal()#
#
p1 / p2
results
library(Rcpp)#
#
safe_log <- function(x, eps = 1e-15) log(pmax(x, eps))#
#
LRuc_count <- function(x, n, p) {#
  phat <- if (x == 0) 0 else if (x == n) 1 else x / n#
  eps <- 1e-15#
  p_  <- max(min(p, 1 - eps), eps)#
  ph_ <- max(min(phat, 1 - eps), eps)#
  num <- x * safe_log(p_) + (n - x) * safe_log(1 - p_)#
  den <- x * safe_log(ph_) + (n - x) * safe_log(1 - ph_)#
  -2 * (num - den)#
}#
#
LRind_counts_loc <- function(T00, T10, T01, T11, n) {#
  if (n <= 1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if ((n - 1) > 0) T1 / (n - 1) else 0#
  num <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
  pi01 <- if ((T00 + T01) > 0) T01 / (T00 + T01) else 1#
  pi11 <- if ((T10 + T11) > 0) T11 / (T10 + T11) else 1#
  den <- T00 * safe_log(1 - pi01) + T01 * safe_log(pi01) +#
         T10 * safe_log(1 - pi11) + T11 * safe_log(pi11)#
  -2 * (num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  {#
    State s0{0,0,0,0,0,0,1.0-alpha};#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1{1,1,0,0,0,0,alpha};#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la  = kv.second.la;#
      int c1  = kv.second.c1;#
      int T00 = kv.second.T00;#
      int T10 = kv.second.T10;#
      int T01 = kv.second.T01;#
      int T11 = kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la   = 0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la   = 1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1  = kv.second.c1;#
    int T00 = kv.second.T00;#
    int T10 = kv.second.T10;#
    int T01 = kv.second.T01;#
    int T11 = kv.second.T11;#
#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha = 0.05, prune_threshold = 1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_  <- max(min(alpha, 1 - eps), eps)#
  ph_ <- max(min(c1 / n, 1 - eps), eps)#
  num_uc <- c1 * safe_log(p_) + (n - c1) * safe_log(1 - p_)#
  den_uc <- c1 * safe_log(ph_) + (n - c1) * safe_log(1 - ph_)#
  LRuc <- -2 * (num_uc - den_uc)#
#
  T00 <- T01 <- T10 <- T11 <- 0#
  if (n > 1) {#
    for (i in 2:n) {#
      if (X[i - 1] == 0 && X[i] == 0) T00 <- T00 + 1#
      if (X[i - 1] == 0 && X[i] == 1) T01 <- T01 + 1#
      if (X[i - 1] == 1 && X[i] == 0) T10 <- T10 + 1#
      if (X[i - 1] == 1 && X[i] == 1) T11 <- T11 + 1#
    }#
  }#
  LRind <- if (n > 1) {#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1 / (n - 1)#
    num <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if (s01 > 0) T01 / s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if (s11 > 0) T11 / s11 else 1#
    den <- T00 * safe_log(1 - pi01) + T01 * safe_log(pi01) +#
           T10 * safe_log(1 - pi11) + T11 * safe_log(pi11)#
    -2 * (num - den)#
  } else 0#
#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  sum(probvals[LRvals >= LRobs])#
}#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for (n_ in n_list) {#
  for (alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
#
    for (i in seq_len(Nrep)) {#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df = 2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- (pval_exact < 0.05) != (pval_chi2 < 0.05)#
    }#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      se_abs = sd(abs_diff) / sqrt(Nrep),#
      prop_diff_in_decision = mean(diff_decision),#
      se_dec = sd(diff_decision) / sqrt(Nrep)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(x = factor(n), y = mean_abs_pval_diff,#
                               fill = factor(alpha))) +#
  geom_bar(stat = "identity", position = position_dodge()) +#
  geom_errorbar(aes(ymin = mean_abs_pval_diff - se_abs,#
                    ymax = mean_abs_pval_diff + se_abs),#
                position = position_dodge(width = 0.9), width = 0.2) +#
  labs(x = "n", y = "mean_abs_pval_diff", fill = "alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x = factor(n), y = prop_diff_in_decision,#
                               fill = factor(alpha))) +#
  geom_bar(stat = "identity", position = position_dodge()) +#
  geom_errorbar(aes(ymin = prop_diff_in_decision - se_dec,#
                    ymax = prop_diff_in_decision + se_dec),#
                position = position_dodge(width = 0.9), width = 0.2) +#
  labs(x = "n", y = "prop_diff_in_decision", fill = "alpha") +#
  theme_minimal()#
#
results#
p1 / p2
# LRcc: P-value Comparison via Bernoulli simulated data#
#
library(Rcpp)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return x>0.0 ? std::log(x) : 0.0;#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  // initialization#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  // forward#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      // next state if we observe 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      // next state if we observe 1#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  // gather distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    // LRuc#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double eps=1e-15;#
      double p_=std::max(std::min(alpha,1.0-eps),eps);#
      double ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    // LRind#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(n-1>0)?((double)T1/(double)(n-1)):0.0;#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  ph_ <- max(min(c1/n,1-eps), eps)#
  num_uc <- c1*log(p_) + (n-c1)*log(1-p_)#
  den_uc <- c1*log(ph_) + (n-c1)*log(1-ph_)#
  LRuc <- -2*(num_uc - den_uc)#
  T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
  if(n>1){#
    for(i in 2:n){#
      if(X[i-1]==0 && X[i]==0) T00 <- T00+1#
      if(X[i-1]==0 && X[i]==1) T01 <- T01+1#
      if(X[i-1]==1 && X[i]==0) T10 <- T10+1#
      if(X[i-1]==1 && X[i]==1) T11 <- T11+1#
    }#
  }#
  if(n>1){#
    T0 <- T00 + T10#
    T1 <- T01 + T11#
    pHat <- T1/(n-1)#
    num <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
    s01 <- T00 + T01#
    pi01 <- if(s01>0) T01/s01 else 1#
    s11 <- T10 + T11#
    pi11 <- if(s11>0) T11/s11 else 1#
    den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
           T10*safe_log(1-pi11) + T11*safe_log(pi11)#
    LRind <- -2*(num - den)#
  } else {#
    LRind <- 0#
  }#
  LRuc + LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  # p-value = 1 - CDF(LRobs)#
  cdf_val <- sum(probvals[LRvals <= LRobs])#
  1 - cdf_val#
}#
#
set.seed(123)#
n_list <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15) #
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRcc(X, alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    # mean_abs_pval_diff: This is the average absolute difference between#
    # the exact p-value and the chi-square-based p-value across all simulations.#
#
    # prop_diff_in_decision: This is the proportion of simulated samples#
    # for which the exact method and the chi-square method give different#
    # reject/not-reject decisions at 5% significance.#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_decision)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
results#
p1 / p2
library(Rcpp)#
#
safe_log <- function(x, eps = 1e-15) log(pmax(x, eps))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  const double EPS = 1e-15;#
  return std::log(x > 0.0 ? x : EPS);#
}#
#
struct State{#
  int la,c1,T00,T10,T01,T11; double prob;#
};#
#
struct LLHash{ std::size_t operator()(long long x) const{ return std::hash<long long>()(x);} };#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long S2=NMAX+10,S3=S2*(NMAX+10),S4=S3*(NMAX+10),S5=S4*(NMAX+10),S6=S5*(NMAX+10);#
  return (long long)la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur.reserve(2);#
  State s0{0,0,0,0,0,0,1.0-alpha};#
  State s1{1,1,0,0,0,0,alpha};#
  cur[encode6(0,0,0,0,0,0,NMAX)]=s0;#
  cur[encode6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nxt; nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune_threshold) continue;#
      int la=kv.second.la,c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      State ns=kv.second;#
      if(la==0) ns.T00++; else ns.T10++; ns.la=0; ns.prob=p*p0;#
      long long h=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
      auto it=nxt.find(h); if(it==nxt.end()) nxt[h]=ns; else it->second.prob+=ns.prob;#
      ns=kv.second;#
      if(la==0){ns.T01++;ns.c1++;}else{ns.T11++;ns.c1++;} ns.la=1; ns.prob=p*p1;#
      h=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
      it=nxt.find(h); if(it==nxt.end()) nxt[h]=ns; else it->second.prob+=ns.prob;#
    }#
    cur.clear();#
    for(auto &km:nxt) if(km.second.prob>=prune_threshold) cur[km.first]=km.second;#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0.0) continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double lruc,lrind,eps=1e-15;#
    {#
      double phat=c1==0?0.0:(c1==n?1.0:(double)c1/n);#
      double p_=std::max(std::min(alpha,1.0-eps),eps),ph_=std::max(std::min(phat,1.0-eps),eps);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num-den);#
    }#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1.0-ph)+T1*s_log(ph);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01?((double)T01/s01):1.0,pi11=s11?((double)T11/s11):1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind=-2.0*(num-den);#
    }else lrind=0.0;#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> v; v.reserve(dist.size());#
  for(auto &kv:dist) v.push_back(kv);#
  std::sort(v.begin(),v.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!v.empty()){#
    double curLR=v[0].first,curP=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(std::fabs(v[i].first-curLR)<1e-15) curP+=v[i].second;#
      else{ LRout.push_back(curLR); Pout.push_back(curP); curLR=v[i].first; curP=v[i].second; }#
    }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) fb_lrcc_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); c1 <- sum(X); eps <- 1e-15#
  p_  <- max(min(alpha,1-eps),eps); ph_ <- max(min(c1/n,1-eps),eps)#
  LRuc <- -2*(c1*safe_log(p_)+(n-c1)*safe_log(1-p_) - (c1*safe_log(ph_)+(n-c1)*safe_log(1-ph_)))#
  T00<-T01<-T10<-T11<-0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  LRind <- if(n>1){#
    T0<-T00+T10; T1<-T01+T11; pHat<-T1/(n-1)#
    num<-T0*safe_log(1-pHat)+T1*safe_log(pHat)#
    s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
    s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    -2*(num-den)#
  } else 0#
  LRuc+LRind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) sum(probvals[LRvals >= LRobs])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) for(alpha_ in alpha_list){#
  dist <- fb_lrcc(n_,alpha_,1e-15)#
  LRvals <- dist$LR; probvals <- dist$prob#
  abs_diff <- numeric(Nrep); diff_decision <- numeric(Nrep)#
  for(i in seq_len(Nrep)){#
    X <- rbinom(n_,1,alpha_)#
    LRobs <- my_compute_LRcc(X,alpha_)#
    p_exact <- get_pval_exact(LRvals,probvals,LRobs)#
    p_chi2  <- 1-pchisq(LRobs,df=2)#
    abs_diff[i] <- abs(p_exact-p_chi2)#
    diff_decision[i] <- (p_exact<0.05)!=(p_chi2<0.05)#
  }#
  results <- rbind(results,data.frame(#
    n=n_,alpha=alpha_,#
    mean_abs_pval_diff=mean(abs_diff),#
    se_abs=sd(abs_diff)/sqrt(Nrep),#
    prop_diff_in_decision=mean(diff_decision),#
    se_dec=sd(diff_decision)/sqrt(Nrep)))#
}#
#
library(ggplot2); library(patchwork)#
p1 <- ggplot(results,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_bar(stat="identity",position=position_dodge())+#
  geom_errorbar(aes(ymin=mean_abs_pval_diff-se_abs,ymax=mean_abs_pval_diff+se_abs),#
                position=position_dodge(width=0.9),width=0.2)+#
  labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p2 <- ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
  geom_bar(stat="identity",position=position_dodge())+#
  geom_errorbar(aes(ymin=prop_diff_in_decision-se_dec,ymax=prop_diff_in_decision+se_dec),#
                position=position_dodge(width=0.9),width=0.2)+#
  labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
results#
p1/p2
p1/p2
for(n_ in c(50,100,150,200,250,300,500)){#
  for(a_ in c(0.01,0.025,0.05)){#
    s <- sum(fb_lrcc(n_, a_)$prob)#
    cat(sprintf("n=%3d  α=%5.3f  mass=% .12f\n", n_, a_, s))#
  }#
}
n <- 10; alpha <- 0.05#
dist <- fb_lrcc(n, alpha)               # “精确”分布#
set.seed(1); X <- rbinom(n, 1, alpha)#
LRobs <- my_compute_LRcc(X, alpha)#
#
# 精确 p#
pexact <- sum(dist$prob[dist$LR >= LRobs])#
#
# Monte-Carlo 完全枚举（2^10 = 1024，直接 brute force）#
library(gtools)#
allX <- permutations(2, n, v=0:1, repeats.allowed = TRUE)#
Lcall <- apply(allX, 1, my_compute_LRcc, alpha = alpha)#
pbrute <- mean(Lcall >= LRobs)#
#
print(c(pexact = pexact, brute = pbrute))
library(Rcpp)#
#
s_log <- function(x) {#
  if(x <= 0) -Inf else log(x)#
}#
#
LRuc_count <- function(x,n,p) {#
  phat <- x/n#
  num <- if(x>0 && x<n) x*s_log(p) + (n-x)*s_log(1-p) else if(x==0) (n-x)*s_log(1-p) else x*s_log(p)#
  den <- if(x>0 && x<n) x*s_log(phat) + (n-x)*s_log(1-phat) else if(x==0) (n-x)*s_log(1e-15) else x*s_log(1-(1e-15))#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- T1/(n-1)#
  num <- T0*s_log(1-pHat) + T1*s_log(pHat)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*s_log(1-pi01) + T01*s_log(pi01) + T10*s_log(1-pi11) + T11*s_log(pi11)#
  -2*(num - den)#
}#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#include <limits>#
using namespace Rcpp;#
static inline double s_log(double x){#
  if(x<=0.0) return -std::numeric_limits<double>::infinity();#
  return std::log(x);#
}#
struct State {#
  int la,c1,T00,T10,T01,T11;#
  double prob;#
};#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int N){#
  long long b=N+10,c=b*(N+10),d=c*(N+10),e=d*(N+10),f=e*(N+10);#
  return la + b*c1 + c*T00 + d*T10 + e*T01 + f*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int N=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  {#
    State s0={0,0,0,0,0,0,1.0-alpha};#
    cur[encode6(0,0,0,0,0,0,N)] = s0;#
    State s1={1,1,0,0,0,0,alpha};#
    cur[encode6(1,1,0,0,0,0,N)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nxt; #
    nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la=kv.second.la;#
      int c1=kv.second.c1;#
      int T00=kv.second.T00;#
      int T10=kv.second.T10;#
      int T01=kv.second.T01;#
      int T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob=p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
        auto it=nxt.find(c);#
        if(it==nxt.end()) nxt[c]=ns; else it->second.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else{ ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob=p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
        auto it=nxt.find(c);#
        if(it==nxt.end()) nxt[c]=ns; else it->second.prob+=ns.prob;#
      }#
    }#
    cur.clear();#
    for(auto &m:nxt){#
      if(m.second.prob>=prune_threshold) cur[m.first]=m.second;#
    }#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob;#
    if(p<=0.0) continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15;#
    double pp=std::max(std::min(alpha,1.0-eps),eps);#
    double phat= (c1==0 ? 0 : (c1==n ? 1 : double(c1)/n));#
    double ph= std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2.0*( c1*s_log(pp)+(n-c1)*s_log(1-pp)#
                       - (c1*s_log(ph)+(n-c1)*s_log(1-ph)) );#
    double lrind=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double ph2= double(T1)/(n-1);#
      double num = T0*s_log(1-ph2) + T1*s_log(ph2);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=(s01>0? double(T01)/s01:1.0),#
             pi11=(s11>0? double(T11)/s11:1.0);#
      double den = T00*s_log(1-pi01)+T01*s_log(pi01)#
                  +T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num - den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(dist.size());#
  for(auto &kv:dist) vec.push_back(std::make_pair(kv.first,kv.second));#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first, curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15) curP+=vec[i].second;#
      else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR=vec[i].first; #
        curP=vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
my_compute_LRcc <- function(X, alpha) {#
  n <- length(X)#
  c1 <- sum(X)#
  eps <- 1e-15#
  p_ <- max(min(alpha,1-eps), eps)#
  phat <- if(c1==0) 0 else if(c1==n) 1 else c1/n#
  p_ <- max(min(p_,1-eps), eps)#
  ph_ <- max(min(phat,1-eps), eps)#
  lruc <- -2*((c1*s_log(p_)+(n-c1)*s_log(1-p_)) - (c1*s_log(ph_)+(n-c1)*s_log(1-ph_)))#
  if(n<=1) return(lruc)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00<-T00+1#
    if(X[i-1]==0 && X[i]==1) T01<-T01+1#
    if(X[i-1]==1 && X[i]==0) T10<-T10+1#
    if(X[i-1]==1 && X[i]==1) T11<-T11+1#
  }#
  T0 <- T00+T10#
  T1 <- T01+T11#
  pH <- T1/(n-1)#
  num <- T0*s_log(1-pH) + T1*s_log(pH)#
  s01 <- T00+T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10+T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*s_log(1-pi01)+T01*s_log(pi01)+T10*s_log(1-pi11)+T11*s_log(pi11)#
  lrind <- -2*(num - den)#
  lruc + lrind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  cdf_left <- sum(probvals[LRvals < LRobs])#
  1 - cdf_left#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrcc(n_, alpha_, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_dec <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_,1,alpha_)#
      LRobs <- my_compute_LRcc(X,alpha_)#
      pval_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      pval_chi2  <- 1 - pchisq(LRobs, df=2)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_dec[i] <- as.numeric((pval_exact<0.05)!=(pval_chi2<0.05))#
    }#
    results <- rbind(results, data.frame(#
      n=n_,#
      alpha=alpha_,#
      mean_abs_pval_diff = mean(abs_diff),#
      prop_diff_in_decision = mean(diff_dec)#
    ))#
  }#
}#
#
library(ggplot2)#
library(patchwork)#
p1 <- ggplot(results,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_col(position=position_dodge(width=0.9))+#
  labs(x="n",y="mean_abs_pval_diff",fill="alpha")+#
  theme_minimal()#
#
p2 <- ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
  geom_col(position=position_dodge(width=0.9))+#
  labs(x="n",y="prop_diff_in_decision",fill="alpha")+#
  theme_minimal()#
#
p1 / p2
library(Rcpp)#
#
safe_log <- function(x, eps = 1e-15) log(pmax(x, eps))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  const double EPS = 1e-15;#
  return std::log(x > EPS ? x : EPS);#
}#
#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{std::size_t operator()(long long x) const{return std::hash<long long>()(x);}};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int N){#
  long long b=N+10,c=b*(N+10),d=c*(N+10),e=d*(N+10),f=e*(N+10);#
  return la + b*c1 + c*T00 + d*T10 + e*T01 + f*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-20){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int N=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[encode6(0,0,0,0,0,0,N)]={0,0,0,0,0,0,1.0-alpha};#
  cur[encode6(1,1,0,0,0,0,N)]={1,1,0,0,0,0,alpha};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nxt; nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune_threshold) continue;#
      int la=kv.second.la,c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      State ns=kv.second;#
      if(la==0) ns.T00++; else ns.T10++; ns.la=0; ns.prob=p*p0;#
      long long h=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
      auto it=nxt.find(h); if(it==nxt.end()) nxt[h]=ns; else it->second.prob+=ns.prob;#
      ns=kv.second;#
      if(la==0){ns.T01++; ns.c1++;}else{ns.T11++; ns.c1++;} ns.la=1; ns.prob=p*p1;#
      h=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
      it=nxt.find(h); if(it==nxt.end()) nxt[h]=ns; else it->second.prob+=ns.prob;#
    }#
    cur.clear();#
    for(auto &m:nxt) if(m.second.prob>=prune_threshold) cur[m.first]=m.second;#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0.0) continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15, pp=std::max(std::min(alpha,1.0-eps),eps);#
    double phat=c1==0?0:(c1==n?1:double(c1)/n);#
    double ph=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2.0*( c1*s_log(pp)+(n-c1)*s_log(1-pp) - (c1*s_log(ph)+(n-c1)*s_log(1-ph)) );#
    double lrind=0.0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph2=double(T1)/(n-1);#
      double num=T0*s_log(1-ph2)+T1*s_log(ph2);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01?double(T01)/s01:1.0,pi11=s11?double(T11)/s11:1.0;#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)+T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> v; v.reserve(dist.size());#
  for(auto &kv:dist) v.push_back(kv);#
  std::sort(v.begin(),v.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!v.empty()){#
    double curLR=v[0].first,curP=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(std::fabs(v[i].first-curLR)<1e-15) curP+=v[i].second;#
      else{ LRout.push_back(curLR); Pout.push_back(curP); curLR=v[i].first; curP=v[i].second; }#
    }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-20) fb_lrcc_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); c1 <- sum(X); eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps); phat <- if(c1==0) 0 else if(c1==n) 1 else c1/n#
  ph_ <- max(min(phat,1-eps),eps)#
  lruc <- -2*((c1*safe_log(p_)+(n-c1)*safe_log(1-p_)) - (c1*safe_log(ph_)+(n-c1)*safe_log(1-ph_)))#
  if(n<=1) return(lruc)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  T0 <- T00+T10; T1 <- T01+T11; pH <- T1/(n-1)#
  num <- T0*safe_log(1-pH)+T1*safe_log(pH)#
  s01 <- T00+T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10+T11; pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  lrind <- -2*(num - den)#
  lruc + lrind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) sum(probvals[LRvals >= LRobs])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) for(alpha_ in alpha_list){#
  dist <- fb_lrcc(n_,alpha_)#
  LRvals <- dist$LR; probvals <- dist$prob#
  abs_diff <- numeric(Nrep); diff_dec <- numeric(Nrep)#
  for(i in seq_len(Nrep)){#
    X <- rbinom(n_,1,alpha_)#
    LRobs <- my_compute_LRcc(X,alpha_)#
    p_exact <- get_pval_exact(LRvals,probvals,LRobs)#
    p_chi2  <- 1 - pchisq(LRobs, df = 2)#
    abs_diff[i] <- abs(p_exact - p_chi2)#
    diff_dec[i] <- (p_exact < 0.05) != (p_chi2 < 0.05)#
  }#
  results <- rbind(results,data.frame(#
    n=n_,alpha=alpha_,#
    mean_abs_pval_diff = mean(abs_diff),#
    prop_diff_in_decision = mean(diff_dec)#
  ))#
}#
#
library(ggplot2); library(patchwork)#
p1 <- ggplot(results,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_col(position=position_dodge(width=0.9))+#
  labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p2 <- ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
  geom_col(position=position_dodge(width=0.9))+#
  labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
results#
p1 / p2
library(Rcpp)#
#
safe_log <- function(x, eps = 1e-15) log(pmax(x, eps))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  const double EPS = 1e-15;#
  return std::log(x > EPS ? x : EPS);#
}#
#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{std::size_t operator()(long long x) const{return std::hash<long long>()(x);}};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int N){#
  long long b=N+10,c=b*(N+10),d=c*(N+10),e=d*(N+10),f=e*(N+10);#
  return la + b*c1 + c*T00 + d*T10 + e*T01 + f*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-20){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int N=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[encode6(0,0,0,0,0,0,N)]={0,0,0,0,0,0,1.0-alpha};#
  cur[encode6(1,1,0,0,0,0,N)]={1,1,0,0,0,0,alpha};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nxt; nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune_threshold) continue;#
      int la=kv.second.la,c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      State ns=kv.second;#
      if(la==0) ns.T00++; else ns.T10++; ns.la=0; ns.prob=p*p0;#
      long long h=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
      auto it=nxt.find(h); if(it==nxt.end()) nxt[h]=ns; else it->second.prob+=ns.prob;#
      ns=kv.second;#
      if(la==0){ns.T01++; ns.c1++;}else{ns.T11++; ns.c1++;} ns.la=1; ns.prob=p*p1;#
      h=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,N);#
      it=nxt.find(h); if(it==nxt.end()) nxt[h]=ns; else it->second.prob+=ns.prob;#
    }#
    cur.clear();#
    for(auto &m:nxt) if(m.second.prob>=prune_threshold) cur[m.first]=m.second;#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0.0) continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double eps=1e-15, pp=std::max(std::min(alpha,1.0-eps),eps);#
    double phat=c1==0?0:(c1==n?1:double(c1)/n);#
    double ph=std::max(std::min(phat,1.0-eps),eps);#
    double lruc=-2.0*( c1*s_log(pp)+(n-c1)*s_log(1-pp) - (c1*s_log(ph)+(n-c1)*s_log(1-ph)) );#
    double lrind=0.0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double ph2=double(T1)/(n-1);#
      double num=T0*s_log(1-ph2)+T1*s_log(ph2);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01?double(T01)/s01:1.0,pi11=s11?double(T11)/s11:1.0;#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)+T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> v; v.reserve(dist.size());#
  for(auto &kv:dist) v.push_back(kv);#
  std::sort(v.begin(),v.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!v.empty()){#
    double curLR=v[0].first,curP=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(std::fabs(v[i].first-curLR)<1e-15) curP+=v[i].second;#
      else{ LRout.push_back(curLR); Pout.push_back(curP); curLR=v[i].first; curP=v[i].second; }#
    }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-20) fb_lrcc_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); c1 <- sum(X); eps <- 1e-15#
  p_ <- max(min(alpha,1-eps),eps); phat <- if(c1==0) 0 else if(c1==n) 1 else c1/n#
  ph_ <- max(min(phat,1-eps),eps)#
  lruc <- -2*((c1*safe_log(p_)+(n-c1)*safe_log(1-p_)) - (c1*safe_log(ph_)+(n-c1)*safe_log(1-ph_)))#
  if(n<=1) return(lruc)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  T0 <- T00+T10; T1 <- T01+T11; pH <- T1/(n-1)#
  num <- T0*safe_log(1-pH)+T1*safe_log(pH)#
  s01 <- T00+T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10+T11; pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  lrind <- -2*(num - den)#
  lruc + lrind#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) sum(probvals[LRvals >= LRobs])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 10000#
results <- data.frame()#
#
for(n_ in n_list) for(alpha_ in alpha_list){#
  dist <- fb_lrcc(n_,alpha_)#
  LRvals <- dist$LR; probvals <- dist$prob#
  abs_diff <- numeric(Nrep); diff_dec <- numeric(Nrep)#
  for(i in seq_len(Nrep)){#
    X <- rbinom(n_,1,alpha_)#
    LRobs <- my_compute_LRcc(X,alpha_)#
    p_exact <- get_pval_exact(LRvals,probvals,LRobs)#
    p_chi2  <- 1 - pchisq(LRobs, df = 2)#
    abs_diff[i] <- abs(p_exact - p_chi2)#
    diff_dec[i] <- (p_exact < 0.05) != (p_chi2 < 0.05)#
  }#
  results <- rbind(results,data.frame(#
    n=n_,alpha=alpha_,#
    mean_abs_pval_diff = mean(abs_diff),#
    prop_diff_in_decision = mean(diff_dec)#
  ))#
}#
#
library(ggplot2); library(patchwork)#
p1 <- ggplot(results,aes(factor(n),mean_abs_pval_diff,fill=factor(alpha)))+#
  geom_col(position=position_dodge(width=0.9))+#
  labs(x="n",y="mean_abs_pval_diff",fill="alpha")+theme_minimal()#
p2 <- ggplot(results,aes(factor(n),prop_diff_in_decision,fill=factor(alpha)))+#
  geom_col(position=position_dodge(width=0.9))+#
  labs(x="n",y="prop_diff_in_decision",fill="alpha")+theme_minimal()#
results#
p1 / p2
## LRind:#
# Version 1 of the Forward Algorithm#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
fb_lrind <- function(n, alpha = 0.05, prune_threshold = 1e-15) {#
  combine_states <- function(mat) {#
    if (!nrow(mat)) return(mat)#
    o <- do.call(order, lapply(seq_len(5), function(i) mat[, i]))#
    mat <- mat[o, , drop = FALSE]#
    d  <- abs(diff(mat[, 1])) + abs(diff(mat[, 2])) + abs(diff(mat[, 3])) +#
          abs(diff(mat[, 4])) + abs(diff(mat[, 5]))#
    idx <- c(which(d > 0), nrow(mat))#
    out <- mat[idx, , drop = FALSE]#
    start <- 1#
    for (i in seq_along(idx)) {#
      s <- start; e <- idx[i]#
      if (s < e) out[i, 6] <- sum(mat[s:e, 6])#
      start <- e + 1#
    }#
    out#
  }#
#
  S <- matrix(c(0, 0, 0, 0, 0, 1 - alpha,#
                1, 0, 0, 0, 0, alpha),#
              nrow = 2, ncol = 6, byrow = TRUE)#
#
  for (k in seq_len(n - 1)) {#
    S <- S[S[, 6] >= prune_threshold, , drop = FALSE]#
    if (!nrow(S)) break#
#
    tmp0 <- S; tmp1 <- S#
    tmp0[, 2] <- tmp0[, 2] + ifelse(tmp0[, 1] == 0, 1, 0)#
    tmp0[, 3] <- tmp0[, 3] + ifelse(tmp0[, 1] == 1, 1, 0)#
    tmp0[, 1] <- 0#
    tmp0[, 6] <- tmp0[, 6] * (1 - alpha)#
#
    tmp1[, 4] <- tmp1[, 4] + ifelse(tmp1[, 1] == 0, 1, 0)#
    tmp1[, 5] <- tmp1[, 5] + ifelse(tmp1[, 1] == 1, 1, 0)#
    tmp1[, 1] <- 1#
    tmp1[, 6] <- tmp1[, 6] * alpha#
#
    S <- rbind(tmp0, tmp1)#
    S <- combine_states(S)#
  }#
#
  S <- S[S[, 6] > 0, , drop = FALSE]#
  if (!nrow(S)) return(list(LR = numeric(0), prob = numeric(0)))#
#
  T0 <- S[, 2] + S[, 3]#
  T1 <- S[, 4] + S[, 5]#
  pHat <- if (n > 1) T1 / (n - 1) else 0#
  num <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
#
  pi01 <- ifelse((S[, 2] + S[, 4]) > 0, S[, 4] / (S[, 2] + S[, 4]), 1)#
  pi11 <- ifelse((S[, 3] + S[, 5]) > 0, S[, 5] / (S[, 3] + S[, 5]), 1)#
  den <- S[, 2] * safe_log(1 - pi01) + S[, 4] * safe_log(pi01) +#
         S[, 3] * safe_log(1 - pi11) + S[, 5] * safe_log(pi11)#
#
  LR <- -2 * (num - den)#
  out <- cbind(LR, S[, 6])#
  o <- order(out[, 1]); out <- out[o, , drop = FALSE]#
#
  d <- c(diff(out[, 1]), 1)#
  idx <- c(which(d != 0), nrow(out))#
  final <- out[idx, , drop = FALSE]#
#
  start <- 1#
  for (i in seq_along(idx)) {#
    s <- start; e <- idx[i]#
    if (s < e) final[i, 2] <- sum(out[s:e, 2])#
    start <- e + 1#
  }#
#
  list(LR = final[, 1], prob = final[, 2])#
}#
#
main <- function() {#
  alpha_test <- 0.05#
  for (n_ in c(15, 100, 500, 1000, 2000)) {#
    cat(sprintf("\n=== n= %d, alpha= %g ===\n", n_, alpha_test))#
    t1 <- proc.time()#
    fb_res <- fb_lrind(n_, alpha_test, 1e-15)#
    tfb <- proc.time() - t1#
    cat(sprintf("FB time= %.3fs, #distinct LR= %d, sum(prob)= %.6f\n",#
                tfb["elapsed"], length(fb_res$LR), sum(fb_res$prob)))#
  }#
}#
main()
## LRind:#
# Version 1 of the Forward Algorithm#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  safe_log <- function(x) ifelse(x > 0, log(x), 0)#
  combine_states <- function(mat) {#
    if(!nrow(mat)) return(mat)#
    o <- do.call(order, lapply(seq_len(5), function(i) mat[,i]))#
    mat <- mat[o, , drop=FALSE]#
    d <- abs(diff(mat[,1])) + abs(diff(mat[,2])) + abs(diff(mat[,3])) + abs(diff(mat[,4])) + abs(diff(mat[,5]))#
    idx <- c(which(d > 0), nrow(mat))#
    out <- mat[idx, , drop=FALSE]#
    start <- 1#
    for(i in seq_along(idx)) {#
      s <- start#
      e <- idx[i]#
      if(s < e) out[i,6] <- sum(mat[s:e,6])#
      start <- e + 1#
    }#
    out#
  }#
  S <- matrix(c(0,0,0,0,0,1 - alpha,#
                1,0,0,0,0,alpha),#
              nrow=2, ncol=6, byrow=TRUE)#
  for(k in seq_len(n - 1)) {#
    S <- S[S[,6] >= prune_threshold, , drop=FALSE]#
    if(!nrow(S)) break#
    tmp0 <- S#
    tmp1 <- S#
    tmp0[,2] <- tmp0[,2] + ifelse(tmp0[,1] == 0, 1, 0)#
    tmp0[,3] <- tmp0[,3] + ifelse(tmp0[,1] == 1, 1, 0)#
    tmp0[,1] <- 0#
    tmp0[,6] <- tmp0[,6] * (1 - alpha)#
    tmp1[,4] <- tmp1[,4] + ifelse(tmp1[,1] == 0, 1, 0)#
    tmp1[,5] <- tmp1[,5] + ifelse(tmp1[,1] == 1, 1, 0)#
    tmp1[,1] <- 1#
    tmp1[,6] <- tmp1[,6] * alpha#
    S <- rbind(tmp0, tmp1)#
    S <- combine_states(S)#
  }#
  S <- S[S[,6] > 0, , drop=FALSE]#
  if(!nrow(S)) return(list(LR=numeric(0), prob=numeric(0)))#
  T0 <- S[,2] + S[,3]#
  T1 <- S[,4] + S[,5]#
  pHat <- if(n > 1) T1 / (n - 1) else 0#
  num <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
  pi01 <- ifelse((S[,2] + S[,4]) > 0, S[,4] / (S[,2] + S[,4]), 1)#
  pi11 <- ifelse((S[,3] + S[,5]) > 0, S[,5] / (S[,3] + S[,5]), 1)#
  den <- S[,2] * safe_log(1 - pi01) + S[,4] * safe_log(pi01) +#
         S[,3] * safe_log(1 - pi11) + S[,5] * safe_log(pi11)#
  LR <- -2 * (num - den)#
  out <- cbind(LR, S[,6])#
  o <- order(out[,1])#
  out <- out[o, , drop=FALSE]#
  d2 <- c(diff(out[,1]), 1)#
  idx2 <- c(which(d2 != 0), nrow(out))#
  final <- out[idx2, , drop=FALSE]#
  start <- 1#
  for(i in seq_along(idx2)) {#
    s <- start#
    e <- idx2[i]#
    if(s < e) final[i,2] <- sum(out[s:e,2])#
    start <- e + 1#
  }#
  list(LR=final[,1], prob=final[,2])#
}#
#
main <- function() {#
  alpha_test <- 0.05#
  for(n_ in c(15,100,500,1000,2000)) {#
    cat(sprintf("\n=== n= %d, alpha= %g ===\n", n_, alpha_test))#
    t1 <- proc.time()#
    fb_res <- fb_lrind(n_, alpha_test, 1e-15)#
    tfb <- proc.time() - t1#
    cat(sprintf("FB time= %.3fs, #distinct LR= %d, sum(prob)= %.6f\n",#
                tfb["elapsed"], length(fb_res$LR), sum(fb_res$prob)))#
  }#
}#
main()
# Version 2 of the Forward Algorithm (Rcpp: C++)#
#
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x) {#
  return std::log( x > EPS ? x : EPS );#
}#
#
struct State {#
  long long code;#
  int last;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_state(int last, int s00, int s10, int s01, int s11,#
                                     long long SHIFT2, long long SHIFT3,#
                                     long long SHIFT4, long long SHIFT5) {#
  return (long long)last#
         + SHIFT2*(long long)s00#
         + SHIFT3*(long long)s10#
         + SHIFT4*(long long)s01#
         + SHIFT5*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n < 1) {#
    return List::create(Named("LR")=NumericVector(0), Named("prob")=NumericVector(0));#
  }#
  long long SHIFT2 = 2LL;#
  long long SHIFT3 = SHIFT2 * (n+1);#
  long long SHIFT4 = SHIFT3 * (n+1);#
  long long SHIFT5 = SHIFT4 * (n+1);#
#
  std::vector<State> states;#
  states.reserve(2);#
#
  {#
    State s0;#
    s0.last=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0 - alpha;#
    s0.code = encode_state(s0.last, s0.s00, s0.s10, s0.s01, s0.s11, SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
    states.push_back(s0);#
    State s1;#
    s1.last=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
    s1.code = encode_state(s1.last, s1.s00, s1.s10, s1.s01, s1.s11, SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
    states.push_back(s1);#
  }#
#
  for(int k=1; k<n; k++) {#
    {#
      int idx=0;#
      for(int i=0; i<(int)states.size(); i++){#
        if(states[i].prob >= prune_threshold) {#
          states[idx++] = states[i];#
        }#
      }#
      states.resize(idx);#
    }#
    if(states.empty()) break;#
#
    std::unordered_map<long long, State, LLHash> newMap;#
    newMap.reserve(states.size()*2);#
#
    for(std::size_t i=0; i<states.size(); i++){#
      const State &st = states[i];#
      double p = st.prob;#
      if(p <= 0) continue;#
#
      {#
        State ns = st;#
        int inc00 = (ns.last==0)?1:0;#
        int inc10 = (ns.last==1)?1:0;#
        ns.s00 += inc00;#
        ns.s10 += inc10;#
        ns.last = 0;#
        ns.prob = p*(1.0 - alpha);#
        ns.code = encode_state(ns.last, ns.s00, ns.s10, ns.s01, ns.s11,#
                               SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
        auto it = newMap.find(ns.code);#
        if(it == newMap.end()){#
          newMap[ns.code] = ns;#
        } else {#
          it->second.prob += ns.prob;#
        }#
      }#
#
      {#
        State ns = st;#
        int inc01 = (ns.last==0)?1:0;#
        int inc11 = (ns.last==1)?1:0;#
        ns.s01 += inc01;#
        ns.s11 += inc11;#
        ns.last = 1;#
        ns.prob = p*alpha;#
        ns.code = encode_state(ns.last, ns.s00, ns.s10, ns.s01, ns.s11,#
                               SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
        auto it = newMap.find(ns.code);#
        if(it == newMap.end()){#
          newMap[ns.code] = ns;#
        } else {#
          it->second.prob += ns.prob;#
        }#
      }#
    }#
#
    states.clear();#
    states.reserve(newMap.size());#
    for(auto &kv : newMap) {#
      if(kv.second.prob>0) {#
        states.push_back(kv.second);#
      }#
    }#
  }#
#
  {#
    int idx=0;#
    for(int i=0; i<(int)states.size(); i++){#
      if(states[i].prob >= prune_threshold) {#
        states[idx++] = states[i];#
      }#
    }#
    states.resize(idx);#
  }#
  if(states.empty()) {#
    return List::create(Named("LR")=NumericVector(0), Named("prob")=NumericVector(0));#
  }#
#
  std::vector<double> LR; LR.reserve(states.size());#
  std::vector<double> PR; PR.reserve(states.size());#
  for(std::size_t i=0; i<states.size(); i++){#
    State &st = states[i];#
    int T0 = st.s00 + st.s10;#
    int T1 = st.s01 + st.s11;#
    double pHat = (n>1)? ( (double)T1 / (double)(n-1) ) : 0.0;#
    double num = T0*safe_log(1 - pHat) + T1*safe_log(pHat);#
    double denom=0.0;#
    int sum01 = st.s00 + st.s01;#
    double pi01 = (sum01>0)? ((double)st.s01/(double)sum01):1.0;#
    int sum11 = st.s10 + st.s11;#
    double pi11 = (sum11>0)? ((double)st.s11/(double)sum11):1.0;#
    denom += st.s00*safe_log(1 - pi01) + st.s01*safe_log(pi01);#
    denom += st.s10*safe_log(1 - pi11) + st.s11*safe_log(pi11);#
    double lrval = -2.0*(num - denom);#
    LR.push_back(lrval);#
    PR.push_back(st.prob);#
  }#
#
  std::vector<int> idx(states.size());#
  for(int i=0; i<(int)idx.size(); i++) idx[i]=i;#
  std::sort(idx.begin(), idx.end(), [&](int a, int b){ return LR[a] < LR[b]; });#
#
  std::vector<double> sortedLR; sortedLR.reserve(idx.size());#
  std::vector<double> sortedPR; sortedPR.reserve(idx.size());#
  for(auto i : idx){ sortedLR.push_back(LR[i]); sortedPR.push_back(PR[i]); }#
#
  NumericVector outLR, outProb;#
  if(!sortedLR.empty()){#
    double curLR = sortedLR[0];#
    double curP  = sortedPR[0];#
    for(int i=1; i<(int)sortedLR.size(); i++){#
      if(std::fabs(sortedLR[i] - curLR) < 1e-15) {#
        curP += sortedPR[i];#
      } else {#
        outLR.push_back(curLR);#
        outProb.push_back(curP);#
        curLR = sortedLR[i];#
        curP  = sortedPR[i];#
      }#
    }#
    outLR.push_back(curLR);#
    outProb.push_back(curP);#
  }#
  return List::create(Named("LR")=outLR, Named("prob")=outProb);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
}#
#
main <- function() {#
  alpha_test <- 0.05#
  for(n_ in c(15,100,500,1000,2000)) {#
    cat(sprintf("\n=== n= %d, alpha= %g ===\n", n_, alpha_test))#
    t1 <- proc.time()#
    fb_res <- fb_lrind(n_, alpha_test, 1e-15)#
    tfb <- proc.time() - t1#
    cat(sprintf("FB time= %.3fs, #distinct LR= %d, sum(prob)= %.6f\n",#
                tfb["elapsed"], length(fb_res$LR), sum(fb_res$prob)))#
  }#
}#
main()#
#
# Runtime Comparison#
#
main <- function() {#
   alpha_list <- c(0.01, 0.025, 0.05, 0.10)#
   n_list <- c(250, 500, 1000, 2000)#
   prune_threshold <- 1e-15#
   cat("   n     alpha   #distinct_LR    sum(prob)       time(s)\n")#
   for(alpha_ in alpha_list) {#
     for(n_ in n_list) {#
       t0 <- proc.time()#
       res <- fb_lrind(n_, alpha_, prune_threshold)#
       elapsed <- proc.time() - t0#
       LRvals <- res$LR#
       probvals <- res$prob#
       sumprob <- sum(probvals)#
       cat(sprintf("%5d  %7.3f  %12d  %10.8f  %10.4f\n",#
                   n_, alpha_, length(LRvals), sumprob, elapsed["elapsed"]))#
     }#
     cat("\n")#
   }#
 }#
main()#
#
# Under different pruning thresholds#
#
main <- function() {#
   thresholds <- c(1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10)#
   alpha_list <- c(0.01, 0.05, 0.10)#
   n_list <- c(500, 1000)#
   for(n_ in n_list) {#
     cat(sprintf("\nn = %d\n", n_))#
     for(alpha_ in alpha_list) {#
       cat(sprintf("\n=== alpha = %g ===\n", alpha_))#
       cat("prune_threshold     #distinct_LR     sum(prob)        time(s)\n")#
       for(th in thresholds) {#
         t0 <- proc.time()#
         res <- fb_lrind(n_, alpha_, th) #
         elapsed <- proc.time() - t0#
         LRvals <- res$LR#
         probvals <- res$prob#
         sumprob <- sum(probvals)#
         distinct_LR <- length(LRvals)#
         cat(sprintf("%-14g %14d %12.8f %12.4f\n",#
                     th, distinct_LR, sumprob, elapsed["elapsed"]))#
       }#
     }#
   }#
 }#
main()
# Comparison of CDFs  -------------------------------------------------------#
#
mc_lrind <- function(n, alpha = 0.05, Nrep = 20000) {#
  LR_values <- numeric(Nrep)#
  for (i in seq_len(Nrep)) {#
    path <- rbinom(n, 1, alpha)#
    T00 <- T01 <- T10 <- T11 <- 0#
    for (t in 2:n) {#
      if (path[t - 1] == 0 && path[t] == 0)       T00 <- T00 + 1#
      else if (path[t - 1] == 0 && path[t] == 1)  T01 <- T01 + 1#
      else if (path[t - 1] == 1 && path[t] == 0)  T10 <- T10 + 1#
      else                                        T11 <- T11 + 1#
    }#
    T0   <- T00 + T10#
    T1   <- T01 + T11#
    pHat <- if (n > 1) T1 / (n - 1) else 0#
#
    num   <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
    pi01  <- if ((T00 + T01) > 0) T01 / (T00 + T01) else 1#
    pi11  <- if ((T10 + T11) > 0) T11 / (T10 + T11) else 1#
    den   <- T00 * safe_log(1 - pi01) + T01 * safe_log(pi01) +#
             T10 * safe_log(1 - pi11) + T11 * safe_log(pi11)#
#
    LR_values[i] <- -2 * (num - den)#
  }#
#
  arr      <- sort(LR_values)#
  idx_diff <- which(diff(arr) > 0)#
  uniq_idx <- c(idx_diff, length(arr))#
  LRuniq   <- arr[uniq_idx]#
  prob_    <- diff(c(0, uniq_idx)) / Nrep#
  list(LR = LRuniq, prob = prob_)#
}#
#
step_cdf_plot <- function(LRvals, probs, col = "blue", lty = 1) {#
  cdf <- cumsum(probs)#
  x   <- c(0, LRvals)#
  y   <- c(0, cdf)#
  lines(x, y, type = "s", col = col, lty = lty)#
  points(x, y, pch = 16, cex = 0.5, col = col)#
}#
#
plot_three_distributions <- function(n, alpha, fb_res, mc_res) {#
  plot(0, 0, type = "n",#
       xlab = "LR value", ylab = "CDF",#
       xlim = c(0, max(c(fb_res$LR, mc_res$LR, 10))),#
       ylim = c(0, 1.02),#
       main = sprintf("Ind Test CDF\nn=%d, alpha=%.3f", n, alpha))#
  step_cdf_plot(fb_res$LR, fb_res$prob,  col = "blue",  lty = 1)#
  step_cdf_plot(mc_res$LR, mc_res$prob,  col = "green", lty = 2)#
  x_max <- max(c(fb_res$LR, mc_res$LR, 10))#
  x_chi <- seq(0, x_max + 0.2, length.out = 300)#
  y_chi <- pchisq(x_chi, df = 1)#
  lines(x_chi, y_chi, col = "red")#
  legend("bottomright",#
         legend = c("True(FB)", "Empirical(MC)", "Chi2(1)"),#
         lty = c(1, 2, 1), col = c("blue", "green", "red"), bty = "n")#
}#
#
main <- function() {#
  set.seed(42)#
  alpha_list <- c(0.01, 0.05, 0.10)#
  n_list     <- c(15, 100, 500)#
  prune_threshold <- 1e-15#
  Nrep <- 20000#
  cat("   n     alpha   #distinct_LR    sum(prob)       time(s)\n")#
  for (alpha_ in alpha_list) {#
    for (n_ in n_list) {#
      t0      <- proc.time()#
      fb_res  <- fb_lrind(n_, alpha_, prune_threshold)#
      elapsed <- proc.time() - t0#
      cat(sprintf("%5d  %7.3f  %12d  %10.8f  %10.4f\n",#
                  n_, alpha_, length(fb_res$LR), sum(fb_res$prob), elapsed["elapsed"]))#
#
      t0_mc     <- proc.time()#
      mc_res    <- mc_lrind(n_, alpha_, Nrep)#
      mc_elapsed<- proc.time() - t0_mc#
#
      dev.new(width = 5.5, height = 4)#
      plot_three_distributions(n_, alpha_, fb_res, mc_res)#
    }#
  }#
  cat("\nDone. Generated 9 figures (3 values of alpha x 3 values of n).\n")#
}#
main()#
#
# KS distance vs pruning threshold  ----------------------------------------#
#
cdf_xy <- function(LRvals, probvals) {#
  csum <- cumsum(probvals)#
  list(x = c(0, LRvals), y = c(0, csum))#
}#
#
cdf_val <- function(x, xx, yy) {#
  if (x <= xx[1])                 return(0)#
  if (x >= xx[length(xx)])        return(yy[length(yy)])#
  yy[findInterval(x, xx, rightmost.closed = TRUE)]#
}#
#
cdf_diff <- function(LRvals, probvals, df = 1) {#
  if (!length(LRvals)) return(0)#
  ord <- order(LRvals)#
  LRvals <- LRvals[ord]#
  probvals <- probvals[ord]#
  cxy <- cdf_xy(LRvals, probvals)#
  xmax <- cxy$x[length(cxy$x)] + 1#
  xs   <- seq(0, xmax, length.out = 600)#
  max(abs(cdf_val(xs, cxy$x, cxy$y) - pchisq(xs, df)))#
}#
#
main <- function() {#
  n <- 500#
  alpha_list <- c(0.01, 0.025, 0.05)#
  thresholds  <- c(1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10)#
  cat("n=500\n")#
  cat(" alpha    prune_threshold     #distinct_LR     sum(prob)     KS_distance\n")#
#
  results_df <- data.frame(alpha = numeric(),#
                           threshold = numeric(),#
                           distinct_LR = integer(),#
                           sumprob = numeric(),#
                           ks = numeric())#
#
  for (a_ in alpha_list) {#
    for (th in thresholds) {#
      dist_   <- fb_lrind(n, a_, th)#
      ks_     <- cdf_diff(dist_$LR, dist_$prob, 1)#
      cat(sprintf(" %6.3f   %-12g   %12d   %10.8f   %9.6f\n",#
                  a_, th, length(dist_$LR), sum(dist_$prob), ks_))#
      results_df <- rbind(results_df,#
                          data.frame(alpha = a_, threshold = th,#
                                     distinct_LR = length(dist_$LR),#
                                     sumprob = sum(dist_$prob), ks = ks_))#
    }#
    cat("\n")#
  }#
#
  plot(NULL, xlim = range(thresholds), ylim = c(0, 1), log = "x",#
       xlab = "prune_threshold", ylab = "KS distance",#
       main = "KS distance vs prune_threshold (n=500)")#
  clrs <- c("blue", "red", "green")#
  i <- 1#
  for (a_ in alpha_list) {#
    subdf <- subset(results_df, alpha == a_)#
    lines(subdf$threshold, subdf$ks, col = clrs[i], type = "b", pch = 19, lwd = 2)#
    i <- i + 1#
  }#
  legend("topright", legend = paste0("alpha=", alpha_list),#
         col = clrs, pch = 19, lwd = 2)#
}#
#
main()
# Comparison of CDFs  -------------------------------------------------------#
#
mc_lrind <- function(n, alpha = 0.05, Nrep = 20000) {#
  LR_values <- numeric(Nrep)#
  for (i in seq_len(Nrep)) {#
    path <- rbinom(n, 1, alpha)#
    T00 <- T01 <- T10 <- T11 <- 0#
    for (t in 2:n) {#
      if (path[t - 1] == 0 && path[t] == 0)       T00 <- T00 + 1#
      else if (path[t - 1] == 0 && path[t] == 1)  T01 <- T01 + 1#
      else if (path[t - 1] == 1 && path[t] == 0)  T10 <- T10 + 1#
      else                                        T11 <- T11 + 1#
    }#
    T0   <- T00 + T10#
    T1   <- T01 + T11#
    pHat <- if (n > 1) T1 / (n - 1) else 0#
#
    num   <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
    pi01  <- if ((T00 + T01) > 0) T01 / (T00 + T01) else 1#
    pi11  <- if ((T10 + T11) > 0) T11 / (T10 + T11) else 1#
    den   <- T00 * safe_log(1 - pi01) + T01 * safe_log(pi01) +#
             T10 * safe_log(1 - pi11) + T11 * safe_log(pi11)#
#
    LR_values[i] <- -2 * (num - den)#
  }#
#
  arr      <- sort(LR_values)#
  idx_diff <- which(diff(arr) > 0)#
  uniq_idx <- c(idx_diff, length(arr))#
  LRuniq   <- arr[uniq_idx]#
  prob_    <- diff(c(0, uniq_idx)) / Nrep#
  list(LR = LRuniq, prob = prob_)#
}#
#
step_cdf_plot <- function(LRvals, probs, col = "blue", lty = 1) {#
  cdf <- cumsum(probs)#
  x   <- c(0, LRvals)#
  y   <- c(0, cdf)#
  lines(x, y, type = "s", col = col, lty = lty)#
  points(x, y, pch = 16, cex = 0.5, col = col)#
}#
#
plot_three_distributions <- function(n, alpha, fb_res, mc_res) {#
  plot(0, 0, type = "n",#
       xlab = "LR value", ylab = "CDF",#
       xlim = c(0, max(c(fb_res$LR, mc_res$LR, 10))),#
       ylim = c(0, 1.02),#
       main = sprintf("Ind Test CDF\nn=%d, alpha=%.3f", n, alpha))#
  step_cdf_plot(fb_res$LR, fb_res$prob,  col = "blue",  lty = 1)#
  step_cdf_plot(mc_res$LR, mc_res$prob,  col = "green", lty = 2)#
  x_max <- max(c(fb_res$LR, mc_res$LR, 10))#
  x_chi <- seq(0, x_max + 0.2, length.out = 300)#
  y_chi <- pchisq(x_chi, df = 1)#
  lines(x_chi, y_chi, col = "red")#
  legend("bottomright",#
         legend = c("True(FB)", "Empirical(MC)", "Chi2(1)"),#
         lty = c(1, 2, 1), col = c("blue", "green", "red"), bty = "n")#
}#
#
main <- function() {#
  set.seed(42)#
  alpha_list <- c(0.01, 0.05, 0.10)#
  n_list     <- c(15, 100, 500)#
  prune_threshold <- 1e-15#
  Nrep <- 20000#
  cat("   n     alpha   #distinct_LR    sum(prob)       time(s)\n")#
  for (alpha_ in alpha_list) {#
    for (n_ in n_list) {#
      t0      <- proc.time()#
      fb_res  <- fb_lrind(n_, alpha_, prune_threshold)#
      elapsed <- proc.time() - t0#
      cat(sprintf("%5d  %7.3f  %12d  %10.8f  %10.4f\n",#
                  n_, alpha_, length(fb_res$LR), sum(fb_res$prob), elapsed["elapsed"]))#
#
      mc_res <- mc_lrind(n_, alpha_, Nrep)#
#
      dev.new(width = 5.5, height = 4)#
      plot_three_distributions(n_, alpha_, fb_res, mc_res)#
    }#
  }#
  cat("\nDone. Generated 9 figures (3 values of alpha x 3 values of n).\n")#
}#
main()#
#
# KS distance vs pruning threshold  ----------------------------------------#
#
cdf_xy <- function(LRvals, probvals) {#
  list(x = c(0, LRvals), y = c(0, cumsum(probvals)))#
}#
#
cdf_val <- function(x, xx, yy) {#
  idx <- findInterval(x, xx, rightmost.closed = TRUE)#
  yy[pmax.int(idx, 1L)]#
}#
#
cdf_diff <- function(LRvals, probvals, df = 1) {#
  if (!length(LRvals)) return(0)#
  ord <- order(LRvals)#
  cxy <- cdf_xy(LRvals[ord], probvals[ord])#
  xmax <- tail(cxy$x, 1) + 1#
  xs   <- seq(0, xmax, length.out = 600)#
  max(abs(cdf_val(xs, cxy$x, cxy$y) - pchisq(xs, df)))#
}#
#
main <- function() {#
  n <- 500#
  alpha_list <- c(0.01, 0.025, 0.05)#
  thresholds  <- c(1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10)#
  cat("n=500\n")#
  cat(" alpha    prune_threshold     #distinct_LR     sum(prob)     KS_distance\n")#
#
  results_df <- data.frame(alpha = numeric(),#
                           threshold = numeric(),#
                           distinct_LR = integer(),#
                           sumprob = numeric(),#
                           ks = numeric())#
#
  for (a_ in alpha_list) {#
    for (th in thresholds) {#
      dist_ <- fb_lrind(n, a_, th)#
      ks_   <- cdf_diff(dist_$LR, dist_$prob, 1)#
      cat(sprintf(" %6.3f   %-12g   %12d   %10.8f   %9.6f\n",#
                  a_, th, length(dist_$LR), sum(dist_$prob), ks_))#
      results_df <- rbind(results_df,#
                          data.frame(alpha = a_, threshold = th,#
                                     distinct_LR = length(dist_$LR),#
                                     sumprob = sum(dist_$prob), ks = ks_))#
    }#
    cat("\n")#
  }#
#
  plot(NULL, xlim = range(thresholds), ylim = c(0, 1), log = "x",#
       xlab = "prune_threshold", ylab = "KS distance",#
       main = "KS distance vs prune_threshold (n=500)")#
  clrs <- c("blue", "red", "green")#
  i <- 1#
  for (a_ in alpha_list) {#
    subdf <- subset(results_df, alpha == a_)#
    lines(subdf$threshold, subdf$ks, col = clrs[i], type = "b",#
          pch = 19, lwd = 2)#
    i <- i + 1#
  }#
  legend("topright", legend = paste0("alpha=", alpha_list),#
         col = clrs, pch = 19, lwd = 2)#
}#
#
main()
# KS distance v.s. alpha  ---------------------------------------------------#
#
cdf_xy <- function(LRvals, probvals) {#
  list(x = c(0, LRvals), y = c(0, cumsum(probvals)))#
}#
#
cdf_val <- function(x, xx, yy) {#
  idx <- findInterval(x, xx, rightmost.closed = TRUE)#
  yy[pmax.int(idx, 1L)]#
}#
#
cdf_diff <- function(LRvals, probvals, df = 1) {#
  if (!length(LRvals)) return(0)#
  ord <- order(LRvals)#
  cxy <- cdf_xy(LRvals[ord], probvals[ord])#
  xm  <- tail(cxy$x, 1) + 1#
  xs  <- seq(0, xm, length.out = 600)#
  max(abs(cdf_val(xs, cxy$x, cxy$y) - pchisq(xs, df)))#
}#
#
main <- function() {#
  n_list      <- c(250, 500, 1000)#
  alpha_vals  <- seq(0.01, 0.1, length.out = 21)#
  curves <- lapply(n_list, function(n_) {#
    sapply(alpha_vals, function(alpha_) {#
      dist_ <- fb_lrind(n_, alpha_, 1e-15)#
      cdf_diff(dist_$LR, dist_$prob, 1)#
    })#
  })#
#
  plot(NA, NA, type = "n", xlim = range(alpha_vals), ylim = c(0, 1),#
       xlab = "alpha", ylab = "KS distance",#
       main = "KS distance vs alpha")#
  cols <- c("blue", "red", "green")#
  for (i in seq_along(n_list)) {#
    lines(alpha_vals, curves[[i]], col = cols[i], lwd = 2)#
  }#
  legend("topright", legend = paste("n=", n_list), col = cols, lty = 1, lwd = 2)#
}#
main()
# KS distance v.s. n  ------------------------------------------------------#
#
main <- function() {#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmin <- 1#
  nmax <- 2000#
  step <- 1#
  cols <- c("red", "blue", "green")#
#
  plot(NULL, xlim = c(nmin, nmax), ylim = c(0, 1),#
       xlab = "n", ylab = "KS distance", main = "KS distance vs n")#
#
  for (i in seq_along(alpha_list)) {#
    a <- alpha_list[i]#
    dist_k <- initialize_dist_fastcpp(a)          # 已在会话中#
    nvals  <- seq(nmin, nmax, by = step)#
    ksvals <- numeric(length(nvals))#
#
    for (j in seq_along(nvals)) {#
      t <- nvals[j]#
      lrres  <- dist_at_current_fastcpp(dist_k, t) # 已在会话中#
      ksvals[j] <- ks_diff(lrres$LR, lrres$prob, 1)#
      if (t < nmax)#
        dist_k <- step_forward_fastcpp(dist_k, a, 1e-15, nmax)  # 已在会话中#
    }#
#
    lines(nvals, ksvals, col = cols[i], lwd = 2)#
  }#
#
  legend("topright", legend = paste0("alpha=", alpha_list),#
         col = cols, lty = 1, lwd = 2)#
}#
#
main()
# KS distance v.s. n  ------------------------------------------------------#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log(x > EPS ? x : EPS); }#
#
struct State {#
  int last, s00, s10, s01, s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const { return std::hash<long long>()(x); }#
};#
#
static inline long long encode_state(int last,int s00,int s10,int s01,int s11,int nmax){#
  long long SHIFT2 = 2LL;#
  long long SHIFT3 = SHIFT2*(nmax+1);#
  long long SHIFT4 = SHIFT3*(nmax+1);#
  long long SHIFT5 = SHIFT4*(nmax+1);#
  return (long long)last#
       + SHIFT2*(long long)s00#
       + SHIFT3*(long long)s10#
       + SHIFT4*(long long)s01#
       + SHIFT5*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha = 0.05){#
  State s0{0,0,0,0,0,1.0-alpha};#
  State s1{1,0,0,0,0,      alpha};#
  IntegerVector vl = {s0.last, s1.last};#
  IntegerVector vs00 = {s0.s00, s1.s00};#
  IntegerVector vs10 = {s0.s10, s1.s10};#
  IntegerVector vs01 = {s0.s01, s1.s01};#
  IntegerVector vs11 = {s0.s11, s1.s11};#
  NumericVector  vp   = {s0.prob, s1.prob};#
  return List::create(_["last"]=vl,_["s00"]=vs00,_["s10"]=vs10,_["s01"]=vs01,_["s11"]=vs11,_["prob"]=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_fastcpp(List curDist,double alpha=0.05,double prune_threshold=1e-15,int nmax=2000){#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<long long,State,LLHash> newMap;#
  newMap.reserve(last.size()*2);#
#
  for(int i=0;i<last.size();i++){#
    if(prob[i] < prune_threshold) continue;#
    State st{last[i], s00[i], s10[i], s01[i], s11[i], prob[i]};#
#
    State ns = st;                         // 观测 0#
    ns.last = 0;#
    if(st.last==0) ns.s00++; else ns.s10++;#
    ns.prob = st.prob*(1.0-alpha);#
    long long c0 = encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
    newMap[c0].last=ns.last; newMap[c0].s00=ns.s00; newMap[c0].s10=ns.s10;#
    newMap[c0].s01=ns.s01; newMap[c0].s11=ns.s11; newMap[c0].prob+=ns.prob;#
#
    ns = st;                               // 观测 1#
    ns.last = 1;#
    if(st.last==0) ns.s01++; else ns.s11++;#
    ns.prob = st.prob*alpha;#
    long long c1 = encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
    newMap[c1].last=ns.last; newMap[c1].s00=ns.s00; newMap[c1].s10=ns.s10;#
    newMap[c1].s01=ns.s01; newMap[c1].s11=ns.s11; newMap[c1].prob+=ns.prob;#
  }#
#
  int sz = newMap.size();#
  IntegerVector vl(sz), vs00(sz), vs10(sz), vs01(sz), vs11(sz);#
  NumericVector vp(sz);#
  int idx = 0;#
  for(auto &kv:newMap){#
    if(kv.second.prob < prune_threshold) continue;#
    vl[idx]=kv.second.last; vs00[idx]=kv.second.s00; vs10[idx]=kv.second.s10;#
    vs01[idx]=kv.second.s01; vs11[idx]=kv.second.s11; vp[idx]=kv.second.prob;#
    idx++;#
  }#
  vl.resize(idx); vs00.resize(idx); vs10.resize(idx); vs01.resize(idx); vs11.resize(idx); vp.resize(idx);#
  return List::create(_["last"]=vl,_["s00"]=vs00,_["s10"]=vs10,_["s01"]=vs01,_["s11"]=vs11,_["prob"]=vp);#
}#
#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List curDist,int t){#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<double,double> dmap;#
  dmap.reserve(last.size());#
#
  for(int i=0;i<last.size();i++){#
    if(prob[i]==0.0) continue;#
    int x00=s00[i], x10=s10[i], x01=s01[i], x11=s11[i];#
    int T0=x00+x10, T1=x01+x11;#
    double pHat = (t>1)? (double)T1/(t-1):0.0;#
    double num  = T0*safe_log(1.0-pHat) + T1*safe_log(pHat);#
    int sum01=x00+x01, sum11=x10+x11;#
    double pi01=(sum01>0)? (double)x01/sum01:1.0;#
    double pi11=(sum11>0)? (double)x11/sum11:1.0;#
    double den  = x00*safe_log(1.0-pi01) + x01*safe_log(pi01) +#
                  x10*safe_log(1.0-pi11) + x11*safe_log(pi11);#
    double LR   = -2.0*(num - den);#
    dmap[LR]   += prob[i];#
  }#
#
  std::vector<std::pair<double,double>> vec(dmap.begin(), dmap.end());#
  std::sort(vec.begin(), vec.end(), [](auto&a,auto&b){ return a.first<b.first; });#
  NumericVector LRv, Pv;#
  for(size_t i=0;i<vec.size();){#
    double cur=vec[i].first, p=0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-cur)<1e-15){ p+=vec[i].second; i++; }#
    LRv.push_back(cur); Pv.push_back(p);#
  }#
  return List::create(_["LR"]=LRv, _["prob"]=Pv);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  list(x = c(0, LRvals), y = c(0, cumsum(probvals)))#
}#
#
cdf_val <- function(x, xs, ys){#
  idx <- findInterval(x, xs, rightmost.closed = TRUE)#
  ys[pmax.int(idx, 1L)]#
}#
#
ks_diff <- function(LRvals, probvals, df = 1){#
  if(!length(LRvals)) return(0)#
  ord <- order(LRvals)#
  d <- cdf_xy(LRvals[ord], probvals[ord])#
  xmax <- tail(d$x, 1) + 1#
  xs <- seq(0, xmax, length.out = 800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
main <- function(){#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax <- 2000#
  nmin <- 1#
  step <- 1#
  plot(NULL, xlim = c(nmin, nmax), ylim = c(0,1),#
       xlab = "n", ylab = "KS distance", main = "KS distance vs n")#
  cols <- c("red","blue","green")#
  for(i in seq_along(alpha_list)){#
    a <- alpha_list[i]#
    dist_k <- initialize_dist_fastcpp(a)#
    nvals  <- seq(nmin, nmax, by = step)#
    ksvals <- numeric(length(nvals))#
    for(j in seq_along(nvals)){#
      t <- nvals[j]#
      lrres <- dist_at_current_fastcpp(dist_k, t)#
      ksvals[j] <- ks_diff(lrres$LR, lrres$prob, 1)#
      if(t < nmax) dist_k <- step_forward_fastcpp(dist_k, a, 1e-15, nmax)#
    }#
    lines(nvals, ksvals, col = cols[i], lwd = 2)#
  }#
  legend("topright", legend = paste0("alpha=", alpha_list),#
         col = cols, lty = 1, lwd = 2)#
}#
main()
# KS distance v.s. n#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
struct State {#
  int last;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_state(int last, int s00, int s10, int s01, int s11, int nmax){#
  long long SHIFT2 = 2LL;#
  long long SHIFT3 = SHIFT2*(nmax+1);#
  long long SHIFT4 = SHIFT3*(nmax+1);#
  long long SHIFT5 = SHIFT4*(nmax+1);#
  return (long long)last#
       + SHIFT2*(long long)s00#
       + SHIFT3*(long long)s10#
       + SHIFT4*(long long)s01#
       + SHIFT5*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05) {#
  State s0; s0.last=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0-alpha;#
  State s1; s1.last=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
  IntegerVector vl(2), vs00(2), vs10(2), vs01(2), vs11(2);#
  NumericVector vp(2);#
  vl[0]=s0.last; vs00[0]=s0.s00; vs10[0]=s0.s10; vs01[0]=s0.s01; vs11[0]=s0.s11; vp[0]=s0.prob;#
  vl[1]=s1.last; vs00[1]=s1.s00; vs10[1]=s1.s10; vs01[1]=s1.s01; vs11[1]=s1.s11; vp[1]=s1.prob;#
  return List::create(Named("last")=vl, Named("s00")=vs00, Named("s10")=vs10,#
                      Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_fastcpp(List curDist, double alpha=0.05, double prune_threshold=1e-15, int nmax=2000) {#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<long long, State, LLHash> newMap;#
  newMap.reserve(last.size()*2);#
  for(int i=0;i<last.size();i++){#
    double p=prob[i];#
    if(p<prune_threshold) continue;#
    State st; st.last=last[i]; st.s00=s00[i]; st.s10=s10[i]; st.s01=s01[i]; st.s11=s11[i]; st.prob=p;#
    {#
      State ns=st;#
      if(ns.last==0) ns.s00++; else ns.s10++;#
      ns.last=0; ns.prob=p*(1.0-alpha);#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=newMap.find(code);#
      if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
    }#
    {#
      State ns=st;#
      if(ns.last==0) ns.s01++; else ns.s11++;#
      ns.last=1; ns.prob=p*alpha;#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=newMap.find(code);#
      if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
    }#
  }#
  std::vector<State> vec; vec.reserve(newMap.size());#
  for(auto &kv:newMap){#
    if(kv.second.prob>=prune_threshold) vec.push_back(kv.second);#
  }#
  int sz=vec.size();#
  IntegerVector vl(sz), vs00(sz), vs10(sz), vs01(sz), vs11(sz);#
  NumericVector vp(sz);#
  for(int i=0;i<sz;i++){#
    vl[i]=vec[i].last; vs00[i]=vec[i].s00; vs10[i]=vec[i].s10;#
    vs01[i]=vec[i].s01; vs11[i]=vec[i].s11; vp[i]=vec[i].prob;#
  }#
  return List::create(Named("last")=vl, Named("s00")=vs00, Named("s10")=vs10,#
                      Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List curDist, int t) {#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<double,double> dmap;#
  dmap.reserve(last.size());#
  for(int i=0;i<last.size();i++){#
    double p=prob[i];#
    if(p<=0.0) continue;#
    int x00=s00[i], x10=s10[i], x01=s01[i], x11=s11[i];#
    int T0=x00+x10, T1=x01+x11;#
    double pHat=(t>1)?((double)T1/(double)(t-1)):0.0;#
    double num=0.0; #
    if(1.0-pHat>0.0) num += T0*std::log(1.0-pHat);#
    if(pHat>0.0)      num += T1*std::log(pHat);#
    int sum01=x00+x01; double pi01=(sum01>0)?((double)x01/sum01):1.0;#
    int sum11=x10+x11; double pi11=(sum11>0)?((double)x11/sum11):1.0;#
    double den=0.0;#
    if(1.0-pi01>0.0) den+=x00*std::log(1.0-pi01);#
    if(pi01>0.0)     den+=x01*std::log(pi01);#
    if(1.0-pi11>0.0) den+=x10*std::log(1.0-pi11);#
    if(pi11>0.0)     den+=x11*std::log(pi11);#
    double LR=-2.0*(num - den);#
    dmap[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vp; vp.reserve(dmap.size());#
  for(auto &kv:dmap) vp.push_back(std::make_pair(kv.first, kv.second));#
  std::sort(vp.begin(), vp.end(), [](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LRvals, probvals;#
  if(!vp.empty()){#
    double curLR=vp[0].first, curP=vp[0].second;#
    for(size_t i=1;i<vp.size();i++){#
      if(std::fabs(vp[i].first - curLR)<1e-15) curP+=vp[i].second;#
      else {#
        LRvals.push_back(curLR); probvals.push_back(curP);#
        curLR=vp[i].first; curP=vp[i].second;#
      }#
    }#
    LRvals.push_back(curLR); probvals.push_back(curP);#
  }#
  return List::create(Named("LR")=LRvals, Named("prob")=probvals);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  if(!length(LRvals)) return(list(x=numeric(0),y=numeric(0)))#
  cum <- cumsum(probvals)#
  if(LRvals[1]>=0) {#
    x <- c(0, LRvals)#
    y <- c(0, cum)#
  } else {#
    x <- LRvals#
    y <- cum#
  }#
  list(x=x,y=y)#
}#
#
cdf_val <- function(x, xs, ys){#
  if(!length(xs)) return(0)#
  if(x<=xs[1]) return(0)#
  if(x>=xs[length(xs)]) return(ys[length(xs)])#
  idx <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[idx]#
}#
#
ks_diff <- function(LRvals, probvals, df=1){#
  d <- cdf_xy(LRvals, probvals)#
  xs <- d$x; ys <- d$y#
  if(!length(xs)) return(0)#
  xmax <- xs[length(xs)] + 1#
  xsample <- seq(0, xmax, length.out=800)#
  supd <- 0#
  for(xv in xsample){#
    Ft <- cdf_val(xv, xs, ys)#
    Fc <- pchisq(xv, df)#
    dd <- abs(Ft - Fc)#
    if(dd>supd) supd<-dd#
  }#
  supd#
}#
#
main <- function(){#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax <- 2000#
  nmin <- 1#
  step <- 1#
  res_dict <- list()#
  plot(NULL, xlim=c(nmin,nmax), ylim=c(0,1), xlab="n", ylab="KS distance", main="KS distance vs n")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_dist_fastcpp(a)#
    nvals <- seq(nmin,nmax,by=step)#
    ksvals <- numeric(length(nvals))#
    for(ix in seq_along(nvals)){#
      t <- nvals[ix]#
      lrres <- dist_at_current_fastcpp(dist_k, t)#
      kd <- ks_diff(lrres$LR, lrres$prob, 1)#
      ksvals[ix] <- kd#
      if(t < nmax) dist_k <- step_forward_fastcpp(dist_k, a, 1e-15, nmax)#
    }#
    lines(nvals, ksvals, col=cols[i], lwd=2)#
    res_dict[[as.character(a)]] <- list(nvals=nvals, ksvals=ksvals)#
    i <- i+1#
  }#
  legend("topright", legend=paste0("alpha=",alpha_list), col=cols, lty=1, lwd=2)#
}#
#
main()
# KS distance v.s. n  ------------------------------------------------------#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log(x < EPS ? EPS : x); }#
#
struct State{#
  int last,s00,s10,s01,s11; double prob;#
};#
struct LLHash{ std::size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
#
static inline long long enc(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL, s3=s2*(n+1), s4=s3*(n+1), s5=s4*(n+1);#
  return l + s2*a + s3*b + s4*c + s5*d;#
}#
#
// initialize --------------------------------------------------------------#
[[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05){#
  State s0{0,0,0,0,0,1.0-alpha}, s1{1,0,0,0,0,alpha};#
  IntegerVector l={s0.last,s1.last}, a={s0.s00,s1.s00}, b={s0.s10,s1.s10},#
                c={s0.s01,s1.s01}, d={s0.s11,s1.s11};#
  NumericVector p={s0.prob,s1.prob};#
  return List::create(_["last"]=l,_["s00"]=a,_["s10"]=b,_["s01"]=c,_["s11"]=d,_["prob"]=p);#
}#
#
// one step -----------------------------------------------------------------#
[[Rcpp::export]]#
List step_forward_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<long long,State,LLHash> mp; mp.reserve(l.size()*2);#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    State s{l[i],a[i],b[i],c[i],d[i],p[i]};#
    State t=s; if(t.last==0) t.s00++; else t.s10++; t.last=0; t.prob*=1.0-alpha;#
    mp[enc(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob+=t.prob;#
    t=s; if(t.last==0) t.s01++; else t.s11++; t.last=1; t.prob*=alpha;#
    mp[enc(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob+=t.prob;#
  }#
  int m=mp.size();#
  IntegerVector L(m),A(m),B(m),C(m),D(m); NumericVector P(m);#
  int idx=0;#
  for(auto &kv:mp){#
    if(kv.second.prob<th) continue;#
    L[idx]=kv.second.last; A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;  D[idx]=kv.second.s11; P[idx]=kv.second.prob; idx++;#
  }#
  L.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
// distribution at time t ---------------------------------------------------#
[[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
  for(int i=0;i<l.size();i++){#
    if(p[i]==0.0) continue;#
    int x00=a[i],x10=b[i],x01=c[i],x11=d[i];#
    int T0=x00+x10, T1=x01+x11;#
    double ph=(t>1)?(double)T1/(t-1):0.0;#
    double num=T0*safe_log(1.0-ph)+T1*safe_log(ph);#
    int s01=x00+x01,s11=x10+x11;#
    double pi01=(s01>0)?(double)x01/s01:1.0, pi11=(s11>0)?(double)x11/s11:1.0;#
    double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)#
              +x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
    mp[-2.0*(num-den)]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0;#
    while(i<v.size()&&std::fabs(v[i].first-cur)<1e-15){sum+=v[i].second;i++;}#
    LR.push_back(cur);Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
cdf_xy  <- function(LR, pr) list(x = c(0, LR), y = c(0, cumsum(pr)))#
cdf_val <- function(x, xs, ys) ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
ks_diff <- function(LR, pr, df = 1){#
  if(!length(LR)) return(0)#
  d <- cdf_xy(LR[order(LR)], pr[order(LR)])#
  xs <- seq(0, tail(d$x,1)+1, length.out = 800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
main <- function(){#
  alpha <- c(0.01,0.025,0.05); cols <- c("red","blue","green")#
  nmax <- 2000; plot(NULL,xlim=c(1,nmax),ylim=c(0,1),xlab="n",ylab="KS distance",main="KS distance vs n")#
  for(i in seq_along(alpha)){#
    dist <- initialize_dist_fastcpp(alpha[i])#
    nvals <- 1:nmax; ks <- numeric(nmax)#
    for(t in nvals){#
      res <- dist_at_current_fastcpp(dist,t); ks[t] <- ks_diff(res$LR,res$prob,1)#
      if(t<nmax) dist <- step_forward_fastcpp(dist,alpha[i],1e-15,nmax)#
    }#
    lines(nvals,ks,col=cols[i],lwd=2)#
  }#
  legend("topright",legend=paste0("alpha=",alpha),col=cols,lty=1,lwd=2)#
}#
main()
# KS distance v.s. n  ------------------------------------------------------#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log(x < EPS ? EPS : x); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct LLHash{ std::size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
#
static inline long long ENC(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL, s3=s2*(n+1), s4=s3*(n+1), s5=s4*(n+1);#
  return l + s2*a + s3*b + s4*c + s5*d;#
}#
#
[[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05){#
  State s0{0,0,0,0,0,1.0-alpha}, s1{1,0,0,0,0,alpha};#
  return List::create(_["last"]={s0.last,s1.last},#
                      _["s00"] ={s0.s00,s1.s00},#
                      _["s10"] ={s0.s10,s1.s10},#
                      _["s01"] ={s0.s01,s1.s01},#
                      _["s11"] ={s0.s11,s1.s11},#
                      _["prob"]={s0.prob,s1.prob});#
}#
#
[[Rcpp::export]]#
List step_forward_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<long long,State,LLHash> mp;#
  mp.reserve(l.size()*2);#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    State st{l[i],a[i],b[i],c[i],d[i],p[i]};#
    State t=st; if(t.last==0) t.s00++; else t.s10++; t.last=0; t.prob*=1.0-alpha;#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob+=t.prob;#
    t=st; if(t.last==0) t.s01++; else t.s11++; t.last=1; t.prob*=alpha;#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob+=t.prob;#
  }#
  int m=mp.size();#
  IntegerVector L(m),A(m),B(m),C(m),D(m); NumericVector P(m);#
  int idx=0;#
  for(auto &kv:mp){#
    if(kv.second.prob<th) continue;#
    L[idx]=kv.second.last; A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;  D[idx]=kv.second.s11; P[idx]=kv.second.prob; idx++;#
  }#
  L.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
[[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
  for(int i=0;i<l.size();i++){#
    if(p[i]==0.0) continue;#
    int x00=a[i],x10=b[i],x01=c[i],x11=d[i];#
    int T0=x00+x10, T1=x01+x11;#
    double ph=(t>1)?(double)T1/(t-1):0.0;#
    double num=T0*safe_log(1.0-ph)+T1*safe_log(ph);#
    int s01=x00+x01,s11=x10+x11;#
    double pi01=(s01>0)?(double)x01/s01:1.0;#
    double pi11=(s11>0)?(double)x11/s11:1.0;#
    double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+#
               x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
    mp[-2.0*(num-den)]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0;#
    while(i<v.size()&&std::fabs(v[i].first-cur)<1e-15){sum+=v[i].second;i++;}#
    LR.push_back(cur);Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
cdf_xy  <- function(LR, pr){#
  o  <- order(LR)#
  x0 <- c(LR[o], 0)#
  y0 <- c(cumsum(pr[o]), 0)#
  o2 <- order(x0)#
  list(x = x0[o2], y = y0[o2])#
}#
cdf_val <- function(x, xs, ys) ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
ks_diff <- function(LR, pr, df = 1){#
  if(!length(LR)) return(0)#
  d  <- cdf_xy(LR, pr)#
  xs <- seq(0, tail(d$x,1)+1, length.out = 800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
main <- function(){#
  alpha <- c(0.01,0.025,0.05); cols <- c("red","blue","green")#
  nmax <- 2000; plot(NULL,xlim=c(1,nmax),ylim=c(0,1),xlab="n",ylab="KS distance",main="KS distance vs n")#
  for(i in seq_along(alpha)){#
    dist <- initialize_dist_fastcpp(alpha[i])#
    nvals <- 1:nmax; ks <- numeric(nmax)#
    for(t in nvals){#
      res <- dist_at_current_fastcpp(dist,t); ks[t] <- ks_diff(res$LR,res$prob,1)#
      if(t<nmax) dist <- step_forward_fastcpp(dist,alpha[i],1e-15,nmax)#
    }#
    lines(nvals,ks,col=cols[i],lwd=2)#
  }#
  legend("topright",legend=paste0("alpha=",alpha),col=cols,lty=1,lwd=2)#
}#
main()
# KS distance v.s. n#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
struct State {#
  int last;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_state(int last, int s00, int s10, int s01, int s11, int nmax){#
  long long SHIFT2 = 2LL;#
  long long SHIFT3 = SHIFT2*(nmax+1);#
  long long SHIFT4 = SHIFT3*(nmax+1);#
  long long SHIFT5 = SHIFT4*(nmax+1);#
  return (long long)last#
       + SHIFT2*(long long)s00#
       + SHIFT3*(long long)s10#
       + SHIFT4*(long long)s01#
       + SHIFT5*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05) {#
  State s0; s0.last=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0-alpha;#
  State s1; s1.last=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
  IntegerVector vl(2), vs00(2), vs10(2), vs01(2), vs11(2);#
  NumericVector vp(2);#
  vl[0]=s0.last; vs00[0]=s0.s00; vs10[0]=s0.s10; vs01[0]=s0.s01; vs11[0]=s0.s11; vp[0]=s0.prob;#
  vl[1]=s1.last; vs00[1]=s1.s00; vs10[1]=s1.s10; vs01[1]=s1.s01; vs11[1]=s1.s11; vp[1]=s1.prob;#
  return List::create(Named("last")=vl, Named("s00")=vs00, Named("s10")=vs10,#
                      Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_fastcpp(List curDist, double alpha=0.05, double prune_threshold=1e-15, int nmax=2000) {#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<long long, State, LLHash> newMap;#
  newMap.reserve(last.size()*2);#
  for(int i=0;i<last.size();i++){#
    double p=prob[i];#
    if(p<prune_threshold) continue;#
    State st; st.last=last[i]; st.s00=s00[i]; st.s10=s10[i]; st.s01=s01[i]; st.s11=s11[i]; st.prob=p;#
    {#
      State ns=st;#
      if(ns.last==0) ns.s00++; else ns.s10++;#
      ns.last=0; ns.prob=p*(1.0-alpha);#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=newMap.find(code);#
      if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
    }#
    {#
      State ns=st;#
      if(ns.last==0) ns.s01++; else ns.s11++;#
      ns.last=1; ns.prob=p*alpha;#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=newMap.find(code);#
      if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
    }#
  }#
  std::vector<State> vec; vec.reserve(newMap.size());#
  for(auto &kv:newMap){#
    if(kv.second.prob>=prune_threshold) vec.push_back(kv.second);#
  }#
  int sz=vec.size();#
  IntegerVector vl(sz), vs00(sz), vs10(sz), vs01(sz), vs11(sz);#
  NumericVector vp(sz);#
  for(int i=0;i<sz;i++){#
    vl[i]=vec[i].last; vs00[i]=vec[i].s00; vs10[i]=vec[i].s10;#
    vs01[i]=vec[i].s01; vs11[i]=vec[i].s11; vp[i]=vec[i].prob;#
  }#
  return List::create(Named("last")=vl, Named("s00")=vs00, Named("s10")=vs10,#
                      Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List curDist, int t) {#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<double,double> dmap;#
  dmap.reserve(last.size());#
  for(int i=0;i<last.size();i++){#
    double p=prob[i];#
    if(p<=0.0) continue;#
    int x00=s00[i], x10=s10[i], x01=s01[i], x11=s11[i];#
    int T0=x00+x10, T1=x01+x11;#
    double pHat=(t>1)?((double)T1/(double)(t-1)):0.0;#
    double num=0.0; #
    if(1.0-pHat>0.0) num += T0*std::log(1.0-pHat);#
    if(pHat>0.0)      num += T1*std::log(pHat);#
    int sum01=x00+x01; double pi01=(sum01>0)?((double)x01/sum01):1.0;#
    int sum11=x10+x11; double pi11=(sum11>0)?((double)x11/sum11):1.0;#
    double den=0.0;#
    if(1.0-pi01>0.0) den+=x00*std::log(1.0-pi01);#
    if(pi01>0.0)     den+=x01*std::log(pi01);#
    if(1.0-pi11>0.0) den+=x10*std::log(1.0-pi11);#
    if(pi11>0.0)     den+=x11*std::log(pi11);#
    double LR=-2.0*(num - den);#
    dmap[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vp; vp.reserve(dmap.size());#
  for(auto &kv:dmap) vp.push_back(std::make_pair(kv.first, kv.second));#
  std::sort(vp.begin(), vp.end(), [](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LRvals, probvals;#
  if(!vp.empty()){#
    double curLR=vp[0].first, curP=vp[0].second;#
    for(size_t i=1;i<vp.size();i++){#
      if(std::fabs(vp[i].first - curLR)<1e-15) curP+=vp[i].second;#
      else {#
        LRvals.push_back(curLR); probvals.push_back(curP);#
        curLR=vp[i].first; curP=vp[i].second;#
      }#
    }#
    LRvals.push_back(curLR); probvals.push_back(curP);#
  }#
  return List::create(Named("LR")=LRvals, Named("prob")=probvals);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  if(!length(LRvals)) return(list(x=numeric(0),y=numeric(0)))#
  cum <- cumsum(probvals)#
  if(LRvals[1]>=0) {#
    x <- c(0, LRvals)#
    y <- c(0, cum)#
  } else {#
    x <- LRvals#
    y <- cum#
  }#
  list(x=x,y=y)#
}#
#
cdf_val <- function(x, xs, ys){#
  if(!length(xs)) return(0)#
  if(x<=xs[1]) return(0)#
  if(x>=xs[length(xs)]) return(ys[length(xs)])#
  idx <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[idx]#
}#
#
ks_diff <- function(LRvals, probvals, df=1){#
  d <- cdf_xy(LRvals, probvals)#
  xs <- d$x; ys <- d$y#
  if(!length(xs)) return(0)#
  xmax <- xs[length(xs)] + 1#
  xsample <- seq(0, xmax, length.out=800)#
  supd <- 0#
  for(xv in xsample){#
    Ft <- cdf_val(xv, xs, ys)#
    Fc <- pchisq(xv, df)#
    dd <- abs(Ft - Fc)#
    if(dd>supd) supd<-dd#
  }#
  supd#
}#
#
main <- function(){#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax <- 2000#
  nmin <- 1#
  step <- 1#
  res_dict <- list()#
  plot(NULL, xlim=c(nmin,nmax), ylim=c(0,1), xlab="n", ylab="KS distance", main="KS distance vs n")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_dist_fastcpp(a)#
    nvals <- seq(nmin,nmax,by=step)#
    ksvals <- numeric(length(nvals))#
    for(ix in seq_along(nvals)){#
      t <- nvals[ix]#
      lrres <- dist_at_current_fastcpp(dist_k, t)#
      kd <- ks_diff(lrres$LR, lrres$prob, 1)#
      ksvals[ix] <- kd#
      if(t < nmax) dist_k <- step_forward_fastcpp(dist_k, a, 1e-15, nmax)#
    }#
    lines(nvals, ksvals, col=cols[i], lwd=2)#
    res_dict[[as.character(a)]] <- list(nvals=nvals, ksvals=ksvals)#
    i <- i+1#
  }#
  legend("topright", legend=paste0("alpha=",alpha_list), col=cols, lty=1, lwd=2)#
}#
#
main()
# Histogram of KS distance --------------------------------------------------#
#
library(Rcpp)#
#
forward_all_t <- function(nmax, alpha, prune_threshold = 1e-15) {#
  fw <- vector("list", nmax + 1L)#
  fw[[1]] <- initialize_dist_fastcpp(alpha)#
  for (t in 2L:(nmax + 1L))#
    fw[[t]] <- step_forward_fastcpp(fw[[t - 1L]], alpha, prune_threshold, nmax)#
  fw#
}#
#
LR_dist_from_forward <- function(fw, t) {#
  if (t <= 1L) return(list(LR = 0, prob = 1))#
  dist_at_current_fastcpp(fw[[t]], t)#
}#
#
cdf_val <- function(x, xs, ys) ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
#
cdf_diff <- function(LRvals, probvals, df = 1) {#
  o  <- order(LRvals)#
  xs <- c(0,  LRvals[o])#
  ys <- c(0, cumsum(probvals[o]))#
  testx <- seq(0, tail(xs, 1) + 1, length.out = 400)#
  max(abs(cdf_val(testx, xs, ys) - pchisq(testx, df)))#
}#
#
generate_data_points <- function() {#
  n_list    <- c(250, 500, 1000, 2000)#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax      <- 2000#
  res <- matrix(0, nrow = length(n_list) * length(alpha_list), ncol = 3L)#
  idx <- 1L#
  for (n_ in n_list) {#
    for (a_ in alpha_list) {#
      fw   <- forward_all_t(nmax, a_)#
      diff <- cdf_diff(LR_dist_from_forward(fw, n_)$LR,#
                       LR_dist_from_forward(fw, n_)$prob, 1)#
      res[idx, ] <- c(n_, a_, diff); idx <- idx + 1L#
    }#
  }#
  split(as.data.frame(res), seq_len(nrow(res)))#
}#
#
plot_grouped_bar <- function(results) {#
  vals <- do.call(rbind, results)#
  n_list     <- sort(unique(vals[, 1]))#
  alpha_list <- sort(unique(vals[, 2]))#
  m <- matrix(0, nrow = length(n_list), ncol = length(alpha_list))#
  for (i in seq_len(nrow(vals))) {#
    m[which(n_list == vals[i, 1]), which(alpha_list == vals[i, 2])] <- vals[i, 3]#
  }#
  colset <- c("blue", "orange", "green3")#
  barplot(t(m), beside = TRUE, names.arg = n_list, col = colset,#
          xlab = "n", ylab = "KS distance",#
          main = "Histogram of KS distance")#
  abline(h = c(0.05, 0.1), col = "red", lty = 2)#
  legend("topright", legend = paste0("alpha=", alpha_list),#
         fill = colset, bty = "n")#
}#
#
main <- function() {#
  results <- generate_data_points()#
  for (x in results)#
    cat(sprintf("n=%d, alpha=%.3f, KS=%.5f\n", x[1], x[2], x[3]))#
  plot_grouped_bar(results)#
}#
#
res <- main()
# Histogram of KS distance --------------------------------------------------#
#
library(Rcpp)#
#
forward_all_t <- function(nmax, alpha, prune_threshold = 1e-15) {#
  fw <- vector("list", nmax + 1L)#
  fw[[1]] <- initialize_dist_fastcpp(alpha)#
  for (t in 2L:(nmax + 1L))#
    fw[[t]] <- step_forward_fastcpp(fw[[t - 1L]], alpha, prune_threshold, nmax)#
  fw#
}#
#
LR_dist_from_forward <- function(fw, t) {#
  if (t <= 1L) return(list(LR = 0, prob = 1))#
  dist_at_current_fastcpp(fw[[t]], t)#
}#
#
cdf_val <- function(x, xs, ys) ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
#
cdf_diff <- function(LRvals, probvals, df = 1) {#
  o  <- order(LRvals)#
  xs <- c(0,  LRvals[o])#
  ys <- c(0, cumsum(probvals[o]))#
  testx <- seq(0, tail(xs, 1) + 1, length.out = 400)#
  max(abs(cdf_val(testx, xs, ys) - pchisq(testx, df)))#
}#
#
generate_data_points <- function() {#
  n_list     <- c(250, 500, 1000, 2000)#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax <- 2000#
  res <- matrix(0, nrow = length(n_list) * length(alpha_list), ncol = 3L)#
  idx <- 1L#
  for (n_ in n_list) {#
    for (a_ in alpha_list) {#
      fw   <- forward_all_t(nmax, a_)#
      diff <- cdf_diff(LR_dist_from_forward(fw, n_)$LR,#
                       LR_dist_from_forward(fw, n_)$prob, 1)#
      res[idx, ] <- c(n_, a_, diff); idx <- idx + 1L#
    }#
  }#
  res#
}#
#
plot_grouped_bar <- function(mat) {#
  n_list     <- sort(unique(mat[, 1]))#
  alpha_list <- sort(unique(mat[, 2]))#
  M <- matrix(0, nrow = length(n_list), ncol = length(alpha_list))#
  for (i in seq_len(nrow(mat))) {#
    M[which(n_list == mat[i, 1]), which(alpha_list == mat[i, 2])] <- mat[i, 3]#
  }#
  colset <- c("blue", "orange", "green3")#
  barplot(t(M), beside = TRUE, names.arg = n_list, col = colset,#
          xlab = "n", ylab = "KS distance",#
          main = "Histogram of KS distance")#
  abline(h = c(0.05, 0.1), col = "red", lty = 2)#
  legend("topright", legend = paste0("alpha=", alpha_list),#
         fill = colset, bty = "n")#
}#
#
main <- function() {#
  res <- generate_data_points()#
  for (i in seq_len(nrow(res)))#
    cat(sprintf("n=%d, alpha=%.3f, KS=%.5f\n", res[i, 1], res[i, 2], res[i, 3]))#
  plot_grouped_bar(res)#
}#
#
main()
# Heatmap: KS distance v.s. n & alpha#
#
library(Rcpp)#
#
heatmap_ks_no_fields <- function(alpha_seq = seq(0.01, 0.05, by=0.005), nmax = 2000, prune_threshold = 1e-15) {#
  t_start <- proc.time()[3]#
  ks_mat <- matrix(NA_real_, nrow = nmax, ncol = length(alpha_seq))#
  for (i in seq_along(alpha_seq)) {#
    a <- alpha_seq[i]#
    dist_k <- initialize_dist_fastcpp(a)#
    for (n in 1:nmax) {#
      lrres <- dist_at_current_fastcpp(dist_k, n)#
      ks_mat[n, i] <- ks_diff(lrres$LR, lrres$prob, 1)#
      if (n < nmax) {#
        dist_k <- step_forward_fastcpp(dist_k, a, prune_threshold, nmax)#
      }#
    }#
    elapsed <- proc.time()[3] - t_start#
    pct_done <- i / length(alpha_seq)#
    est_total <- elapsed / pct_done#
    est_left <- est_total - elapsed#
    cat(sprintf("alpha=%6.3f done. (%.1f%%). elapsed=%.2fs, est. time left=%.2fs\n",#
                a, 100*pct_done, elapsed, est_left))#
  }#
  ks_mat[ks_mat > 0.1] <- 0.1#
  ks_mat[is.na(ks_mat)] <- 0.1#
  xvals <- alpha_seq#
  yvals <- 1:nmax#
  col_fun <- colorRampPalette(c("blue","green","yellow","red"))(256)#
  zlim <- c(0, 0.1)#
  layout(matrix(c(1,2), nrow=1), widths=c(4,0.8))#
  par(mar=c(5,4,4,1))#
  image(xvals, yvals, t(ks_mat), col=col_fun, zlim=zlim, xlab="alpha", ylab="n", main="CDF difference (True vs Chi2)")#
  par(mar=c(5,1,4,3))#
  xx <- c(0,1)#
  yy <- seq(zlim[1], zlim[2], length.out=256)#
  zz <- matrix(rep(yy, each=length(xx)), nrow=length(xx), ncol=length(yy))#
  image(xx, yy, zz, col=col_fun, zlim=zlim, xlab="", ylab="", xaxt="n", yaxt="n")#
  axis(4, at=seq(zlim[1], zlim[2], by=0.02), las=1)#
  box()#
  invisible(ks_mat)#
}#
#
res_matrix_no_fields <- heatmap_ks_no_fields()
# Size distortion v.s. n ----------------------------------------------------#
#
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){ return std::log( x > 1e-15 ? x : 1e-15 ); }#
#
struct State {#
  int last,s00,s10,s01,s11;#
  double prob;#
};#
#
struct LLHash { std::size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode_state(int last,int s00,int s10,int s01,int s11,int nmax){#
  long long SHIFT2 = 2LL, SHIFT3 = SHIFT2*(nmax+1), SHIFT4 = SHIFT3*(nmax+1), SHIFT5 = SHIFT4*(nmax+1);#
  return (long long)last + SHIFT2*s00 + SHIFT3*s10 + SHIFT4*s01 + SHIFT5*s11;#
}#
#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05){#
  State s0{0,0,0,0,0,1.0-alpha}, s1{1,0,0,0,0,alpha};#
  IntegerVector vl{0,1}, vs00{0,0}, vs10{0,0}, vs01{0,0}, vs11{0,0};#
  NumericVector vp{1.0-alpha,alpha};#
  return List::create(_["last"]=vl,_["s00"]=vs00,_["s10"]=vs10,_["s01"]=vs01,_["s11"]=vs11,_["prob"]=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_fastcpp(List cur,double alpha=0.05,double pr=1e-15,int nmax=2000){#
  IntegerVector last=cur["last"],s00=cur["s00"],s10=cur["s10"],s01=cur["s01"],s11=cur["s11"]; NumericVector prob=cur["prob"];#
  std::unordered_map<long long,State,LLHash> mp; mp.reserve(last.size()*2);#
  for(int i=0;i<last.size();++i){#
    double p=prob[i]; if(p<pr) continue; State st{last[i],s00[i],s10[i],s01[i],s11[i],p};#
    {#
      State ns=st; if(ns.last==0) ns.s00++; else ns.s10++; ns.last=0; ns.prob=p*(1.0-alpha);#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      mp[code].prob+=ns.prob; mp[code].last=ns.last; mp[code].s00=ns.s00; mp[code].s10=ns.s10; mp[code].s01=ns.s01; mp[code].s11=ns.s11;#
    }#
    {#
      State ns=st; if(ns.last==0) ns.s01++; else ns.s11++; ns.last=1; ns.prob=p*alpha;#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      mp[code].prob+=ns.prob; mp[code].last=ns.last; mp[code].s00=ns.s00; mp[code].s10=ns.s10; mp[code].s01=ns.s01; mp[code].s11=ns.s11;#
    }#
  }#
  int sz=mp.size(); IntegerVector vl(sz),vs00(sz),vs10(sz),vs01(sz),vs11(sz); NumericVector vp(sz); int k=0;#
  for(auto &kv:mp){ if(kv.second.prob<pr) continue; vl[k]=kv.second.last; vs00[k]=kv.second.s00; vs10[k]=kv.second.s10;#
    vs01[k]=kv.second.s01; vs11[k]=kv.second.s11; vp[k]=kv.second.prob; ++k;}#
  vl.resize(k);vs00.resize(k);vs10.resize(k);vs01.resize(k);vs11.resize(k);vp.resize(k);#
  return List::create(_["last"]=vl,_["s00"]=vs00,_["s10"]=vs10,_["s01"]=vs01,_["s11"]=vs11,_["prob"]=vp);#
}#
#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector last=cur["last"],s00=cur["s00"],s10=cur["s10"],s01=cur["s01"],s11=cur["s11"]; NumericVector prob=cur["prob"];#
  std::unordered_map<double,double> dmp; dmp.reserve(last.size());#
  for(int i=0;i<last.size();++i){#
    double p=prob[i]; if(p<=0) continue; if(t<2){ dmp[0]+=p; continue;}#
    int x00=s00[i],x10=s10[i],x01=s01[i],x11=s11[i];#
    double T0=x00+x10,T1=x01+x11; double pHat=(double)T1/(t-1);#
    double num=T0*s_log(1.0-pHat)+T1*s_log(pHat);#
    int sum01=x00+x01,sum11=x10+x11; double pi01=(sum01? (double)x01/sum01:1.0), pi11=(sum11? (double)x11/sum11:1.0);#
    double den=x00*s_log(1.0-pi01)+x01*s_log(pi01)+x10*s_log(1.0-pi11)+x11*s_log(pi11);#
    dmp[-2.0*(num-den)]+=p;#
  }#
  std::vector<std::pair<double,double>> v; v.reserve(dmp.size()); for(auto &kv:dmp) v.push_back(kv);#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,PR; for(auto &kv:v){ LR.push_back(kv.first); PR.push_back(kv.second);}#
  return List::create(_["LR"]=LR,_["prob"]=PR);#
}#
')#
#
fwd_all_t_R <- function(nmax, alpha, pr=1e-15){#
  res <- vector("list", nmax+1L)#
  res[[1]] <- initialize_dist_fastcpp(alpha)#
  for(k in 1:(nmax-1L)) res[[k+1L]] <- step_forward_fastcpp(res[[k]], alpha, pr, nmax)#
  res#
}#
#
dist_at_t_R <- function(fw, t) dist_at_current_fastcpp(fw[[t]], t)#
#
cdf_val <- function(x,xs,ys) ys[pmax.int(findInterval(x,xs,TRUE),1L)]#
#
cdf_xy <- function(LR,pr){ o<-order(LR); list(x=c(0,LR[o]), y=c(0,cumsum(pr[o]))) }#
#
size_dist_val <- function(LR,pr,alpha_p=0.05){#
  c <- qchisq(1-alpha_p,1); d<-cdf_xy(LR,pr); 1 - cdf_val(c,d$x,d$y) - alpha_p#
}#
#
main_size_distortion <- function(){#
  alpha_list <- c(0.01,0.025,0.05); alpha_p <- 0.05; nmax <- 2000; step <- 10#
  cols <- c("red","blue","forestgreen")#
  plot(NA,xlim=c(1,nmax),ylim=c(-0.1,0.1),xlab="n",ylab="Size Distortion",#
       main=paste0("Size Distortion vs n (alpha'=",alpha_p,")")); abline(h=0,col="gray",lty=2)#
  for(j in seq_along(alpha_list)){#
    a<-alpha_list[j]; fw<-fwd_all_t_R(nmax,a); nvals<-seq(1,nmax,by=step)#
    sd<-sapply(nvals,function(t){d<-dist_at_t_R(fw,t); size_dist_val(d$LR,d$prob,alpha_p)})#
    lines(nvals,sd,col=cols[j],lwd=2); points(nvals,sd,col=cols[j],pch=19,cex=0.5)#
  }#
  legend("topright",legend=paste0("alpha=",alpha_list),col=cols,lty=1,lwd=2,pch=19,bty="n")#
}#
#
main_size_distortion()
# Size distortion v.s. n ----------------------------------------------------#
#
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){ return std::log( x > 1e-15 ? x : 1e-15 ); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct LLHash{ std::size_t operator()(long long x) const{ return std::hash<long long>()(x);} };#
#
static inline long long enc(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL,s3=s2*(n+1),s4=s3*(n+1),s5=s4*(n+1);#
  return (long long)l+s2*a+s3*b+s4*c+s5*d;#
}#
#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double a=0.05){#
  IntegerVector vl{0,1}, z(2,0); NumericVector vp{1-a,a};#
  return List::create(_["last"]=vl,_["s00"]=z,_["s10"]=z,_["s01"]=z,_["s11"]=z,_["prob"]=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_fastcpp(List cur,double a=0.05,double pr=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"],s00=cur["s00"],s10=cur["s10"],s01=cur["s01"],s11=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<long long,State,LLHash> mp; mp.reserve(l.size()*2);#
  for(int i=0;i<l.size();++i){#
    double w=p[i]; if(w<pr) continue; State st{l[i],s00[i],s10[i],s01[i],s11[i],w};#
    {State ns=st; (ns.last?ns.s10:ns.s00)++; ns.last=0; ns.prob=w*(1-a);#
     long long code=enc(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax); mp[code].prob+=ns.prob;#
     mp[code].last=ns.last; mp[code].s00=ns.s00; mp[code].s10=ns.s10; mp[code].s01=ns.s01; mp[code].s11=ns.s11;}#
    {State ns=st; (ns.last?ns.s11:ns.s01)++; ns.last=1; ns.prob=w*a;#
     long long code=enc(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax); mp[code].prob+=ns.prob;#
     mp[code].last=ns.last; mp[code].s00=ns.s00; mp[code].s10=ns.s10; mp[code].s01=ns.s01; mp[code].s11=ns.s11;}#
  }#
  int k=0,sz=mp.size(); IntegerVector vl(sz),v00(sz),v10(sz),v01(sz),v11(sz); NumericVector vp(sz);#
  for(auto &kv:mp){ if(kv.second.prob<pr) continue; vl[k]=kv.second.last; v00[k]=kv.second.s00; v10[k]=kv.second.s10;#
    v01[k]=kv.second.s01; v11[k]=kv.second.s11; vp[k]=kv.second.prob; ++k;}#
  vl.resize(k);v00.resize(k);v10.resize(k);v01.resize(k);v11.resize(k);vp.resize(k);#
  return List::create(_["last"]=vl,_["s00"]=v00,_["s10"]=v10,_["s01"]=v01,_["s11"]=v11,_["prob"]=vp);#
}#
#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector l=cur["last"],s00=cur["s00"],s10=cur["s10"],s01=cur["s01"],s11=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<double,double> d; d.reserve(l.size());#
  for(int i=0;i<l.size();++i){#
    double w=p[i]; if(w<=0) continue; if(t<2){ d[0]+=w; continue;}#
    int a=s00[i],b=s10[i],c=s01[i],d1=s11[i]; double T0=a+b,T1=c+d1,pH=T1/(t-1);#
    double num=T0*s_log(1-pH)+T1*s_log(pH);#
    int s01_=a+c,s11_=b+d1; double pi01=s01_? (double)c/s01_:1.0, pi11=s11_? (double)d1/s11_:1.0;#
    double den=a*s_log(1-pi01)+c*s_log(pi01)+b*s_log(1-pi11)+d1*s_log(pi11);#
    d[-2*(num-den)]+=w;#
  }#
  std::vector<std::pair<double,double>> v; for(auto &kv:d) v.push_back(kv);#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,PR; for(auto &kv:v){ LR.push_back(kv.first); PR.push_back(kv.second);}#
  return List::create(_["LR"]=LR,_["prob"]=PR);#
}#
')#
#
fwd_all_t_R <- function(nmax,a,pr=1e-15){#
  res<-vector("list",nmax+1L); res[[1]]<-initialize_dist_fastcpp(a)#
  for(k in 1:(nmax-1L)) res[[k+1L]]<-step_forward_fastcpp(res[[k]],a,pr,nmax); res#
}#
#
cdf_val <- function(x,xs,ys){ if(!length(xs)) return(0); ys[pmax.int(findInterval(x,xs,TRUE),1L)] }#
#
size_dist_val <- function(LR,pr,alp=0.05){#
  if(!length(LR)) return(0); o<-order(LR); xs<-c(0,LR[o]); ys<-c(0,cumsum(pr[o]))#
  1 - cdf_val(qchisq(1-alp,1),xs,ys) - alp#
}#
#
main_size_distortion <- function(){#
  alpha_list<-c(0.01,0.025,0.05); alp_p<-0.05; nmax<-2000; step<-10#
  cols<-c("red","blue","forestgreen"); plot(NA,xlim=c(1,nmax),ylim=c(-0.1,0.1),#
    xlab="n",ylab="Size Dist.",main=paste0("Size Distortion vs n (alpha'=",alp_p,")")); abline(h=0,col="grey",lty=2)#
  for(j in seq_along(alpha_list)){#
    a<-alpha_list[j]; fw<-fwd_all_t_R(nmax,a); nvals<-seq(1,nmax,by=step)#
    sd<-sapply(nvals,function(t){d<-dist_at_current_fastcpp(fw[[t]],t); size_dist_val(d$LR,d$prob,alp_p)})#
    lines(nvals,sd,col=cols[j],lwd=2); points(nvals,sd,col=cols[j],pch=19,cex=0.5)#
  }#
  legend("topright",legend=paste0("alpha=",alpha_list),col=cols,lty=1,lwd=2,pch=19,bty="n")#
}#
#
main_size_distortion()
# Size distortion v.s. alpha#
#
main_size_distortion_vs_alpha <- function() {#
  n_list <- c(250, 500, 1000)#
  alpha_p <- 0.05#
  alpha_array <- seq(0.01, 0.1, length.out=10)#
  results <- list()#
#
  for(n_ in n_list) {#
    sd_list <- numeric(length(alpha_array))#
    for(i in seq_along(alpha_array)) {#
      alpha_ <- alpha_array[i]#
      f_list <- fwd_all_t_R(n_, alpha_, prune_threshold=1e-15)#
      dist_res <- dist_at_t_R(f_list, n_)#
      sd_list[i] <- size_dist_val(dist_res$LR, dist_res$prob, alpha_p)#
    }#
    results[[as.character(n_)]] <- sd_list#
  }#
#
  plot(NA, NA, xlim = range(alpha_array), ylim = c(-0.1, 0.1),#
       xlab = "alpha", ylab = "Size Distortion",#
       main = paste0("Size Distortion vs alpha (alpha'=", alpha_p, ")"))#
  abline(h=0, col="gray", lty=2)#
  cols <- c("red","blue","forestgreen")#
  leg <- character(0)#
  i <- 1#
  for(n_ in n_list) {#
    lines(alpha_array, results[[as.character(n_)]], col=cols[i], lwd=2)#
    points(alpha_array, results[[as.character(n_)]], col=cols[i], pch=19, cex=0.5)#
    leg <- c(leg, paste0("n=", n_))#
    i <- i + 1#
  }#
  legend("topright", legend=leg, col=cols, lty=1, lwd=2, pch=19, bty="n")#
}#
#
main_size_distortion_vs_alpha()
# Size distortion v.s. n#
#
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
struct State {#
  int last;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_state(int last, int s00, int s10, int s01, int s11, int nmax){#
  long long SHIFT2 = 2LL;#
  long long SHIFT3 = SHIFT2*(nmax+1);#
  long long SHIFT4 = SHIFT3*(nmax+1);#
  long long SHIFT5 = SHIFT4*(nmax+1);#
  return (long long)last#
       + SHIFT2*(long long)s00#
       + SHIFT3*(long long)s10#
       + SHIFT4*(long long)s01#
       + SHIFT5*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05) {#
  State s0; s0.last=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0-alpha;#
  State s1; s1.last=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
  IntegerVector vl(2), vs00(2), vs10(2), vs01(2), vs11(2);#
  NumericVector vp(2);#
  vl[0]=s0.last; vs00[0]=s0.s00; vs10[0]=s0.s10; vs01[0]=s0.s01; vs11[0]=s0.s11; vp[0]=s0.prob;#
  vl[1]=s1.last; vs00[1]=s1.s00; vs10[1]=s1.s10; vs01[1]=s1.s01; vs11[1]=s1.s11; vp[1]=s1.prob;#
  return List::create(Named("last")=vl, Named("s00")=vs00, Named("s10")=vs10,#
                      Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_fastcpp(List curDist, double alpha=0.05, double prune_threshold=1e-15, int nmax=2000) {#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<long long, State, LLHash> newMap;#
  newMap.reserve(last.size()*2);#
  for(int i=0;i<last.size();i++){#
    double p=prob[i];#
    if(p<prune_threshold) continue;#
    State st; st.last=last[i]; st.s00=s00[i]; st.s10=s10[i]; st.s01=s01[i]; st.s11=s11[i]; st.prob=p;#
    {#
      State ns=st;#
      if(ns.last==0) ns.s00++; else ns.s10++;#
      ns.last=0; ns.prob=p*(1.0-alpha);#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=newMap.find(code);#
      if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
    }#
    {#
      State ns=st;#
      if(ns.last==0) ns.s01++; else ns.s11++;#
      ns.last=1; ns.prob=p*alpha;#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=newMap.find(code);#
      if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
    }#
  }#
  std::vector<State> vec; vec.reserve(newMap.size());#
  for(auto &kv:newMap){#
    if(kv.second.prob>=prune_threshold) vec.push_back(kv.second);#
  }#
  int sz=vec.size();#
  IntegerVector vl(sz), vs00(sz), vs10(sz), vs01(sz), vs11(sz);#
  NumericVector vp(sz);#
  for(int i=0;i<sz;i++){#
    vl[i]=vec[i].last; vs00[i]=vec[i].s00; vs10[i]=vec[i].s10;#
    vs01[i]=vec[i].s01; vs11[i]=vec[i].s11; vp[i]=vec[i].prob;#
  }#
  return List::create(Named("last")=vl, Named("s00")=vs00, Named("s10")=vs10,#
                      Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List curDist, int t) {#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<double,double> dmap;#
  dmap.reserve(last.size());#
  for(int i=0;i<last.size();i++){#
    double p=prob[i];#
    if(p<=0.0) continue;#
    int x00=s00[i], x10=s10[i], x01=s01[i], x11=s11[i];#
    if(t<2){#
      double LR=0.0;#
      dmap[LR]+=p;#
      continue;#
    }#
    double T0=x00+x10, T1=x01+x11;#
    double pHat=(double)T1/(double)(t-1);#
    double num=0.0;#
    if((1.0-pHat)>0.0) num += T0*std::log(1.0-pHat);#
    if(pHat>0.0)       num += T1*std::log(pHat);#
    int sum01=x00+x01;#
    double pi01= (sum01>0)? (double)x01/(double)sum01 : 1.0;#
    int sum11=x10+x11;#
    double pi11= (sum11>0)? (double)x11/(double)sum11 : 1.0;#
    double den=0.0;#
    if((1.0-pi01)>0.0) den += x00*std::log(1.0-pi01);#
    if(pi01>0.0)       den += x01*std::log(pi01);#
    if((1.0-pi11)>0.0) den += x10*std::log(1.0-pi11);#
    if(pi11>0.0)       den += x11*std::log(pi11);#
    double LR=-2.0*(num - den);#
    dmap[LR]+=p;#
  }#
  std::vector<double> LRvals, probvals;#
  LRvals.reserve(dmap.size());#
  probvals.reserve(dmap.size());#
  for(auto &kv : dmap){#
    LRvals.push_back(kv.first);#
    probvals.push_back(kv.second);#
  }#
  std::vector<int> idx(LRvals.size());#
  for(int i=0;i<(int)idx.size();i++) idx[i]=i;#
  std::sort(idx.begin(), idx.end(), [&](int a, int b){return LRvals[a]<LRvals[b];});#
  NumericVector LRout, Pout;#
  if(!idx.empty()){#
    double curLR=LRvals[idx[0]];#
    double curP=probvals[idx[0]];#
    for(size_t i=1;i<idx.size();i++){#
      double tmpLR=LRvals[idx[i]];#
      double tmpP=probvals[idx[i]];#
      if(std::fabs(tmpLR - curLR)<1e-15){#
        curP += tmpP;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR=tmpLR;#
        curP=tmpP;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fwd_all_t_R <- function(nmax, alpha, prune_threshold=1e-15) {#
  dist_t <- initialize_dist_fastcpp(alpha)#
  fwd_list <- vector("list", nmax+1)#
  fwd_list[[1]] <- dist_t#
  for (k in 1:(nmax - 1)) {#
    dist_t_next <- step_forward_fastcpp(dist_t, alpha, prune_threshold, nmax)#
    fwd_list[[k+1]] <- dist_t_next#
    dist_t <- dist_t_next#
  }#
  fwd_list#
}#
#
dist_at_t_R <- function(fwd_list, t) {#
  lrres <- dist_at_current_fastcpp(fwd_list[[t]], t)#
  list(LR = lrres$LR, prob = lrres$prob)#
}#
#
cdf_xy <- function(LRvals, probvals) {#
  ok <- !is.na(LRvals) & !is.na(probvals)#
  LRvals <- LRvals[ok]#
  probvals <- probvals[ok]#
  if(!length(LRvals)) return(list(x=numeric(0), y=numeric(0)))#
  o <- order(LRvals)#
  LRsorted <- LRvals[o]#
  p_sorted <- probvals[o]#
  cum_p <- cumsum(p_sorted)#
  list(x = LRsorted, y = cum_p)#
}#
#
cdf_val <- function(x, xs, ys) {#
  if(!length(xs)) return(0)#
  if(x <= xs[1]) return(0)#
  if(x >= xs[length(xs)]) return(ys[length(ys)])#
  i <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[i]#
}#
#
size_dist_val <- function(LRvals, probvals, alpha_p = 0.05) {#
  c_chi2 <- qchisq(1 - alpha_p, df=1)#
  tmp <- cdf_xy(LRvals, probvals)#
  pr_rej <- 1 - cdf_val(c_chi2, tmp$x, tmp$y)#
  pr_rej - alpha_p#
}#
#
main_size_distortion <- function() {#
  alpha_list <- c(0.01, 0.025, 0.05)#
  alpha_p <- 0.05#
  nmax <- 2000#
  nmin <- 1#
  step <- 10#
  res_dict <- list()#
  for(a_ in alpha_list) {#
    f_list <- fwd_all_t_R(nmax, a_, 1e-15)#
    nvals <- seq(nmin, nmax, by=step)#
    sdvals <- numeric(length(nvals))#
    for(i in seq_along(nvals)) {#
      t <- nvals[i]#
      dist_res <- dist_at_t_R(f_list, t)#
      sdvals[i] <- size_dist_val(dist_res$LR, dist_res$prob, alpha_p)#
    }#
    df_alpha <- data.frame(n = nvals, size_distortion = sdvals)#
    res_dict[[as.character(a_)]] <- df_alpha#
  }#
  plot(NA, NA, xlim = c(nmin, nmax), ylim = c(-0.1, 0.1),#
       xlab = "n", ylab = "Size Distortion",#
       main = paste0("Size Distortion vs n (alpha'=", alpha_p, ")"))#
  abline(h=0, col="gray", lty=2)#
  cols <- c("red","blue","forestgreen")#
  leg <- character(0)#
  for(j in seq_along(alpha_list)) {#
    a_ <- alpha_list[j]#
    dfp <- res_dict[[as.character(a_)]]#
    lines(dfp$n, dfp$size_distortion, col=cols[j], lwd=2)#
    points(dfp$n, dfp$size_distortion, col=cols[j], pch=19, cex=0.5)#
    leg <- c(leg, paste0("alpha=", a_))#
  }#
  legend("topright", legend=leg, col=cols, lty=1, lwd=2, pch=19, bty="n")#
}#
#
main_size_distortion()
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){ return std::log( x > 1e-15 ? x : 1e-15 ); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct LLHash{ std::size_t operator()(long long x) const{ return std::hash<long long>()(x);} };#
#
static inline long long enc(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL,s3=s2*(n+1),s4=s3*(n+1),s5=s4*(n+1);#
  return (long long)l+s2*a+s3*b+s4*c+s5*d;#
}#
#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double a=0.05){#
  IntegerVector vl{0,1}, z(2,0); NumericVector vp{1-a,a};#
  return List::create(_["last"]=vl,_["s00"]=z,_["s10"]=z,_["s01"]=z,_["s11"]=z,_["prob"]=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_fastcpp(List cur,double a=0.05,double pr=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"],s00=cur["s00"],s10=cur["s10"],s01=cur["s01"],s11=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<long long,State,LLHash> mp; mp.reserve(l.size()*2);#
  for(int i=0;i<l.size();++i){#
    double w=p[i]; if(w<pr) continue; State st{l[i],s00[i],s10[i],s01[i],s11[i],w};#
    {State ns=st; (ns.last?ns.s10:ns.s00)++; ns.last=0; ns.prob=w*(1-a);#
     long long code=enc(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax); mp[code].prob+=ns.prob;#
     mp[code].last=ns.last; mp[code].s00=ns.s00; mp[code].s10=ns.s10; mp[code].s01=ns.s01; mp[code].s11=ns.s11;}#
    {State ns=st; (ns.last?ns.s11:ns.s01)++; ns.last=1; ns.prob=w*a;#
     long long code=enc(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax); mp[code].prob+=ns.prob;#
     mp[code].last=ns.last; mp[code].s00=ns.s00; mp[code].s10=ns.s10; mp[code].s01=ns.s01; mp[code].s11=ns.s11;}#
  }#
  int k=0,sz=mp.size(); IntegerVector vl(sz),v00(sz),v10(sz),v01(sz),v11(sz); NumericVector vp(sz);#
  for(auto &kv:mp){ if(kv.second.prob<pr) continue; vl[k]=kv.second.last; v00[k]=kv.second.s00; v10[k]=kv.second.s10;#
    v01[k]=kv.second.s01; v11[k]=kv.second.s11; vp[k]=kv.second.prob; ++k;}#
  vl.resize(k);v00.resize(k);v10.resize(k);v01.resize(k);v11.resize(k);vp.resize(k);#
  return List::create(_["last"]=vl,_["s00"]=v00,_["s10"]=v10,_["s01"]=v01,_["s11"]=v11,_["prob"]=vp);#
}#
#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector l=cur["last"],s00=cur["s00"],s10=cur["s10"],s01=cur["s01"],s11=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<double,double> d; d.reserve(l.size());#
  for(int i=0;i<l.size();++i){#
    double w=p[i]; if(w<=0) continue; if(t<2){ d[0]+=w; continue;}#
    int a=s00[i],b=s10[i],c=s01[i],d1=s11[i]; double T0=a+b,T1=c+d1,pH=T1/(t-1);#
    double num=T0*s_log(1-pH)+T1*s_log(pH);#
    int s01_=a+c,s11_=b+d1; double pi01=s01_? (double)c/s01_:1.0, pi11=s11_? (double)d1/s11_:1.0;#
    double den=a*s_log(1-pi01)+c*s_log(pi01)+b*s_log(1-pi11)+d1*s_log(pi11);#
    d[-2*(num-den)]+=w;#
  }#
  std::vector<std::pair<double,double>> v; for(auto &kv:d) v.push_back(kv);#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,PR; for(auto &kv:v){ LR.push_back(kv.first); PR.push_back(kv.second);}#
  return List::create(_["LR"]=LR,_["prob"]=PR);#
}#
')#
#
fwd_all_t_R <- function(nmax,a,pr=1e-15){#
  res<-vector("list",nmax+1L); res[[1]]<-initialize_dist_fastcpp(a)#
  for(k in 1:(nmax-1L)) res[[k+1L]]<-step_forward_fastcpp(res[[k]],a,pr,nmax); res#
}#
#
cdf_val <- function(x,xs,ys){ if(!length(xs)) 0 else ys[pmax.int(findInterval(x,xs,TRUE),1L)] }#
#
size_dist_val <- function(LR,pr,alp=0.05){#
  keep <- is.finite(LR) & is.finite(pr) & pr>0#
  if(!any(keep)) return(0)#
  LR <- LR[keep]; pr <- pr[keep]; o <- order(LR)#
  xs <- c(0, LR[o]); ys <- c(0, cumsum(pr[o]))#
  1 - cdf_val(qchisq(1-alp,1), xs, ys) - alp#
}#
#
main_size_distortion <- function(){#
  alpha_list <- c(0.01,0.025,0.05); alp_p <- 0.05; nmax <- 2000; step <- 10#
  cols <- c("red","blue","forestgreen")#
  plot(NA,xlim=c(1,nmax),ylim=c(-0.1,0.1),xlab="n",ylab="Size Distortion",#
       main=paste0("Size Distortion vs n (alpha'=",alp_p,")")); abline(h=0,col="grey",lty=2)#
  for(j in seq_along(alpha_list)){#
    a  <- alpha_list[j]; fw <- fwd_all_t_R(nmax,a)#
    ns <- seq(1,nmax,by=step)#
    sd <- vapply(ns,function(t){ d<-dist_at_current_fastcpp(fw[[t]],t); size_dist_val(d$LR,d$prob,alp_p)},numeric(1))#
    lines(ns,sd,col=cols[j],lwd=2); points(ns,sd,col=cols[j],pch=19,cex=0.5)#
  }#
  legend("topright",legend=paste0("alpha=",alpha_list),col=cols,lty=1,lwd=2,pch=19,bty="n")#
}#
#
main_size_distortion()
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
static inline double s_log(double x){ return std::log(x > 1e-15 ? x : 1e-15); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct Hash{ std::size_t operator()(long long x)const{ return std::hash<long long>()(x);} };#
#
static inline long long enc(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL,s3=s2*(n+1),s4=s3*(n+1),s5=s4*(n+1);#
  return (long long)l+s2*a+s3*b+s4*c+s5*d;#
}#
#
List init_cpp(double a){#
  IntegerVector l{0,1},z(2,0); NumericVector p{1-a,a};#
  return List::create(_["last"]=l,_["s00"]=z,_["s10"]=z,_["s01"]=z,_["s11"]=z,_["prob"]=p);#
}#
#
List step_cpp(List cur,double a,double pr,int nmax){#
  IntegerVector l=cur["last"],a0=cur["s00"],b0=cur["s10"],c0=cur["s01"],d0=cur["s11"]; NumericVector w=cur["prob"];#
  std::unordered_map<long long,State,Hash> mp; mp.reserve(l.size()*2);#
  for(int i=0;i<l.size();++i){#
    double ww=w[i]; if(ww<pr) continue; State st{l[i],a0[i],b0[i],c0[i],d0[i],ww};#
    {State ns=st; (ns.last?ns.s10:ns.s00)++; ns.last=0; ns.prob=ww*(1-a);#
     long long code=enc(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax); mp[code].prob+=ns.prob;#
     mp[code]=ns;}#
    {State ns=st; (ns.last?ns.s11:ns.s01)++; ns.last=1; ns.prob=ww*a;#
     long long code=enc(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax); mp[code].prob+=ns.prob;#
     mp[code]=ns;}#
  }#
  int k=0,sz=mp.size(); IntegerVector L(sz),A(sz),B(sz),C(sz),D(sz); NumericVector P(sz);#
  for(auto &kv:mp){ if(kv.second.prob<pr) continue;#
    L[k]=kv.second.last; A[k]=kv.second.s00; B[k]=kv.second.s10; C[k]=kv.second.s01; D[k]=kv.second.s11; P[k]=kv.second.prob; ++k;}#
  L.resize(k);A.resize(k);B.resize(k);C.resize(k);D.resize(k);P.resize(k);#
  return List::create(_["last"]=L,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
List dist_cpp(List cur,int t){#
  IntegerVector l=cur["last"],a0=cur["s00"],b0=cur["s10"],c0=cur["s01"],d0=cur["s11"]; NumericVector w=cur["prob"];#
  std::unordered_map<double,double> d; d.reserve(l.size());#
  for(int i=0;i<l.size();++i){#
    double ww=w[i]; if(ww<=0) continue; if(t<2){ d[0]+=ww; continue;}#
    int a=a0[i],b=b0[i],c=c0[i],d1=d0[i]; double T0=a+b,T1=c+d1,pH=T1/(t-1);#
    double num=T0*s_log(1-pH)+T1*s_log(pH);#
    int s01_=a+c,s11_=b+d1; double pi01=s01_? (double)c/s01_:1.0,pi11=s11_? (double)d1/s11_:1.0;#
    double den=a*s_log(1-pi01)+c*s_log(pi01)+b*s_log(1-pi11)+d1*s_log(pi11);#
    d[-2*(num-den)]+=ww;#
  }#
  NumericVector LR,PR; for(auto &kv:d){ LR.push_back(kv.first); PR.push_back(kv.second);}#
  return List::create(_["LR"]=LR,_["prob"]=PR);#
}#
#
')#
#
initialize_dist_fastcpp <- function(a) init_cpp(a)#
step_forward_fastcpp   <- function(x,a,pr,nmax) step_cpp(x,a,pr,nmax)#
dist_at_current_fastcpp<- function(x,t) dist_cpp(x,t)#
#
fwd_all_t_R <- function(nmax,a,pr=1e-15){#
  res<-vector("list",nmax+1); res[[1]]<-initialize_dist_fastcpp(a)#
  for(k in 1:(nmax-1)) res[[k+1]]<-step_forward_fastcpp(res[[k]],a,pr,nmax); res#
}#
#
size_dist_val <- function(LR,pr,alp=0.05){#
  keep <- is.finite(LR)&is.finite(pr)&pr>0#
  if(!any(keep)) return(0)#
  sum(pr[keep & LR > qchisq(1-alp,1)]) - alp#
}#
#
main_size_distortion <- function(){#
  alpha_list <- c(0.01,0.025,0.05); alp_p <- 0.05; nmax <- 2000; step <- 10#
  cols <- c("red","blue","forestgreen")#
  plot(NA,xlim=c(1,nmax),ylim=c(-0.1,0.1),xlab="n",ylab="Size Distortion",#
       main=paste0("Size Distortion vs n (alpha'=",alp_p,")")); abline(h=0,col="grey",lty=2)#
  for(j in seq_along(alpha_list)){#
    a <- alpha_list[j]; fw <- fwd_all_t_R(nmax,a)#
    ns <- seq(1,nmax,by=step)#
    sd <- vapply(ns,function(t){d<-dist_at_current_fastcpp(fw[[t]],t); size_dist_val(d$LR,d$prob,alp_p)},numeric(1))#
    lines(ns,sd,col=cols[j],lwd=2); points(ns,sd,col=cols[j],pch=19,cex=0.5)#
  }#
  legend("topright",legend=paste0("alpha=",alpha_list),col=cols,lty=1,lwd=2,pch=19,bty="n")#
}#
#
main_size_distortion()
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
static inline double s_log(double x){ return std::log(x > 1e-15 ? x : 1e-15); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct Hash{ std::size_t operator()(long long x)const{ return std::hash<long long>()(x);} };#
#
static inline long long enc(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL,s3=s2*(n+1),s4=s3*(n+1),s5=s4*(n+1);#
  return (long long)l+s2*a+s3*b+s4*c+s5*d;#
}#
#
// [[Rcpp::export]]#
List init_cpp(double a){#
  IntegerVector l{0,1},z(2,0); NumericVector p{1-a,a};#
  return List::create(_["last"]=l,_["s00"]=z,_["s10"]=z,_["s01"]=z,_["s11"]=z,_["prob"]=p);#
}#
#
// [[Rcpp::export]]#
List step_cpp(List cur,double a,double pr,int nmax){#
  IntegerVector l=cur["last"],a0=cur["s00"],b0=cur["s10"],c0=cur["s01"],d0=cur["s11"]; NumericVector w=cur["prob"];#
  std::unordered_map<long long,State,Hash> mp; mp.reserve(l.size()*2);#
  for(int i=0;i<l.size();++i){#
    double ww=w[i]; if(ww<pr) continue; State st{l[i],a0[i],b0[i],c0[i],d0[i],ww};#
    {State ns=st; (ns.last?ns.s10:ns.s00)++; ns.last=0; ns.prob=ww*(1-a);#
     long long code=enc(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax); mp[code].prob+=ns.prob; mp[code]=ns;}#
    {State ns=st; (ns.last?ns.s11:ns.s01)++; ns.last=1; ns.prob=ww*a;#
     long long code=enc(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax); mp[code].prob+=ns.prob; mp[code]=ns;}#
  }#
  int k=0,sz=mp.size(); IntegerVector L(sz),A(sz),B(sz),C(sz),D(sz); NumericVector P(sz);#
  for(auto &kv:mp){ if(kv.second.prob<pr) continue;#
    L[k]=kv.second.last; A[k]=kv.second.s00; B[k]=kv.second.s10; C[k]=kv.second.s01; D[k]=kv.second.s11; P[k]=kv.second.prob; ++k;}#
  L.resize(k);A.resize(k);B.resize(k);C.resize(k);D.resize(k);P.resize(k);#
  return List::create(_["last"]=L,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
// [[Rcpp::export]]#
List dist_cpp(List cur,int t){#
  IntegerVector l=cur["last"],a0=cur["s00"],b0=cur["s10"],c0=cur["s01"],d0=cur["s11"]; NumericVector w=cur["prob"];#
  std::unordered_map<double,double> d; d.reserve(l.size());#
  for(int i=0;i<l.size();++i){#
    double ww=w[i]; if(ww<=0) continue;#
    if(t<2){ d[0]+=ww; continue; }#
    int a=a0[i],b=b0[i],c=c0[i],d1=d0[i];#
    double T0=a+b,T1=c+d1,pH=T1/(t-1);#
    double num=T0*s_log(1-pH)+T1*s_log(pH);#
    int s01_=a+c,s11_=b+d1;#
    double pi01=s01_? (double)c/s01_:1.0,pi11=s11_? (double)d1/s11_:1.0;#
    double den=a*s_log(1-pi01)+c*s_log(pi01)+b*s_log(1-pi11)+d1*s_log(pi11);#
    d[-2*(num-den)]+=ww;#
  }#
  NumericVector LR,PR; for(auto &kv:d){ LR.push_back(kv.first); PR.push_back(kv.second);}#
  return List::create(_["LR"]=LR,_["prob"]=PR);#
}#
')#
#
initialize_dist_fastcpp <- function(a) init_cpp(a)#
step_forward_fastcpp   <- function(x,a,pr,nmax) step_cpp(x,a,pr,nmax)#
dist_at_current_fastcpp<- function(x,t) dist_cpp(x,t)#
#
fwd_all_t_R <- function(nmax,a,pr=1e-15){#
  out <- vector("list", nmax+1); out[[1]] <- initialize_dist_fastcpp(a)#
  for(k in 1:(nmax-1)) out[[k+1]] <- step_forward_fastcpp(out[[k]], a, pr, nmax)#
  out#
}#
#
size_dist_val <- function(LR, pr, alpha_p = 0.05){#
  keep <- is.finite(LR) & is.finite(pr) & (pr > 0)#
  if(!any(keep)) return(0)#
  sum(pr[keep & LR > qchisq(1 - alpha_p, 1)]) - alpha_p#
}#
#
main_size_distortion <- function(){#
  alpha_list <- c(0.01, 0.025, 0.05)#
  alpha_p <- 0.05#
  nmax <- 2000#
  step <- 10#
  cols <- c("red", "blue", "forestgreen")#
  plot(NA, xlim = c(1, nmax), ylim = c(-0.1, 0.1),#
       xlab = "n", ylab = "Size Distortion",#
       main = paste0("Size Distortion vs n (alpha'=", alpha_p, ")"))#
  abline(h = 0, col = "grey", lty = 2)#
  for(j in seq_along(alpha_list)){#
    a <- alpha_list[j]#
    fw <- fwd_all_t_R(nmax, a)#
    nseq <- seq(1, nmax, by = step)#
    sd  <- vapply(nseq, function(t){#
      d <- dist_at_current_fastcpp(fw[[t]], t)#
      size_dist_val(d$LR, d$prob, alpha_p)#
    }, numeric(1))#
    lines(nseq, sd, col = cols[j], lwd = 2)#
    points(nseq, sd, col = cols[j], pch = 19, cex = 0.5)#
  }#
  legend("topright", legend = paste0("alpha=", alpha_list),#
         col = cols, lty = 1, lwd = 2, pch = 19, bty = "n")#
}#
#
main_size_distortion()
# LRind – P-value comparison (robust log handling)#
#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
#
      // transition to 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      // transition to 1#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
#
    double LR = 0.0;#
    if(n>1){#
      int  T0 = T00 + T10;#
      int  T1 = T01 + T11;#
      double ph  = static_cast<double>(T1) / (n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
#
      int s01 = T00 + T01;#
      int s11 = T10 + T11;#
      double pi01 = s01>0 ? static_cast<double>(T01)/s01 : 1.0;#
      double pi11 = s11>0 ? static_cast<double>(T11)/s11 : 1.0;#
#
      double den = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                 + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR) < 1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  T00 <- T01 <- T10 <- T11 <- 0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    if(X[i-1]==1 && X[i]==1) T11 <- T11 + 1#
  }#
  if(n==1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1 / (n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals <= LRobs])#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
                     data.frame(n=n_, alpha=alpha_,#
                                mean_abs_pval_diff=mean(abs_diff),#
                                prop_diff_in_decision=mean(diff_dec)))#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha)))+#
        geom_bar(stat="identity", position="dodge")+#
        labs(x="n", y="mean_abs_pval_diff", fill="alpha")+#
        theme_minimal()#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha)))+#
        geom_bar(stat="identity", position="dodge")+#
        labs(x="n", y="prop_diff_in_decision", fill="alpha")+#
        theme_minimal()#
p1 / p2#
results
# LRind: P-value comparison#
#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){ return x>0.0 ? std::log(x) : 0.0; }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10, S2=M, S3=S2*M, S4=S3*M, S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0; s0.la=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode5(0,0,0,0,0,NMAX);#
    curMap[c0]=s0;#
    State s1; s1.la=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode5(1,0,0,0,0,NMAX);#
    curMap[c1]=s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob; #
      if(p<prune_threshold) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*p0;#
        long long code=encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la=1; ns.prob=p*p1;#
        long long code=encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
    }#
    curMap.clear();#
    for(auto &kv:newMap) if(kv.second.prob>=prune_threshold) curMap[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob; #
    if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LRind=0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=(s01>0?((double)T01/s01):1.0);#
      double pi11=(s11>0?((double)T11/s11):1.0);#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)#
                 +T10*s_log(1-pi11)+T11*s_log(pi11);#
      LRind=-2*(num-den);#
    }#
    lrDist[LRind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  for(auto &kv:lrDist) vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15) curP+=vec[i].second;#
      else{ LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second; }#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n,alpha=0.05,prune_threshold=1e-15) fb_lrind_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRind <- function(X,alpha) {#
  n<-length(X)#
  T00<-0;T01<-0;T10<-0;T11<-0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  LRind<-0#
  if(n>1){#
    T0<-T00+T10#
    T1<-T01+T11#
    ph<-T1/(n-1)#
    num<-T0*safe_log(1-ph)+T1*safe_log(ph)#
    s01<-T00+T01#
    pi01<-if(s01>0) T01/s01 else 1#
    s11<-T10+T11#
    pi11<-if(s11>0) T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<--2*(num-den)#
  }#
  LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1 - sum(probvals[LRvals<=LRobs])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_,1,alpha_)#
      LRobs <- my_compute_LRind(X,alpha_)#
      pval_exact <- get_pval_exact(LRvals,probvals,LRobs)#
      pval_chi2 <- 1 - pchisq(LRobs,df=1)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_decision)#
    ))#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
p1 / p2#
results
# LRind – P-value comparison (robust log handling)#
#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
#
      // transition to 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      // transition to 1#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
#
    double LR = 0.0;#
    if(n>1){#
      int  T0 = T00 + T10;#
      int  T1 = T01 + T11;#
      double ph  = static_cast<double>(T1) / (n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
#
      int s01 = T00 + T01;#
      int s11 = T10 + T11;#
      double pi01 = s01>0 ? static_cast<double>(T01)/s01 : 1.0;#
      double pi11 = s11>0 ? static_cast<double>(T11)/s11 : 1.0;#
#
      double den = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                 + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR) < 1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  T00 <- T01 <- T10 <- T11 <- 0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    if(X[i-1]==1 && X[i]==1) T11 <- T11 + 1#
  }#
  if(n==1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1 / (n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals <= LRobs])#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
                     data.frame(n=n_, alpha=alpha_,#
                                mean_abs_pval_diff=mean(abs_diff),#
                                prop_diff_in_decision=mean(diff_dec)))#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha)))+#
        geom_bar(stat="identity", position="dodge")+#
        labs(x="n", y="mean_abs_pval_diff", fill="alpha")+#
        theme_minimal()#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha)))+#
        geom_bar(stat="identity", position="dodge")+#
        labs(x="n", y="prop_diff_in_decision", fill="alpha")+#
        theme_minimal()#
p1 / p2#
results#
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names=1)#
exception_df <- data#
alpha_list2  <- c(0.05,0.025,0.01)#
names(exception_df) <- as.character(alpha_list2)#
#
set.seed(123)#
n_list2 <- c(50,100,150,200,250,300,500)#
K <- 2000#
N <- nrow(exception_df)#
results2 <- data.frame()#
#
for(alpha in alpha_list2){#
  X_all <- exception_df[[as.character(alpha)]]#
  for(n in n_list2){#
    dist_full <- fb_lrind(n, alpha, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(K)#
    diff_dec <- numeric(K)#
    max_start <- N - n + 1#
    for(i in seq_len(K)){#
      st <- sample.int(max_start, 1)#
      seg <- X_all[st:(st+n-1)]#
      LRobs <- my_compute_LRind(seg, alpha)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results2 <- rbind(results2,#
                      data.frame(n=n, alpha=alpha,#
                                 mean_abs_pval_diff=mean(abs_diff),#
                                 prop_diff_in_decision=mean(diff_dec)))#
  }#
}#
#
results_plot2 <- subset(results2, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p3 <- ggplot(results_plot2, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha)))+#
        geom_bar(stat="identity", position="dodge")+#
        labs(x="n", y="mean_abs_pval_diff", fill="alpha")+#
        theme_minimal()#
p4 <- ggplot(results_plot2, aes(factor(n), prop_diff_in_decision, fill=factor(alpha)))+#
        geom_bar(stat="identity", position="dodge")+#
        labs(x="n", y="prop_diff_in_decision", fill="alpha")+#
        theme_minimal()#
p3 / p4#
results2
# LRind: P-value comparison#
#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
safe_log <- function(x) if(x>0) log(x) else 0#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
static inline double s_log(double x){ return x>0.0 ? std::log(x) : 0.0; }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10, S2=M, S3=S2*M, S4=S3*M, S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0; s0.la=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode5(0,0,0,0,0,NMAX);#
    curMap[c0]=s0;#
    State s1; s1.la=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode5(1,0,0,0,0,NMAX);#
    curMap[c1]=s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p=kv.second.prob; #
      if(p<prune_threshold) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      double p0=1.0-alpha,p1=alpha;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*p0;#
        long long code=encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la=1; ns.prob=p*p1;#
        long long code=encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(code);#
        if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
      }#
    }#
    curMap.clear();#
    for(auto &kv:newMap) if(kv.second.prob>=prune_threshold) curMap[kv.first]=kv.second;#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p=kv.second.prob; #
    if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LRind=0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double ph=(double)T1/(n-1);#
      double num=T0*s_log(1-ph)+T1*s_log(ph);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=(s01>0?((double)T01/s01):1.0);#
      double pi11=(s11>0?((double)T11/s11):1.0);#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)#
                 +T10*s_log(1-pi11)+T11*s_log(pi11);#
      LRind=-2*(num-den);#
    }#
    lrDist[LRind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  for(auto &kv:lrDist) vec.emplace_back(kv.first,kv.second);#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  if(!vec.empty()){#
    double curLR=vec[0].first,curP=vec[0].second;#
    for(size_t i=1;i<vec.size();i++){#
      if(std::fabs(vec[i].first-curLR)<1e-15) curP+=vec[i].second;#
      else{ LRout.push_back(curLR);Pout.push_back(curP);curLR=vec[i].first;curP=vec[i].second; }#
    }#
    LRout.push_back(curLR);Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n,alpha=0.05,prune_threshold=1e-15) fb_lrind_fastcpp(n,alpha,prune_threshold)#
#
my_compute_LRind <- function(X,alpha) {#
  n<-length(X)#
  T00<-0;T01<-0;T10<-0;T11<-0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1#
    if(X[i-1]==1&&X[i]==1) T11<-T11+1#
  }#
  LRind<-0#
  if(n>1){#
    T0<-T00+T10#
    T1<-T01+T11#
    ph<-T1/(n-1)#
    num<-T0*safe_log(1-ph)+T1*safe_log(ph)#
    s01<-T00+T01#
    pi01<-if(s01>0) T01/s01 else 1#
    s11<-T10+T11#
    pi11<-if(s11>0) T11/s11 else 1#
    den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
    LRind<--2*(num-den)#
  }#
  LRind#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1 - sum(probvals[LRvals<=LRobs])#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list) {#
  for(alpha_ in alpha_list) {#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(Nrep)#
    diff_decision <- numeric(Nrep)#
    for(i in seq_len(Nrep)) {#
      X <- rbinom(n_,1,alpha_)#
      LRobs <- my_compute_LRind(X,alpha_)#
      pval_exact <- get_pval_exact(LRvals,probvals,LRobs)#
      pval_chi2 <- 1 - pchisq(LRobs,df=1)#
      abs_diff[i] <- abs(pval_exact - pval_chi2)#
      diff_decision[i] <- as.numeric((pval_exact < 0.05) != (pval_chi2 < 0.05))#
    }#
    results <- rbind(results,data.frame(#
      n=n_,#
      alpha=alpha_,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_decision)#
    ))#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
p1 / p2#
results#
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv",row.names=1)#
exception_df <- data#
alpha_list <- c(0.05,0.025,0.01)#
names(exception_df) <- as.character(alpha_list)#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
K <- 2000#
N <- nrow(exception_df)#
results <- data.frame()#
#
for(alpha in alpha_list){#
  X <- exception_df[[as.character(alpha)]]#
  for(n in n_list){#
    dist_full <- fb_lrind(n,alpha,1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(K)#
    diff_dec <- numeric(K)#
    max_start <- N - n + 1#
    for(i in seq_len(K)){#
      st <- sample.int(max_start,1)#
      seg <- X[st:(st+n-1)]#
      LRobs <- my_compute_LRind(seg,alpha)#
      p_exact <- get_pval_exact(LRvals,probvals,LRobs)#
      p_chi2 <- 1 - pchisq(LRobs,df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.numeric((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,data.frame(#
      n=n,#
      alpha=alpha,#
      mean_abs_pval_diff=mean(abs_diff),#
      prop_diff_in_decision=mean(diff_dec)#
    ))#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(x=factor(n), y=mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
p2 <- ggplot(results_plot, aes(x=factor(n), y=prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
p1 / p2#
results
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) sum(probvals[LRvals >= LRobs])#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals < LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
# LRind – P-value comparison (robust log handling)#
#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
#
      // transition to 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      // transition to 1#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
#
    double LR = 0.0;#
    if(n>1){#
      int  T0 = T00 + T10;#
      int  T1 = T01 + T11;#
      double ph  = static_cast<double>(T1) / (n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
#
      int s01 = T00 + T01;#
      int s11 = T10 + T11;#
      double pi01 = s01>0 ? static_cast<double>(T01)/s01 : 1.0;#
      double pi11 = s11>0 ? static_cast<double>(T11)/s11 : 1.0;#
#
      double den = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                 + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR) < 1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  T00 <- T01 <- T10 <- T11 <- 0#
  if(n>1) for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    if(X[i-1]==1 && X[i]==1) T11 <- T11 + 1#
  }#
  if(n==1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1 / (n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals <= LRobs])#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
                     data.frame(n=n_, alpha=alpha_,#
                                mean_abs_pval_diff=mean(abs_diff),#
                                prop_diff_in_decision=mean(diff_dec)))#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha)))+#
        geom_bar(stat="identity", position="dodge")+#
        labs(x="n", y="mean_abs_pval_diff", fill="alpha")+#
        theme_minimal()#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha)))+#
        geom_bar(stat="identity", position="dodge")+#
        labs(x="n", y="prop_diff_in_decision", fill="alpha")+#
        theme_minimal()#
p1 / p2#
results
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals < LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals < LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,200,300,500,600,700,800,900,1000)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals < LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results#
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names=1)#
exception_df <- data#
alpha_list2  <- c(0.05,0.025,0.01)#
names(exception_df) <- as.character(alpha_list2)#
#
set.seed(123)#
n_list2 <- c(50,100,150,200,250,300,500,750,1000,1250,1500,1750,2000)#
K <- 2000#
N <- nrow(exception_df)#
results2 <- data.frame()#
#
for(alpha in alpha_list2){#
  X_all <- exception_df[[as.character(alpha)]]#
  for(n in n_list2){#
    dist_full <- fb_lrind(n, alpha, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(K)#
    diff_dec <- numeric(K)#
    max_start <- N - n + 1#
    for(i in seq_len(K)){#
      st <- sample.int(max_start, 1)#
      seg <- X_all[st:(st+n-1)]#
      LRobs <- my_compute_LRind(seg, alpha)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results2 <- rbind(results2,#
      data.frame(#
        n=n,#
        alpha=alpha,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(K),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/K)#
      )#
    )#
  }#
}#
#
results_plot2 <- subset(results2, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p3 <- ggplot(results_plot2, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p4 <- ggplot(results_plot2, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p3 / p4#
results2
library(Rcpp)#
#
library(stats)#
#
library(ggplot2)#
#
library(patchwork)#
EPS <- 1e-15#
#
safe_log <- function(x) log(pmax(x, EPS))#
cppFunction('#
#
#include <Rcpp.h>#
#
#include <unordered_map>#
#
#include <vector>#
#
#include <cmath>#
#
#include <algorithm>#
#
using namespace Rcpp;#
const double EPS = 1e-15;#
#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
struct State { int la,T00,T10,T01,T11; double prob; };#
#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
#
  long long M = NMAX + 10LL;#
#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
#
}#
// [[Rcpp::export]]#
#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
#
  int NMAX = n + 5;#
#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  {#
#
    State s0{0,0,0,0,0,1.0-alpha};#
#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
#
    State s1{1,0,0,0,0,alpha};#
#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
#
  }#
#
  for(int k=1;k<n;k++){#
#
    std::unordered_map<long long,State,LLHash> newMap;#
#
    newMap.reserve(curMap.size()*2);#
#
    for(auto &kv:curMap){#
#
      double p = kv.second.prob;#
#
      if(p < prune_threshold) continue;#
#
      int la  = kv.second.la;#
#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
#
      {#
#
        State ns = kv.second;#
#
        if(la==0) ns.T00++; else ns.T10++;#
#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
#
      }#
#
      {#
#
        State ns = kv.second;#
#
        if(la==0) ns.T01++; else ns.T11++;#
#
        ns.la = 1;  ns.prob = p * alpha;#
#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
#
      }#
#
    }#
#
    curMap.swap(newMap);#
#
  }#
#
  std::unordered_map<double,double> lrDist;#
#
  for(auto &kv:curMap){#
#
    double p = kv.second.prob;#
#
    if(p<=0) continue;#
#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
#
    double LR = 0.0;#
#
    if(n>1){#
#
      int T0 = T00 + T10, T1 = T01 + T11;#
#
      double ph  = (double)T1/(n-1);#
#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
#
      int s01 = T00 + T01, s11 = T10 + T11;#
#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
#
      LR = -2.0*(num - den);#
#
    }#
#
    lrDist[LR] += p;#
#
  }#
#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
#
  NumericVector LRout, Pout;#
#
  for(size_t i=0;i<vec.size();){#
#
    double curLR = vec[i].first, curP = 0.0;#
#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
#
    LRout.push_back(curLR); Pout.push_back(curP);#
#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
#
}#
#
')#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
my_compute_LRind <- function(X, alpha) {#
#
  n <- length(X)#
#
  if(n<2) return(0)#
#
  T00 <- T01 <- T10 <- T11 <- 0#
#
  for(i in 2:n){#
#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
#
    else T11 <- T11 + 1#
#
  }#
#
  T0 <- T00 + T10#
#
  T1 <- T01 + T11#
#
  ph <- T1/(n-1)#
#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
#
  s01 <- T00 + T01#
#
  pi01 <- if(s01>0) T01/s01 else 1#
#
  s11 <- T10 + T11#
#
  pi11 <- if(s11>0) T11/s11 else 1#
#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
#
  -2*(num - den)#
#
}#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
#
  1 - sum(probvals[LRvals < LRobs])#
#
}#
set.seed(123)#
#
n_list     <- c(50,100,150,200,250,300,500,750,1000,1250,1500,1750,2000)#
#
alpha_list <- c(0.01,0.025,0.05)#
#
Nrep <- 2000#
#
results <- data.frame()#
for(n_ in n_list){#
#
  for(alpha_ in alpha_list){#
#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
#
    LRvals    <- dist_full$LR#
#
    probvals  <- dist_full$prob#
#
    abs_diff  <- numeric(Nrep)#
#
    diff_dec  <- numeric(Nrep)#
#
    for(i in seq_len(Nrep)){#
#
      X <- rbinom(n_, 1, alpha_)#
#
      LRobs <- my_compute_LRind(X, alpha_)#
#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
#
      abs_diff[i] <- abs(p_exact - p_chi2)#
#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
#
    }#
#
    results <- rbind(results,#
#
      data.frame(#
#
        n=n_,#
#
        alpha=alpha_,#
#
        mean_abs_pval_diff=mean(abs_diff),#
#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
#
        prop_diff_in_decision=mean(diff_dec),#
#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
#
      )#
#
    )#
#
  }#
#
}#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
#
  geom_bar(stat="identity", position="dodge") +#
#
  geom_errorbar(#
#
    aes(#
#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
#
    ),#
#
    width=0.2, position=position_dodge(width=0.9)#
#
  ) +#
#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
#
  theme_minimal()#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
#
  geom_bar(stat="identity", position="dodge") +#
#
  geom_errorbar(#
#
    aes(#
#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
#
    ),#
#
    width=0.2, position=position_dodge(width=0.9)#
#
  ) +#
#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
#
  theme_minimal()#
p1 / p2#
#
results
You said:#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals <= LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500,750,1000,1250,1500,1750,2000)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
dist <- fb_lrind(250, 0.05)#
sum(dist$prob)           # ≈ 1 ± 1e-12 ?#
max(abs(cumsum(dist$prob) - (1 - rev(cumsum(rev(dist$prob))))))  # ≤ 1e-13 ?
prob <- dist$prob#
#
# ❶ 正向累加与反向累加（同一索引）之差#
fwd <- cumsum(prob)#
bwd <- rev(cumsum(rev(prob)))#
max(abs(fwd + bwd - 1 - prob))          # 应该 ~ 1e-15#
#
# ❷ 前一位置的正向累加与当前位置的反向累加之和#
max(abs(fwd[-length(prob)] + bwd[-1] - 1))  # 也应 ~ 1e-15
format(sum(prob), digits = 17)          # 应显示 0.99999999999999989 之类
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
library(dplyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
Rcpp::List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return Rcpp::List::create(Rcpp::Named("LR")=Rcpp::NumericVector(0),Rcpp::Named("prob")=Rcpp::NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  Rcpp::NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return Rcpp::List::create(Rcpp::Named("LR")=LRout, Rcpp::Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals <= LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_chi2_only  <- numeric(Nrep)#
    diff_exact_only <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_chi2_only[i]  <- as.integer((p_chi2 < 0.05) & (p_exact >= 0.05))#
      diff_exact_only[i] <- as.integer((p_exact < 0.05) & (p_chi2 >= 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_chi2_rej_only=mean(diff_chi2_only),#
        se_chi2_rej_only=sqrt(mean(diff_chi2_only)*(1-mean(diff_chi2_only))/Nrep),#
        prop_exact_rej_only=mean(diff_exact_only),#
        se_exact_rej_only=sqrt(mean(diff_exact_only)*(1-mean(diff_exact_only))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
results_long <- results %>%#
  pivot_longer(cols=c(prop_chi2_rej_only, prop_exact_rej_only,#
                      se_chi2_rej_only, se_exact_rej_only),#
               names_to=c(".value","direction"),#
               names_pattern="(prop|se)_(chi2_rej_only|exact_rej_only)")#
#
p2 <- ggplot(results_long, aes(factor(n), prop, fill=direction)) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop - 1.96*se, 0),#
      ymax = pmin(prop + 1.96*se, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_direction", fill="direction") +#
  theme_minimal()#
#
p1 / p2#
results
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals <= LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
data <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names=1)#
exception_df <- data#
alpha_list2  <- c(0.05,0.025,0.01)#
names(exception_df) <- as.character(alpha_list2)#
#
set.seed(123)#
n_list2 <- c(50,100,150,200,250,300,500)#
K <- 2000#
N <- nrow(exception_df)#
results2 <- data.frame()#
#
for(alpha in alpha_list2){#
  X_all <- exception_df[[as.character(alpha)]]#
  for(n in n_list2){#
    dist_full <- fb_lrind(n, alpha, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(K)#
    diff_dec <- numeric(K)#
    max_start <- N - n + 1#
    for(i in seq_len(K)){#
      st <- sample.int(max_start, 1)#
      seg <- X_all[st:(st+n-1)]#
      LRobs <- my_compute_LRind(seg, alpha)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results2 <- rbind(results2,#
      data.frame(#
        n=n,#
        alpha=alpha,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(K),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/K)#
      )#
    )#
  }#
}#
#
results_plot2 <- subset(results2, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p3 <- ggplot(results_plot2, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p4 <- ggplot(results_plot2, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p3 / p4#
results2
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals <= LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
# On real exceedance 0/1 series: #
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names=1)#
exception_df <- data#
alpha_list2  <- c(0.05,0.025,0.01)#
names(exception_df) <- as.character(alpha_list2)#
#
set.seed(123)#
n_list2 <- c(50,100,150,200,250,300,500)#
K <- 2000#
N <- nrow(exception_df)#
results2 <- data.frame()#
#
for(alpha in alpha_list2){#
  X_all <- exception_df[[as.character(alpha)]]#
  for(n in n_list2){#
    dist_full <- fb_lrind(n, alpha, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(K)#
    diff_dec <- numeric(K)#
    max_start <- N - n + 1#
    for(i in seq_len(K)){#
      st <- sample.int(max_start, 1)#
      seg <- X_all[st:(st+n-1)]#
      LRobs <- my_compute_LRind(seg, alpha)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results2 <- rbind(results2,#
      data.frame(#
        n=n,#
        alpha=alpha,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(K),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/K)#
      )#
    )#
  }#
}#
#
results_plot2 <- subset(results2, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p3 <- ggplot(results_plot2, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p4 <- ggplot(results_plot2, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p3 / p4#
results2
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals < LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
# On real exceedance 0/1 series: #
#
data <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names=1)#
exception_df <- data#
alpha_list2  <- c(0.05,0.025,0.01)#
names(exception_df) <- as.character(alpha_list2)#
#
set.seed(123)#
n_list2 <- c(50,100,150,200,250,300,500)#
K <- 2000#
N <- nrow(exception_df)#
results2 <- data.frame()#
#
for(alpha in alpha_list2){#
  X_all <- exception_df[[as.character(alpha)]]#
  for(n in n_list2){#
    dist_full <- fb_lrind(n, alpha, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    abs_diff <- numeric(K)#
    diff_dec <- numeric(K)#
    max_start <- N - n + 1#
    for(i in seq_len(K)){#
      st <- sample.int(max_start, 1)#
      seg <- X_all[st:(st+n-1)]#
      LRobs <- my_compute_LRind(seg, alpha)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results2 <- rbind(results2,#
      data.frame(#
        n=n,#
        alpha=alpha,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(K),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/K)#
      )#
    )#
  }#
}#
#
results_plot2 <- subset(results2, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p3 <- ggplot(results_plot2, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p4 <- ggplot(results_plot2, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p3 / p4#
results2
# On Bernoulli simulated data: #
#
## mean_abs_pval_diff: This is the average absolute difference between the exact p-value and the chi-square-based p-value across all simulations.#
#
## prop_diff_in_decision: This is the proportion of simulated samples for which the exact method and the chi-square method give different reject/not-reject decisions at 5% significance.#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals < LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
# On Bernoulli simulated data: #
#
## mean_abs_pval_diff: This is the average absolute difference between the exact p-value and the chi-square-based p-value across all simulations.#
#
## prop_diff_in_decision: This is the proportion of simulated samples for which the exact method and the chi-square method give different reject/not-reject decisions at 5% significance.#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01#
  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals <= LRobs])#
}#
#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
    }#
    results <- rbind(results,#
      data.frame(#
        n=n_,#
        alpha=alpha_,#
        mean_abs_pval_diff=mean(abs_diff),#
        se_abs_pval_diff=sd(abs_diff)/sqrt(Nrep),#
        prop_diff_in_decision=mean(diff_dec),#
        se_diff_dec=sqrt(mean(diff_dec)*(1-mean(diff_dec))/Nrep)#
      )#
    )#
  }#
}#
#
results_plot <- subset(results, !is.na(mean_abs_pval_diff) & !is.na(prop_diff_in_decision))#
#
p1 <- ggplot(results_plot, aes(factor(n), mean_abs_pval_diff, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = mean_abs_pval_diff - 1.96*se_abs_pval_diff,#
      ymax = mean_abs_pval_diff + 1.96*se_abs_pval_diff#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="mean_abs_pval_diff", fill="alpha") +#
  theme_minimal()#
#
p2 <- ggplot(results_plot, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
      ymax = pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)#
    ),#
    width=0.2, position=position_dodge(width=0.9)#
  ) +#
  labs(x="n", y="prop_diff_in_decision", fill="alpha") +#
  theme_minimal()#
#
p1 / p2#
results
#############################################
# Exact vs. Chi-square LR-independence test ##
# Monte‑Carlo study – **SIMULATED DATA ONLY** ##
#############################################
#
# ------------------------------------------------------------------#
# 0.  Packages & helpers#
# ------------------------------------------------------------------#
#
library(Rcpp)      # for C++ forward algorithm#
library(stats)     # pchisq, rbinom#
library(ggplot2)   # plotting (if needed later)#
#
EPS  <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
# ------------------------------------------------------------------#
# 1.  C++ forward algorithm to enumerate exact LR distribution#
# ------------------------------------------------------------------#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;              // avoid log(0)#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
// structure of a forward state#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
// encode 5 integers into one long long key#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      // next observation = 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      // next observation = 1#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  // collect LR distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
# Thin R wrapper ------------------------------------------------------#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
# ------------------------------------------------------------------#
# 2.  Log‑likelihood ratio for one sample path#
# ------------------------------------------------------------------#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n < 2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0)      T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else                          T11 <- T11 + 1#
  }#
  T0  <- T00 + T10#
  T1  <- T01 + T11#
  ph  <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01;  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11;  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
# ------------------------------------------------------------------#
# 3.  Exact p‑value (***regulatory, conservative: P(LR ≥ LRobs)***)#
# ------------------------------------------------------------------#
get_pval_exact <- function(LRvals, probvals, LRobs) {#
  1 - sum(probvals[LRvals < LRobs])   # keep LR >= LRobs in tail#
}#
#
# ------------------------------------------------------------------#
# 4.  Monte‑Carlo study (simulated Bernoulli data only)#
# ------------------------------------------------------------------#
#
set.seed(123)#
#
n_list     <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep       <- 2000#
#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
#
    abs_diff  <- numeric(Nrep)#
    diff_dec  <- numeric(Nrep)#
    rej_exact_vec <- numeric(Nrep)#
    rej_chi2_vec  <- numeric(Nrep)#
#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs    <- my_compute_LRind(X, alpha_)#
      p_exact  <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2   <- 1 - pchisq(LRobs, df = 1)#
#
      abs_diff[i] <- abs(p_exact - p_chi2)#
      diff_dec[i] <- as.integer((p_exact < 0.05) != (p_chi2 < 0.05))#
      rej_exact_vec[i] <- as.integer(p_exact < 0.05)  # size under H0#
      rej_chi2_vec[i]  <- as.integer(p_chi2  < 0.05)#
    }#
#
    # aggregate#
    mean_abs <- mean(abs_diff)#
    se_abs   <- sd(abs_diff) / sqrt(Nrep)#
#
    prop_dec <- mean(diff_dec)#
    se_dec   <- sqrt(prop_dec * (1 - prop_dec) / Nrep)#
#
    size_exact <- mean(rej_exact_vec)   # empirical type‑I error#
    se_size_exact <- sqrt(size_exact * (1 - size_exact) / Nrep)#
#
    size_chi2  <- mean(rej_chi2_vec)#
    se_size_chi2 <- sqrt(size_chi2 * (1 - size_chi2) / Nrep)#
#
    results <- rbind(results, data.frame(#
      n = n_,#
      alpha = alpha_,#
      mean_abs_pval_diff = mean_abs,#
      se_abs_pval_diff   = se_abs,#
      prop_diff_in_decision = prop_dec,#
      se_diff_dec            = se_dec,#
      size_exact = size_exact,#
      se_size_exact = se_size_exact,#
      size_chi2  = size_chi2,#
      se_size_chi2 = se_size_chi2#
    ))#
  }#
}#
#
# ------------------------------------------------------------------#
# 5.  View results#
# ------------------------------------------------------------------#
print(results)#
#
# Optional: save to CSV#
# write.csv(results, "lr_backtest_sim_results.csv", row.names = FALSE)
library(Rcpp)#
library(stats)#
library(ggplot2)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0)      T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else                          T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11; pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
set.seed(123)#
#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
#
    diff_dec  <- numeric(Nrep)#
    rej_exact <- numeric(Nrep)#
    rej_chi2  <- numeric(Nrep)#
#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs   <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      diff_dec[i] <- (p_exact < 0.05) != (p_chi2 < 0.05)#
      rej_exact[i] <- p_exact < 0.05#
      rej_chi2[i]  <- p_chi2  < 0.05#
    }#
#
    prop_dec <- mean(diff_dec)#
    se_dec   <- sqrt(prop_dec * (1 - prop_dec) / Nrep)#
#
    size_ex  <- mean(rej_exact)#
    se_ex    <- sqrt(size_ex * (1 - size_ex) / Nrep)#
#
    size_ch  <- mean(rej_chi2)#
    se_ch    <- sqrt(size_ch * (1 - size_ch) / Nrep)#
#
    results <- rbind(results, data.frame(#
      n=n_, alpha=alpha_,#
      prop_diff_in_decision=prop_dec,#
      se_diff_dec=se_dec,#
      size_exact=size_ex,#
      se_size_exact=se_ex,#
      size_chi2=size_ch,#
      se_size_chi2=se_ch))#
  }#
}#
#
print(results)#
#
library(tidyr)#
plot_df <- pivot_longer(results, cols=c(size_exact,size_chi2),#
                        names_to="method", values_to="size")#
#
p_size <- ggplot(plot_df, aes(factor(n), size, fill=method)) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(aes(ymin=size-1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2),#
                    ymax=size+1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2)),#
                position=position_dodge(width=0.9), width=0.25) +#
  facet_wrap(~alpha, labeller=label_both) +#
  geom_hline(yintercept=0.05, colour="red", linetype="dashed") +#
  labs(x="n", y="empirical size (α=5%)", fill="method") +#
  theme_minimal()#
#
print(p_size)
install.package('tidyr')
install.packages('tidyr')
library(Rcpp)#
library(stats)#
library(ggplot2)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0)      T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else                          T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11; pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
set.seed(123)#
#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
#
    diff_dec  <- numeric(Nrep)#
    rej_exact <- numeric(Nrep)#
    rej_chi2  <- numeric(Nrep)#
#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs   <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      diff_dec[i] <- (p_exact < 0.05) != (p_chi2 < 0.05)#
      rej_exact[i] <- p_exact < 0.05#
      rej_chi2[i]  <- p_chi2  < 0.05#
    }#
#
    prop_dec <- mean(diff_dec)#
    se_dec   <- sqrt(prop_dec * (1 - prop_dec) / Nrep)#
#
    size_ex  <- mean(rej_exact)#
    se_ex    <- sqrt(size_ex * (1 - size_ex) / Nrep)#
#
    size_ch  <- mean(rej_chi2)#
    se_ch    <- sqrt(size_ch * (1 - size_ch) / Nrep)#
#
    results <- rbind(results, data.frame(#
      n=n_, alpha=alpha_,#
      prop_diff_in_decision=prop_dec,#
      se_diff_dec=se_dec,#
      size_exact=size_ex,#
      se_size_exact=se_ex,#
      size_chi2=size_ch,#
      se_size_chi2=se_ch))#
  }#
}#
#
print(results)#
#
library(tidyr)#
plot_df <- pivot_longer(results, cols=c(size_exact,size_chi2),#
                        names_to="method", values_to="size")#
#
p_size <- ggplot(plot_df, aes(factor(n), size, fill=method)) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(aes(ymin=size-1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2),#
                    ymax=size+1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2)),#
                position=position_dodge(width=0.9), width=0.25) +#
  facet_wrap(~alpha, labeller=label_both) +#
  geom_hline(yintercept=0.05, colour="red", linetype="dashed") +#
  labs(x="n", y="empirical size (α=5%)", fill="method") +#
  theme_minimal()#
#
print(p_size)
p_size
library(Rcpp)#
library(stats)#
library(ggplot2)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01)#
                  + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15)#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0)      T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else                          T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11; pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
set.seed(123)#
#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
#
results <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals    <- dist_full$LR#
    probvals  <- dist_full$prob#
#
    diff_dec  <- numeric(Nrep)#
    rej_exact <- numeric(Nrep)#
    rej_chi2  <- numeric(Nrep)#
#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs   <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2  <- 1 - pchisq(LRobs, df=1)#
      diff_dec[i] <- (p_exact < 0.05) != (p_chi2 < 0.05)#
      rej_exact[i] <- p_exact < 0.05#
      rej_chi2[i]  <- p_chi2  < 0.05#
    }#
#
    prop_dec <- mean(diff_dec)#
    se_dec   <- sqrt(prop_dec * (1 - prop_dec) / Nrep)#
#
    size_ex  <- mean(rej_exact)#
    se_ex    <- sqrt(size_ex * (1 - size_ex) / Nrep)#
#
    size_ch  <- mean(rej_chi2)#
    se_ch    <- sqrt(size_ch * (1 - size_ch) / Nrep)#
#
    results <- rbind(results, data.frame(#
      n=n_, alpha=alpha_,#
      prop_diff_in_decision=prop_dec,#
      se_diff_dec=se_dec,#
      size_exact=size_ex,#
      se_size_exact=se_ex,#
      size_chi2=size_ch,#
      se_size_chi2=se_ch))#
  }#
}#
#
print(results)#
#
# 可视化：误拒率 vs n（按 alpha 分组），含 5% 红线#
library(tidyr)#
plot_df <- pivot_longer(results, cols=c(size_exact,size_chi2),#
                        names_to="method", values_to="size")#
#
p_size <- ggplot(plot_df, aes(factor(n), size, fill=method)) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(aes(ymin=size-1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2),#
                    ymax=size+1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2)),#
                position=position_dodge(width=0.9), width=0.25) +#
  facet_wrap(~alpha, labeller=label_both) +#
  geom_hline(yintercept=0.05, colour="red", linetype="dashed") +#
  labs(x="n", y="empirical size (α=5%)", fill="method") +#
  theme_minimal()#
#
print(p_size)#
#
# 可视化：两法翻转比例 prop_diff_in_decision#
p_flip <- ggplot(results, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(aes(ymin=pmax(prop_diff_in_decision - 1.96*se_diff_dec, 0),#
                    ymax=pmin(prop_diff_in_decision + 1.96*se_diff_dec, 1)),#
                position=position_dodge(width=0.9), width=0.25) +#
  facet_wrap(~alpha, labeller=label_both) +#
  labs(x="n", y="proportion of decision flips", fill="alpha") +#
  theme_minimal()#
#
print(p_flip)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> curMap;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    curMap[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    curMap[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){#
      double p = kv.second.prob;#
      if(p < prune_threshold) continue;#
      int la  = kv.second.la;#
      int T00 = kv.second.T00, T10 = kv.second.T10, T01 = kv.second.T01, T11 = kv.second.T11;#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la = 0;  ns.prob = p * (1.0 - alpha);#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
      {#
        State ns = kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la = 1;  ns.prob = p * alpha;#
        auto &slot = newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){#
    double p = kv.second.prob;#
    if(p<=0) continue;#
    int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
    double LR = 0.0;#
    if(n>1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      double ph  = (double)T1/(n-1);#
      double num = T0*s_log(1.0-ph) + T1*s_log(ph);#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01) + T10*s_log(1.0-pi11) + T11*s_log(pi11);#
      LR = -2.0*(num - den);#
    }#
    lrDist[LR] += p;#
  }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(), lrDist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){ return a.first < b.first; });#
  NumericVector LRout, Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i<vec.size() && std::fabs(vec[i].first-curLR)<1e-15){ curP += vec[i].second; ++i; }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15) fb_lrind_fastcpp(n, alpha, prune_threshold)#
my_compute_LRind <- function(X, alpha) {#
  n <- length(X)#
  if(n<2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00 + 1#
    else if(X[i-1]==0 && X[i]==1) T01 <- T01 + 1#
    else if(X[i-1]==1 && X[i]==0) T10 <- T10 + 1#
    else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  ph <- T1/(n-1)#
  num <- T0*safe_log(1-ph) + T1*safe_log(ph)#
  s01 <- T00 + T01;  pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10 + T11;  pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01) + T01*safe_log(pi01) + T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results <- data.frame()#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist_full <- fb_lrind(n_, alpha_, 1e-15)#
    LRvals <- dist_full$LR#
    probvals <- dist_full$prob#
    diff_dec <- numeric(Nrep)#
    rej_exact <- numeric(Nrep)#
    rej_chi2 <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- rbinom(n_, 1, alpha_)#
      LRobs <- my_compute_LRind(X, alpha_)#
      p_exact <- get_pval_exact(LRvals, probvals, LRobs)#
      p_chi2 <- 1 - pchisq(LRobs, df=1)#
      diff_dec[i] <- (p_exact < 0.05) != (p_chi2 < 0.05)#
      rej_exact[i] <- p_exact < 0.05#
      rej_chi2[i] <- p_chi2 < 0.05#
    }#
    prop_dec <- mean(diff_dec)#
    se_dec <- sqrt(prop_dec*(1-prop_dec)/Nrep)#
    size_ex <- mean(rej_exact)#
    se_ex <- sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch <- mean(rej_chi2)#
    se_ch <- sqrt(size_ch*(1-size_ch)/Nrep)#
    results <- rbind(results, data.frame(n=n_, alpha=alpha_, prop_diff_in_decision=prop_dec, se_diff_dec=se_dec, size_exact=size_ex, se_size_exact=se_ex, size_chi2=size_ch, se_size_chi2=se_ch))#
  }#
}#
library(tidyr)#
plot_df <- pivot_longer(results, cols=c(size_exact,size_chi2), names_to="method", values_to="size")#
p_size <- ggplot(plot_df, aes(factor(n), size, fill=method)) + geom_bar(stat="identity", position="dodge") + geom_errorbar(aes(ymin=size-1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2), ymax=size+1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2)), position=position_dodge(width=0.9), width=0.25) + facet_wrap(~alpha, labeller=label_both) + geom_hline(yintercept=0.05, colour="red", linetype="dashed") + labs(x="n", y="empirical size (α=5%)", fill="method") + theme_minimal()#
p_flip <- ggplot(results, aes(factor(n), prop_diff_in_decision, fill=factor(alpha))) + geom_bar(stat="identity", position="dodge") + geom_errorbar(aes(ymin=pmax(prop_diff_in_decision-1.96*se_diff_dec,0), ymax=pmin(prop_diff_in_decision+1.96*se_diff_dec,1)), position=position_dodge(width=0.9), width=0.25) + facet_wrap(~alpha, labeller=label_both) + labs(x="n", y="proportion of decision flips", fill="alpha") + theme_minimal()#
combined_plot <- p_size / p_flip#
print(combined_plot)#
print(results)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
lEPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){ long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M; return la+S2*T00+S3*T10+S4*T01+S5*T11; }#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5; std::unordered_map<long long,State,LLHash> curMap;#
  {State s0{0,0,0,0,0,1.0-alpha};curMap[encode5(0,0,0,0,0,NMAX)]=s0; State s1{1,0,0,0,0,alpha};curMap[encode5(1,0,0,0,0,NMAX)]=s1;}#
  for(int k=1;k<n;k++){ std::unordered_map<long long,State,LLHash> newMap; newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){ double p=kv.second.prob; if(p<prune_threshold) continue; int la=kv.second.la; int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {State ns=kv.second; if(la==0) ns.T00++; else ns.T10++; ns.la=0; ns.prob=p*(1.0-alpha); auto &slot=newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)]; if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
      {State ns=kv.second; if(la==0) ns.T01++; else ns.T11++; ns.la=1; ns.prob=p*alpha; auto &slot=newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)]; if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){ double p=kv.second.prob; if(p<=0) continue; int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11; double LR=0.0; if(n>1){ int T0=T00+T10,T1=T01+T11; double ph=(double)T1/(n-1); double num=T0*s_log(1.0-ph)+T1*s_log(ph); int s01=T00+T01,s11=T10+T11; double pi01=s01>0?(double)T01/s01:1.0; double pi11=s11>0?(double)T11/s11:1.0; double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11); LR=-2.0*(num-den);} lrDist[LR]+=p; }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(),lrDist.end()); std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;}); NumericVector LRout,Pout; for(size_t i=0;i<vec.size();){ double curLR=vec[i].first,curP=0.0; while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second;++i;} LRout.push_back(curLR);Pout.push_back(curP);} return List::create(Named("LR")=LRout,Named("prob")=Pout); }#
')#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15) fb_lrind_fastcpp(n, alpha, prune_threshold)#
my_compute_LRind <- function(X, alpha){ n<-length(X); if(n<2) return(0); T00<-T01<-T10<-T11<-0; for(i in 2:n){ if(X[i-1]==0&&X[i]==0) T00<-T00+1 else if(X[i-1]==0&&X[i]==1) T01<-T01+1 else if(X[i-1]==1&&X[i]==0) T10<-T10+1 else T11<-T11+1 }; T0<-T00+T10; T1<-T01+T11; ph<-T1/(n-1); num<-T0*safe_log(1-ph)+T1*safe_log(ph); s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1; s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1; den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11); -2*(num-den) }#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
gen_markov <- function(n, alpha, phi=0.6){ p11<-phi; p01<-alpha*(1-phi)/(1-alpha); X<-numeric(n); X[1]<-rbinom(1,1,alpha); for(i in 2:n) X[i]<-rbinom(1,1, ifelse(X[i-1]==1,p11,p01)); X }#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results_size<-data.frame(); results_power<-data.frame()#
for(n_ in n_list){ for(alpha_ in alpha_list){ dist_full<-fb_lrind(n_,alpha_,1e-15); LRvals<-dist_full$LR; probvals<-dist_full$prob; diff_dec<-numeric(Nrep); rej_exact<-numeric(Nrep); rej_chi2<-numeric(Nrep); for(i in seq_len(Nrep)){ X<-rbinom(n_,1,alpha_); LRobs<-my_compute_LRind(X,alpha_); p_exact<-get_pval_exact(LRvals,probvals,LRobs); p_chi2<-1-pchisq(LRobs,df=1); diff_dec[i]<-(p_exact<0.05)!=(p_chi2<0.05); rej_exact[i]<-p_exact<0.05; rej_chi2[i]<-p_chi2<0.05 }#
 prop_dec<-mean(diff_dec); se_dec<-sqrt(prop_dec*(1-prop_dec)/Nrep); size_ex<-mean(rej_exact); se_ex<-sqrt(size_ex*(1-size_ex)/Nrep); size_ch<-mean(rej_chi2); se_ch<-sqrt(size_ch*(1-size_ch)/Nrep); results_size<-rbind(results_size,data.frame(n=n_,alpha=alpha_,size_exact=size_ex,se_size_exact=se_ex,size_chi2=size_ch,se_size_chi2=se_ch))#
 # power#
 pow_exact<-numeric(Nrep); pow_chi2<-numeric(Nrep); for(i in seq_len(Nrep)){ X<-gen_markov(n_,alpha_,phi=0.6); LRobs<-my_compute_LRind(X,alpha_); p_exact<-get_pval_exact(LRvals,probvals,LRobs); p_chi2<-1-pchisq(LRobs,df=1); pow_exact[i]<-p_exact<0.05; pow_chi2[i]<-p_chi2<0.05 }#
 p_ex<-mean(pow_exact); se_p_ex<-sqrt(p_ex*(1-p_ex)/Nrep); p_ch<-mean(pow_chi2); se_p_ch<-sqrt(p_ch*(1-p_ch)/Nrep); results_power<-rbind(results_power,data.frame(n=n_,alpha=alpha_,power_exact=p_ex,se_power_exact=se_p_ex,power_chi2=p_ch,se_power_chi2=se_p_ch)) }}#
library(tidyr)#
size_df<-pivot_longer(results_size,cols=c(size_exact,size_chi2),names_to="method",values_to="value")#
power_df<-pivot_longer(results_power,cols=c(power_exact,power_chi2),names_to="method",values_to="value")#
plot_size<-ggplot(size_df,aes(factor(n),value,fill=method))+geom_bar(stat="identity",position="dodge")+geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2),ymax=value+1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2)),position=position_dodge(width=0.9),width=0.25)+facet_wrap(~alpha,labeller=label_both)+geom_hline(yintercept=0.05,colour="red",linetype="dashed")+labs(x="n",y="empirical size (α=5%)",fill="method")+theme_minimal()#
plot_power<-ggplot(power_df,aes(factor(n),value,fill=method))+geom_bar(stat="identity",position="dodge")+geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2),ymax=value+1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2)),position=position_dodge(width=0.9),width=0.25)+facet_wrap(~alpha,labeller=label_both)+labs(x="n",y="empirical power (φ=0.6)",fill="method")+theme_minimal()#
combined_plot<-plot_power/plot_size#
print(combined_plot)#
print(results_size)#
print(results_power)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
lEPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){ long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M; return la+S2*T00+S3*T10+S4*T01+S5*T11; }#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5; std::unordered_map<long long,State,LLHash> curMap;#
  {State s0{0,0,0,0,0,1.0-alpha};curMap[encode5(0,0,0,0,0,NMAX)]=s0; State s1{1,0,0,0,0,alpha};curMap[encode5(1,0,0,0,0,NMAX)]=s1;}#
  for(int k=1;k<n;k++){ std::unordered_map<long long,State,LLHash> newMap; newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){ double p=kv.second.prob; if(p<prune_threshold) continue; int la=kv.second.la; int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {State ns=kv.second; if(la==0) ns.T00++; else ns.T10++; ns.la=0; ns.prob=p*(1.0-alpha); auto &slot=newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)]; if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
      {State ns=kv.second; if(la==0) ns.T01++; else ns.T11++; ns.la=1; ns.prob=p*alpha; auto &slot=newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)]; if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){ double p=kv.second.prob; if(p<=0) continue; int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11; double LR=0.0; if(n>1){ int T0=T00+T10,T1=T01+T11; double ph=(double)T1/(n-1); double num=T0*s_log(1.0-ph)+T1*s_log(ph); int s01=T00+T01,s11=T10+T11; double pi01=s01>0?(double)T01/s01:1.0; double pi11=s11>0?(double)T11/s11:1.0; double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11); LR=-2.0*(num-den);} lrDist[LR]+=p; }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(),lrDist.end()); std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;}); NumericVector LRout,Pout; for(size_t i=0;i<vec.size();){ double curLR=vec[i].first,curP=0.0; while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second;++i;} LRout.push_back(curLR);Pout.push_back(curP);} return List::create(Named("LR")=LRout,Named("prob")=Pout); }#
')#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15) fb_lrind_fastcpp(n, alpha, prune_threshold)#
my_compute_LRind <- function(X, alpha){ n<-length(X); if(n<2) return(0); T00<-T01<-T10<-T11<-0; for(i in 2:n){ if(X[i-1]==0&&X[i]==0) T00<-T00+1 else if(X[i-1]==0&&X[i]==1) T01<-T01+1 else if(X[i-1]==1&&X[i]==0) T10<-T10+1 else T11<-T11+1 }; T0<-T00+T10; T1<-T01+T11; ph<-T1/(n-1); num<-T0*safe_log(1-ph)+T1*safe_log(ph); s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1; s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1; den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11); -2*(num-den) }#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
gen_markov <- function(n, alpha, phi=0.6){ p11<-phi; p01<-alpha*(1-phi)/(1-alpha); X<-numeric(n); X[1]<-rbinom(1,1,alpha); for(i in 2:n) X[i]<-rbinom(1,1, ifelse(X[i-1]==1,p11,p01)); X }#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results_size<-data.frame(); results_power<-data.frame()#
for(n_ in n_list){ for(alpha_ in alpha_list){ dist_full<-fb_lrind(n_,alpha_,1e-15); LRvals<-dist_full$LR; probvals<-dist_full$prob; diff_dec<-numeric(Nrep); rej_exact<-numeric(Nrep); rej_chi2<-numeric(Nrep); for(i in seq_len(Nrep)){ X<-rbinom(n_,1,alpha_); LRobs<-my_compute_LRind(X,alpha_); p_exact<-get_pval_exact(LRvals,probvals,LRobs); p_chi2<-1-pchisq(LRobs,df=1); diff_dec[i]<-(p_exact<0.05)!=(p_chi2<0.05); rej_exact[i]<-p_exact<0.05; rej_chi2[i]<-p_chi2<0.05 }#
 prop_dec<-mean(diff_dec); se_dec<-sqrt(prop_dec*(1-prop_dec)/Nrep); size_ex<-mean(rej_exact); se_ex<-sqrt(size_ex*(1-size_ex)/Nrep); size_ch<-mean(rej_chi2); se_ch<-sqrt(size_ch*(1-size_ch)/Nrep); results_size<-rbind(results_size,data.frame(n=n_,alpha=alpha_,size_exact=size_ex,se_size_exact=se_ex,size_chi2=size_ch,se_size_chi2=se_ch))#
 # power#
 pow_exact<-numeric(Nrep); pow_chi2<-numeric(Nrep); for(i in seq_len(Nrep)){ X<-gen_markov(n_,alpha_,phi=0.8); LRobs<-my_compute_LRind(X,alpha_); p_exact<-get_pval_exact(LRvals,probvals,LRobs); p_chi2<-1-pchisq(LRobs,df=1); pow_exact[i]<-p_exact<0.05; pow_chi2[i]<-p_chi2<0.05 }#
 p_ex<-mean(pow_exact); se_p_ex<-sqrt(p_ex*(1-p_ex)/Nrep); p_ch<-mean(pow_chi2); se_p_ch<-sqrt(p_ch*(1-p_ch)/Nrep); results_power<-rbind(results_power,data.frame(n=n_,alpha=alpha_,power_exact=p_ex,se_power_exact=se_p_ex,power_chi2=p_ch,se_power_chi2=se_p_ch)) }}#
library(tidyr)#
size_df<-pivot_longer(results_size,cols=c(size_exact,size_chi2),names_to="method",values_to="value")#
power_df<-pivot_longer(results_power,cols=c(power_exact,power_chi2),names_to="method",values_to="value")#
plot_size<-ggplot(size_df,aes(factor(n),value,fill=method))+geom_bar(stat="identity",position="dodge")+geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2),ymax=value+1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2)),position=position_dodge(width=0.9),width=0.25)+facet_wrap(~alpha,labeller=label_both)+geom_hline(yintercept=0.05,colour="red",linetype="dashed")+labs(x="n",y="empirical size (α=5%)",fill="method")+theme_minimal()#
plot_power<-ggplot(power_df,aes(factor(n),value,fill=method))+geom_bar(stat="identity",position="dodge")+geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2),ymax=value+1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2)),position=position_dodge(width=0.9),width=0.25)+facet_wrap(~alpha,labeller=label_both)+labs(x="n",y="empirical power (φ=0.6)",fill="method")+theme_minimal()#
combined_plot<-plot_power/plot_size#
print(combined_plot)#
print(results_size)#
print(results_power)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
lEPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){ long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M; return la+S2*T00+S3*T10+S4*T01+S5*T11; }#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5; std::unordered_map<long long,State,LLHash> curMap;#
  {State s0{0,0,0,0,0,1.0-alpha};curMap[encode5(0,0,0,0,0,NMAX)]=s0; State s1{1,0,0,0,0,alpha};curMap[encode5(1,0,0,0,0,NMAX)]=s1;}#
  for(int k=1;k<n;k++){ std::unordered_map<long long,State,LLHash> newMap; newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){ double p=kv.second.prob; if(p<prune_threshold) continue; int la=kv.second.la; int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {State ns=kv.second; if(la==0) ns.T00++; else ns.T10++; ns.la=0; ns.prob=p*(1.0-alpha); auto &slot=newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)]; if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
      {State ns=kv.second; if(la==0) ns.T01++; else ns.T11++; ns.la=1; ns.prob=p*alpha; auto &slot=newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)]; if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){ double p=kv.second.prob; if(p<=0) continue; int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11; double LR=0.0; if(n>1){ int T0=T00+T10,T1=T01+T11; double ph=(double)T1/(n-1); double num=T0*s_log(1.0-ph)+T1*s_log(ph); int s01=T00+T01,s11=T10+T11; double pi01=s01>0?(double)T01/s01:1.0; double pi11=s11>0?(double)T11/s11:1.0; double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11); LR=-2.0*(num-den);} lrDist[LR]+=p; }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(),lrDist.end()); std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;}); NumericVector LRout,Pout; for(size_t i=0;i<vec.size();){ double curLR=vec[i].first,curP=0.0; while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second;++i;} LRout.push_back(curLR);Pout.push_back(curP);} return List::create(Named("LR")=LRout,Named("prob")=Pout); }#
')#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15) fb_lrind_fastcpp(n, alpha, prune_threshold)#
my_compute_LRind <- function(X, alpha){ n<-length(X); if(n<2) return(0); T00<-T01<-T10<-T11<-0; for(i in 2:n){ if(X[i-1]==0&&X[i]==0) T00<-T00+1 else if(X[i-1]==0&&X[i]==1) T01<-T01+1 else if(X[i-1]==1&&X[i]==0) T10<-T10+1 else T11<-T11+1 }; T0<-T00+T10; T1<-T01+T11; ph<-T1/(n-1); num<-T0*safe_log(1-ph)+T1*safe_log(ph); s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1; s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1; den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11); -2*(num-den) }#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
gen_markov <- function(n, alpha, phi=0.6){ p11<-phi; p01<-alpha*(1-phi)/(1-alpha); X<-numeric(n); X[1]<-rbinom(1,1,alpha); for(i in 2:n) X[i]<-rbinom(1,1, ifelse(X[i-1]==1,p11,p01)); X }#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results_size<-data.frame(); results_power<-data.frame()#
for(n_ in n_list){ for(alpha_ in alpha_list){ dist_full<-fb_lrind(n_,alpha_,1e-15); LRvals<-dist_full$LR; probvals<-dist_full$prob; diff_dec<-numeric(Nrep); rej_exact<-numeric(Nrep); rej_chi2<-numeric(Nrep); for(i in seq_len(Nrep)){ X<-rbinom(n_,1,alpha_); LRobs<-my_compute_LRind(X,alpha_); p_exact<-get_pval_exact(LRvals,probvals,LRobs); p_chi2<-1-pchisq(LRobs,df=1); diff_dec[i]<-(p_exact<0.05)!=(p_chi2<0.05); rej_exact[i]<-p_exact<0.05; rej_chi2[i]<-p_chi2<0.05 }#
 prop_dec<-mean(diff_dec); se_dec<-sqrt(prop_dec*(1-prop_dec)/Nrep); size_ex<-mean(rej_exact); se_ex<-sqrt(size_ex*(1-size_ex)/Nrep); size_ch<-mean(rej_chi2); se_ch<-sqrt(size_ch*(1-size_ch)/Nrep); results_size<-rbind(results_size,data.frame(n=n_,alpha=alpha_,size_exact=size_ex,se_size_exact=se_ex,size_chi2=size_ch,se_size_chi2=se_ch))#
 # power#
 pow_exact<-numeric(Nrep); pow_chi2<-numeric(Nrep); for(i in seq_len(Nrep)){ X<-gen_markov(n_,alpha_,phi=0.6); LRobs<-my_compute_LRind(X,alpha_); p_exact<-get_pval_exact(LRvals,probvals,LRobs); p_chi2<-1-pchisq(LRobs,df=1); pow_exact[i]<-p_exact<0.05; pow_chi2[i]<-p_chi2<0.05 }#
 p_ex<-mean(pow_exact); se_p_ex<-sqrt(p_ex*(1-p_ex)/Nrep); p_ch<-mean(pow_chi2); se_p_ch<-sqrt(p_ch*(1-p_ch)/Nrep); results_power<-rbind(results_power,data.frame(n=n_,alpha=alpha_,power_exact=p_ex,se_power_exact=se_p_ex,power_chi2=p_ch,se_power_chi2=se_p_ch)) }}#
library(tidyr)#
size_df<-pivot_longer(results_size,cols=c(size_exact,size_chi2),names_to="method",values_to="value")#
power_df<-pivot_longer(results_power,cols=c(power_exact,power_chi2),names_to="method",values_to="value")#
plot_size<-ggplot(size_df,aes(factor(n),value,fill=method))+geom_bar(stat="identity",position="dodge")+geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2),ymax=value+1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2)),position=position_dodge(width=0.9),width=0.25)+facet_wrap(~alpha,labeller=label_both)+geom_hline(yintercept=0.05,colour="red",linetype="dashed")+labs(x="n",y="empirical size (α=5%)",fill="method")+theme_minimal()#
plot_power<-ggplot(power_df,aes(factor(n),value,fill=method))+geom_bar(stat="identity",position="dodge")+geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2),ymax=value+1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2)),position=position_dodge(width=0.9),width=0.25)+facet_wrap(~alpha,labeller=label_both)+labs(x="n",y="empirical power (φ=0.6)",fill="method")+theme_minimal()#
combined_plot<-plot_power/plot_size#
print(combined_plot)#
print(results_size)#
print(results_power)#
#
phi_list<-c(0.2,0.4,0.6,0.8,0.9)#
Nrep_phi<-2000#
dist_250<-fb_lrind(250,0.05,1e-15)#
LRvals_250<-dist_250$LR; probvals_250<-dist_250$prob#
phi_df<-data.frame()#
for(phi_ in phi_list){ pow_ex<-numeric(Nrep_phi); pow_ch<-numeric(Nrep_phi); for(i in seq_len(Nrep_phi)){ X<-gen_markov(250,0.05,phi=phi_); LRobs<-my_compute_LRind(X,0.05); p_ex<-get_pval_exact(LRvals_250,probvals_250,LRobs); p_ch<-1-pchisq(LRobs,df=1); pow_ex[i]<-p_ex<0.05; pow_ch[i]<-p_ch<0.05 }#
  p1<-mean(pow_ex); se1<-sqrt(p1*(1-p1)/Nrep_phi); p2<-mean(pow_ch); se2<-sqrt(p2*(1-p2)/Nrep_phi); phi_df<-rbind(phi_df,data.frame(phi=phi_,method="exact",power=p1,se=se1)); phi_df<-rbind(phi_df,data.frame(phi=phi_,method="chi2",power=p2,se=se2)) }#
#
plot_phi<-ggplot(phi_df,aes(phi,power,color=method))+geom_line()+geom_point()+geom_errorbar(aes(ymin=power-1.96*se,ymax=power+1.96*se),width=0.02)+scale_x_continuous(breaks=phi_list)+labs(x="phi",y="empirical power (n=250, α=0.05)")+theme_minimal()#
print(plot_phi)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
lEPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){ long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M; return la+S2*T00+S3*T10+S4*T01+S5*T11; }#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5; std::unordered_map<long long,State,LLHash> curMap;#
  {State s0{0,0,0,0,0,1.0-alpha};curMap[encode5(0,0,0,0,0,NMAX)]=s0; State s1{1,0,0,0,0,alpha};curMap[encode5(1,0,0,0,0,NMAX)]=s1;}#
  for(int k=1;k<n;k++){ std::unordered_map<long long,State,LLHash> newMap; newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){ double p=kv.second.prob; if(p<prune_threshold) continue; int la=kv.second.la; int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {State ns=kv.second; if(la==0) ns.T00++; else ns.T10++; ns.la=0; ns.prob=p*(1.0-alpha); auto &slot=newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)]; if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
      {State ns=kv.second; if(la==0) ns.T01++; else ns.T11++; ns.la=1; ns.prob=p*alpha; auto &slot=newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)]; if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){ double p=kv.second.prob; if(p<=0) continue; int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11; double LR=0.0; if(n>1){ int T0=T00+T10,T1=T01+T11; double ph=(double)T1/(n-1); double num=T0*s_log(1.0-ph)+T1*s_log(ph); int s01=T00+T01,s11=T10+T11; double pi01=s01>0?(double)T01/s01:1.0; double pi11=s11>0?(double)T11/s11:1.0; double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11); LR=-2.0*(num-den);} lrDist[LR]+=p; }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(),lrDist.end()); std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;}); NumericVector LRout,Pout; for(size_t i=0;i<vec.size();){ double curLR=vec[i].first,curP=0.0; while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second;++i;} LRout.push_back(curLR);Pout.push_back(curP);} return List::create(Named("LR")=LRout,Named("prob")=Pout); }#
')#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15) fb_lrind_fastcpp(n, alpha, prune_threshold)#
my_compute_LRind <- function(X, alpha){ n<-length(X); if(n<2) return(0); T00<-T01<-T10<-T11<-0; for(i in 2:n){ if(X[i-1]==0&&X[i]==0) T00<-T00+1 else if(X[i-1]==0&&X[i]==1) T01<-T01+1 else if(X[i-1]==1&&X[i]==0) T10<-T10+1 else T11<-T11+1 }; T0<-T00+T10; T1<-T01+T11; ph<-T1/(n-1); num<-T0*safe_log(1-ph)+T1*safe_log(ph); s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1; s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1; den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11); -2*(num-den) }#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
gen_markov <- function(n, alpha, phi=0.6){ p11<-phi; p01<-alpha*(1-phi)/(1-alpha); X<-numeric(n); X[1]<-rbinom(1,1,alpha); for(i in 2:n) X[i]<-rbinom(1,1, ifelse(X[i-1]==1,p11,p01)); X }#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results_size<-data.frame(); results_power<-data.frame()#
for(n_ in n_list){ for(alpha_ in alpha_list){ dist_full<-fb_lrind(n_,alpha_,1e-15); LRvals<-dist_full$LR; probvals<-dist_full$prob; diff_dec<-numeric(Nrep); rej_exact<-numeric(Nrep); rej_chi2<-numeric(Nrep); for(i in seq_len(Nrep)){ X<-rbinom(n_,1,alpha_); LRobs<-my_compute_LRind(X,alpha_); p_exact<-get_pval_exact(LRvals,probvals,LRobs); p_chi2<-1-pchisq(LRobs,df=1); diff_dec[i]<-(p_exact<0.05)!=(p_chi2<0.05); rej_exact[i]<-p_exact<0.05; rej_chi2[i]<-p_chi2<0.05 }#
 prop_dec<-mean(diff_dec); se_dec<-sqrt(prop_dec*(1-prop_dec)/Nrep); size_ex<-mean(rej_exact); se_ex<-sqrt(size_ex*(1-size_ex)/Nrep); size_ch<-mean(rej_chi2); se_ch<-sqrt(size_ch*(1-size_ch)/Nrep); results_size<-rbind(results_size,data.frame(n=n_,alpha=alpha_,size_exact=size_ex,se_size_exact=se_ex,size_chi2=size_ch,se_size_chi2=se_ch))#
 # power#
 pow_exact<-numeric(Nrep); pow_chi2<-numeric(Nrep); for(i in seq_len(Nrep)){ X<-gen_markov(n_,alpha_,phi=0.6); LRobs<-my_compute_LRind(X,alpha_); p_exact<-get_pval_exact(LRvals,probvals,LRobs); p_chi2<-1-pchisq(LRobs,df=1); pow_exact[i]<-p_exact<0.05; pow_chi2[i]<-p_chi2<0.05 }#
 p_ex<-mean(pow_exact); se_p_ex<-sqrt(p_ex*(1-p_ex)/Nrep); p_ch<-mean(pow_chi2); se_p_ch<-sqrt(p_ch*(1-p_ch)/Nrep); results_power<-rbind(results_power,data.frame(n=n_,alpha=alpha_,power_exact=p_ex,se_power_exact=se_p_ex,power_chi2=p_ch,se_power_chi2=se_p_ch)) }}#
library(tidyr)#
size_df<-pivot_longer(results_size,cols=c(size_exact,size_chi2),names_to="method",values_to="value")#
power_df<-pivot_longer(results_power,cols=c(power_exact,power_chi2),names_to="method",values_to="value")#
plot_size<-ggplot(size_df,aes(factor(n),value,fill=method))+geom_bar(stat="identity",position="dodge")+geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2),ymax=value+1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2)),position=position_dodge(width=0.9),width=0.25)+facet_wrap(~alpha,labeller=label_both)+geom_hline(yintercept=0.05,colour="red",linetype="dashed")+labs(x="n",y="empirical size (α=5%)",fill="method")+theme_minimal()#
plot_power<-ggplot(power_df,aes(factor(n),value,fill=method))+geom_bar(stat="identity",position="dodge")+geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2),ymax=value+1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2)),position=position_dodge(width=0.9),width=0.25)+facet_wrap(~alpha,labeller=label_both)+labs(x="n",y="empirical power (φ=0.6)",fill="method")+theme_minimal()#
combined_plot<-plot_power/plot_size#
print(combined_plot)#
print(results_size)#
print(results_power)
library(ggplot2)#
library(tidyr)#
#
n      <- 250#
alpha  <- 0.05#
phi_list <- c(0.2,0.4,0.6,0.8,0.9)#
Nrep   <- 2000#
#
dist   <- fb_lrind(n, alpha, 1e-15)#
LRvals <- dist$LR#
probvals <- dist$prob#
#
phi_df <- data.frame()#
#
for(phi in phi_list){#
  pow_ex <- pow_ch <- numeric(Nrep)#
  for(i in seq_len(Nrep)){#
    X <- gen_markov(n, alpha, phi)#
    LR <- my_compute_LRind(X, alpha)#
    p_ex <- get_pval_exact(LRvals, probvals, LR)#
    p_ch <- 1 - pchisq(LR, df = 1)#
    pow_ex[i] <- (p_ex < 0.05)#
    pow_ch[i] <- (p_ch < 0.05)#
  }#
  phi_df <- rbind(#
    phi_df,#
    data.frame(phi = phi, method = "exact",#
               power = mean(pow_ex),#
               se = sqrt(mean(pow_ex)*(1-mean(pow_ex))/Nrep)),#
    data.frame(phi = phi, method = "chi2",#
               power = mean(pow_ch),#
               se = sqrt(mean(pow_ch)*(1-mean(pow_ch))/Nrep))#
  )#
}#
#
plot_phi <- ggplot(phi_df, aes(phi, power, color = method)) +#
  geom_line() +#
  geom_point() +#
  geom_errorbar(aes(ymin = power - 1.96*se,#
                    ymax = power + 1.96*se), width = 0.02) +#
  scale_x_continuous(breaks = phi_list) +#
  labs(x = "phi",#
       y = "empirical power (n = 250, α = 0.05)") +#
  theme_minimal()#
#
print(plot_phi)
library(Rcpp)#
library(stats)#
library(ggplot2)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
# ---- C++ and R helper functions (assume not yet sourced) ----#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
struct State { int la,T00,T10,T01,T11; double prob; };#
struct LLHash { size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){ long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M; return la+S2*T00+S3*T10+S4*T01+S5*T11; }#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune_threshold=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5; std::unordered_map<long long,State,LLHash> curMap;#
  {State s0{0,0,0,0,0,1.0-alpha};curMap[encode5(0,0,0,0,0,NMAX)]=s0; State s1{1,0,0,0,0,alpha};curMap[encode5(1,0,0,0,0,NMAX)]=s1;}#
  for(int k=1;k<n;k++){ std::unordered_map<long long,State,LLHash> newMap; newMap.reserve(curMap.size()*2);#
    for(auto &kv:curMap){ double p=kv.second.prob; if(p<prune_threshold) continue; int la=kv.second.la; int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {State ns=kv.second; if(la==0) ns.T00++; else ns.T10++; ns.la=0; ns.prob=p*(1.0-alpha); auto &slot=newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)]; if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
      {State ns=kv.second; if(la==0) ns.T01++; else ns.T11++; ns.la=1; ns.prob=p*alpha; auto &slot=newMap[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)]; if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
    }#
    curMap.swap(newMap);#
  }#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv:curMap){ double p=kv.second.prob; if(p<=0) continue; int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11; double LR=0.0; if(n>1){ int T0=T00+T10,T1=T01+T11; double ph=(double)T1/(n-1); double num=T0*s_log(1.0-ph)+T1*s_log(ph); int s01=T00+T01,s11=T10+T11; double pi01=s01>0?(double)T01/s01:1.0; double pi11=s11>0?(double)T11/s11:1.0; double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11); LR=-2.0*(num-den);} lrDist[LR]+=p; }#
  std::vector<std::pair<double,double>> vec(lrDist.begin(),lrDist.end()); std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;}); NumericVector LRout,Pout; for(size_t i=0;i<vec.size();){ double curLR=vec[i].first,curP=0.0; while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second;++i;} LRout.push_back(curLR);Pout.push_back(curP);} return List::create(Named("LR")=LRout,Named("prob")=Pout); }#
')#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15) fb_lrind_fastcpp(n, alpha, prune_threshold)#
my_compute_LRind <- function(X, alpha){ n<-length(X); if(n<2) return(0); T00<-T01<-T10<-T11<-0; for(i in 2:n){ if(X[i-1]==0&&X[i]==0) T00<-T00+1 else if(X[i-1]==0&&X[i]==1) T01<-T01+1 else if(X[i-1]==1&&X[i]==0) T10<-T10+1 else T11<-T11+1 }; T0<-T00+T10; T1<-T01+T11; ph<-T1/(n-1); num<-T0*safe_log(1-ph)+T1*safe_log(ph); s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1; s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1; den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11); -2*(num-den) }#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
# ---- real data p‑values ----#
exception_df <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names = 1)#
alpha_vec <- c(0.05,0.025,0.01)#
colnames(exception_df) <- as.character(alpha_vec)#
#
p_tab <- data.frame()#
for(a in alpha_vec){ X <- exception_df[[as.character(a)]]; n <- length(X); dist <- fb_lrind(n,a); p_exact <- get_pval_exact(dist$LR,dist$prob,my_compute_LRind(X,a)); p_chi <- 1-pchisq(my_compute_LRind(X,a),df=1); p_tab <- rbind(p_tab,data.frame(alpha=a,method="exact",p_value=p_exact)); p_tab <- rbind(p_tab,data.frame(alpha=a,method="chi2",p_value=p_chi)) }#
#
print(p_tab)#
#
ggplot(p_tab,aes(factor(alpha),p_value,fill=method)) + geom_bar(stat="identity",position="dodge") + labs(x="alpha",y="p‑value") + theme_minimal()
library(Rcpp)#
library(stats)#
library(ggplot2)#
EPS<-1e-15#
safe_log<-function(x)log(pmax(x,EPS))#
cppFunction(' # same C++ code shortened for brevity#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp; const double EPS=1e-15; static inline double s_log(double x){return std::log(x>EPS?x:EPS);} struct State{int la,T00,T10,T01,T11;double prob;}; struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}}; static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){long long M=NMAX+10LL;long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;return la+S2*T00+S3*T10+S4*T01+S5*T11;} // [[Rcpp::export]] List fb_lrind_fastcpp(int n,double alpha=0.05,double prune=1e-15){if(n<1)return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));int NMAX=n+5;std::unordered_map<long long,State,LLHash>cur;{State s0{0,0,0,0,0,1.0-alpha};cur[encode5(0,0,0,0,0,NMAX)]=s0;State s1{1,0,0,0,0,alpha};cur[encode5(1,0,0,0,0,NMAX)]=s1;}for(int k=1;k<n;k++){std::unordered_map<long long,State,LLHash>nx;nx.reserve(cur.size()*2);for(auto &kv:cur){double p=kv.second.prob;if(p<prune)continue;int la=kv.second.la;int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T1
1=kv.second.T11;{State ns=kv.second;if(la==0)ns.T00++;else ns.T10++;ns.la=0;ns.prob=p*(1.0-alpha);auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];if(slot.prob==0)slot=ns;else slot.prob+=ns.prob;}{State ns=kv.second;if(la==0)ns.T01++;else ns.T11++;ns.la=1;ns.prob=p*alpha;auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];if(slot.prob==0)slot=ns;else slot.prob+=ns.prob;}}cur.swap(nx);}std::unordered_map<double,double>dist;for(auto &kv:cur){double p=kv.second.prob;if(p<=0)continue;int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;double LR=0.0;if(n>1){int T0=T00+T10,T1=T01+T11;double ph=(double)T1/(n-1);double num=T0*s_log(1.0-ph)+T1*s_log(ph);int s01=T00+T01,s11=T10+T11;double pi01=s01>0?(double)T01/s01:1.0;double pi11=s11>0?(double)T11/s11:1.0;double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);LR=-2.0*(num-den);}dist[LR]+=p;}std::vector<std::pair<double,double>>vec(dist.begin(),dist.end());std::sort(vec.begin(),vec.end(),[](
auto&a,auto&b){return a.first<b.first;});NumericVector LRout,Pout;for(size_t i=0;i<vec.size();){double curLR=vec[i].first,curP=0.0;while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second;++i;}LRout.push_back(curLR);Pout.push_back(curP);}return List::create(Named("LR")=LRout,Named("prob")=Pout);} ')#
fb_lrind<-function(n,alpha)fb_lrind_fastcpp(n,alpha,1e-15)#
my_compute_LRind<-function(X,alpha){n<-length(X);if(n<2)return(0);T00<-T01<-T10<-T11<-0;for(i in 2:n){if(X[i-1]==0&&X[i]==0)T00<-T00+1 else if(X[i-1]==0&&X[i]==1)T01<-T01+1 else if(X[i-1]==1&&X[i]==0)T10<-T10+1 else T11<-T11+1};T0<-T00+T10;T1<-T01+T11;ph<-T1/(n-1);num<-T0*safe_log(1-ph)+T1*safe_log(ph);s01<-T00+T01;pi01<-if(s01>0)T01/s01 else 1;s11<-T10+T11;pi11<-if(s11>0)T11/s11 else 1;den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11);-2*(num-den)}#
get_pval_exact<-function(LRvals,probvals,LRobs)1-sum(probvals[LRvals<LRobs])#
#
exception_df<-read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv",row.names=1)#
alpha_vec<-c(0.05,0.025,0.01)#
colnames(exception_df)<-as.character(alpha_vec)#
#
n_win<-250#
series_len<-nrow(exception_df)#
plot_df<-data.frame()#
for(a in alpha_vec){X<-exception_df[[as.character(a)]];dist<-fb_lrind(n_win,a);LRvals<-dist$LR;probvals<-dist$prob;idx_max<-series_len-n_win+1;for(idx in 1:idx_max){seg<-X[idx:(idx+n_win-1)];LR<-my_compute_LRind(seg,a);p_ex<-get_pval_exact(LRvals,probvals,LR);p_ch<-1-pchisq(LR,1);plot_df<-rbind(plot_df,data.frame(idx=idx,alpha=a,method="exact",p_value=p_ex));plot_df<-rbind(plot_df,data.frame(idx=idx,alpha=a,method="chi2",p_value=p_ch));}}#
#
ggplot(plot_df,aes(idx,p_value,color=method))+geom_line()+facet_wrap(~alpha,labeller=label_both,ncol=1)+geom_hline(yintercept=0.05,linetype="dashed",colour="red")+labs(x="window start index",y="p-value")+theme_minimal()
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  {State s0{0,0,0,0,0,1.0-alpha};cur[encode5(0,0,0,0,0,NMAX)]=s0;#
   State s1{1,0,0,0,0,alpha};cur[encode5(1,0,0,0,0,NMAX)]=s1;}#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {State ns=kv.second; if(la==0) ns.T00++; else ns.T10++;#
       ns.la=0; ns.prob=p*(1.0-alpha);#
       auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
       if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
      {State ns=kv.second; if(la==0) ns.T01++; else ns.T11++;#
       ns.la=1; ns.prob=p*alpha;#
       auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
       if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double num=T0*s_log(1.0-alpha)+T1*s_log(alpha);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)#
                +T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      LR=-2.0*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first,curP=0.0;#
    while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){#
      curP+=vec[i].second; ++i;#
    }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}')#
#
fb_lrind <- function(n,alpha) fb_lrind_fastcpp(n,alpha,1e-15)#
#
my_compute_LRind <- function(X,alpha){#
  n<-length(X); if(n<2) return(0)#
  T00<-T01<-T10<-T11<-0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1 else#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1 else#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1 else T11<-T11+1#
  }#
  T0<-T00+T10; T1<-T01+T11#
  num<-T0*safe_log(1-alpha)+T1*safe_log(alpha)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+#
       T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1-sum(probvals[LRvals<LRobs])#
#
gen_markov <- function(n,alpha,phi=0.6){#
  p11<-phi; p01<-alpha*(1-phi)/(1-alpha)#
  X<-numeric(n); X[1]<-rbinom(1,1,alpha)#
  for(i in 2:n) X[i]<-rbinom(1,1,ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results_size<-data.frame(); results_power<-data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrind(n_,alpha_); LRvals<-dist$LR; probvals<-dist$prob#
    rej_ex<-rej_ch<-numeric(Nrep)#
    for(i in 1:Nrep){#
      X<-rbinom(n_,1,alpha_)#
      LR<-my_compute_LRind(X,alpha_)#
      p_ex<-get_pval_exact(LRvals,probvals,LR)#
      p_ch<-1-pchisq(LR,1)#
      rej_ex[i]<-(p_ex<0.05); rej_ch[i]<-(p_ch<0.05)#
    }#
    size_ex<-mean(rej_ex); se_ex<-sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch<-mean(rej_ch); se_ch<-sqrt(size_ch*(1-size_ch)/Nrep)#
    results_size<-rbind(results_size,data.frame(n=n_,alpha=alpha_,#
                      size_exact=size_ex,se_size_exact=se_ex,#
                      size_chi2=size_ch,se_size_chi2=se_ch))#
    pow_ex<-pow_ch<-numeric(Nrep)#
    for(i in 1:Nrep){#
      X<-gen_markov(n_,alpha_,0.6)#
      LR<-my_compute_LRind(X,alpha_)#
      p_ex<-get_pval_exact(LRvals,probvals,LR)#
      p_ch<-1-pchisq(LR,1)#
      pow_ex[i]<-(p_ex<0.05); pow_ch[i]<-(p_ch<0.05)#
    }#
    p_ex<-mean(pow_ex); se_pe<-sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch<-mean(pow_ch); se_pc<-sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power<-rbind(results_power,data.frame(n=n_,alpha=alpha_,#
                        power_exact=p_ex,se_power_exact=se_pe,#
                        power_chi2=p_ch,se_power_chi2=se_pc))#
  }#
}#
#
size_df<-pivot_longer(results_size,cols=c(size_exact,size_chi2),#
                      names_to=\"method\",values_to=\"value\")#
power_df<-pivot_longer(results_power,cols=c(power_exact,power_chi2),#
                       names_to=\"method\",values_to=\"value\")#
#
p_size<-ggplot(size_df,aes(factor(n),value,fill=method))+#
  geom_bar(stat=\"identity\",position=\"dodge\")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method==\"size_exact\",se_size_exact,se_size_chi2),#
                    ymax=value+1.96*ifelse(method==\"size_exact\",se_size_exact,se_size_chi2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~alpha,labeller=label_both)+#
  geom_hline(yintercept=0.05,colour=\"red\",linetype=\"dashed\")+#
  labs(x=\"n\",y=\"empirical size (α=5%)\")+theme_minimal()#
#
p_power<-ggplot(power_df,aes(factor(n),value,fill=method))+#
  geom_bar(stat=\"identity\",position=\"dodge\")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method==\"power_exact\",se_power_exact,se_power_chi2),#
                    ymax=value+1.96*ifelse(method==\"power_exact\",se_power_exact,se_power_chi2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~alpha,labeller=label_both)+#
  labs(x=\"n\",y=\"empirical power (φ=0.6)\")+theme_minimal()#
#
print(p_power/p_size)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  {State s0{0,0,0,0,0,1.0-alpha};cur[encode5(0,0,0,0,0,NMAX)]=s0;#
   State s1{1,0,0,0,0,alpha};cur[encode5(1,0,0,0,0,NMAX)]=s1;}#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {State ns=kv.second; if(la==0) ns.T00++; else ns.T10++;#
       ns.la=0; ns.prob=p*(1.0-alpha);#
       auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
       if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
      {State ns=kv.second; if(la==0) ns.T01++; else ns.T11++;#
       ns.la=1; ns.prob=p*alpha;#
       auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
       if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;}#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double num=T0*s_log(1.0-alpha)+T1*s_log(alpha);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)#
                +T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      LR=-2.0*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first,curP=0.0;#
    while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){#
      curP+=vec[i].second; ++i;#
    }#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}')#
#
fb_lrind <- function(n,alpha) fb_lrind_fastcpp(n,alpha,1e-15)#
#
my_compute_LRind <- function(X,alpha){#
  n<-length(X); if(n<2) return(0)#
  T00<-T01<-T10<-T11<-0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1 else#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1 else#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1 else T11<-T11+1#
  }#
  T0<-T00+T10; T1<-T01+T11#
  num<-T0*safe_log(1-alpha)+T1*safe_log(alpha)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+#
       T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1-sum(probvals[LRvals<LRobs])#
#
gen_markov <- function(n,alpha,phi=0.6){#
  p11<-phi; p01<-alpha*(1-phi)/(1-alpha)#
  X<-numeric(n); X[1]<-rbinom(1,1,alpha)#
  for(i in 2:n) X[i]<-rbinom(1,1,ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results_size<-data.frame(); results_power<-data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrind(n_,alpha_); LRvals<-dist$LR; probvals<-dist$prob#
    rej_ex<-rej_ch<-numeric(Nrep)#
    for(i in 1:Nrep){#
      X<-rbinom(n_,1,alpha_)#
      LR<-my_compute_LRind(X,alpha_)#
      p_ex<-get_pval_exact(LRvals,probvals,LR)#
      p_ch<-1-pchisq(LR,1)#
      rej_ex[i]<-(p_ex<0.05); rej_ch[i]<-(p_ch<0.05)#
    }#
    size_ex<-mean(rej_ex); se_ex<-sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch<-mean(rej_ch); se_ch<-sqrt(size_ch*(1-size_ch)/Nrep)#
    results_size<-rbind(results_size,data.frame(n=n_,alpha=alpha_,#
                      size_exact=size_ex,se_size_exact=se_ex,#
                      size_chi2=size_ch,se_size_chi2=se_ch))#
    pow_ex<-pow_ch<-numeric(Nrep)#
    for(i in 1:Nrep){#
      X<-gen_markov(n_,alpha_,0.6)#
      LR<-my_compute_LRind(X,alpha_)#
      p_ex<-get_pval_exact(LRvals,probvals,LR)#
      p_ch<-1-pchisq(LR,1)#
      pow_ex[i]<-(p_ex<0.05); pow_ch[i]<-(p_ch<0.05)#
    }#
    p_ex<-mean(pow_ex); se_pe<-sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch<-mean(pow_ch); se_pc<-sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power<-rbind(results_power,data.frame(n=n_,alpha=alpha_,#
                        power_exact=p_ex,se_power_exact=se_pe,#
                        power_chi2=p_ch,se_power_chi2=se_pc))#
  }#
}#
#
size_df<-pivot_longer(results_size,cols=c(size_exact,size_chi2),#
                      names_to=\"method\",values_to=\"value\")#
power_df<-pivot_longer(results_power,cols=c(power_exact,power_chi2),#
                       names_to=\"method\",values_to=\"value\")#
#
p_size<-ggplot(size_df,aes(factor(n),value,fill=method))+#
  geom_bar(stat=\"identity\",position=\"dodge\")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method==\"size_exact\",se_size_exact,se_size_chi2),#
                    ymax=value+1.96*ifelse(method==\"size_exact\",se_size_exact,se_size_chi2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~alpha,labeller=label_both)+#
  geom_hline(yintercept=0.05,colour=\"red\",linetype=\"dashed\")+#
  labs(x=\"n\",y=\"empirical size (α=5%)\")+theme_minimal()#
#
p_power<-ggplot(power_df,aes(factor(n),value,fill=method))+#
  geom_bar(stat=\"identity\",position=\"dodge\")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method==\"power_exact\",se_power_exact,se_power_chi2),#
                    ymax=value+1.96*ifelse(method==\"power_exact\",se_power_exact,se_power_chi2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~alpha,labeller=label_both)+#
  labs(x=\"n\",y=\"empirical power (φ=0.6)\")+theme_minimal()#
#
print(p_power/p_size)#
#
n_phi<-250; alpha_phi<-0.05; phi_list<-c(0.2,0.4,0.6,0.8,0.9)#
dist_phi<-fb_lrind(n_phi,alpha_phi); LRv<-dist_phi$LR; Pv<-dist_phi$prob#
phi_df<-data.frame()#
for(ph in phi_list){#
  ex<-ch<-numeric(Nrep)#
  for(i in 1:Nrep){#
    X<-gen_markov(n_phi,alpha_phi,ph)#
    LR<-my_compute_LRind(X,alpha_phi)#
    p_e<-get_pval_exact(LRv,Pv,LR)#
    p_c<-1-pchisq(LR,1)#
    ex[i]<-(p_e<0.05); ch[i]<-(p_c<0.05)#
  }#
  phi_df<-rbind(phi_df,#
    data.frame(phi=ph,method=\"exact\",power=mean(ex),#
               se=sqrt(mean(ex)*(1-mean(ex))/Nrep)),#
    data.frame(phi=ph,method=\"chi2\",power=mean(ch),#
               se=sqrt(mean(ch)*(1-mean(ch))/Nrep)))#
}#
ggplot(phi_df,aes(phi,power,color=method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin=power-1.96*se,ymax=power+1.96*se),width=0.02)+#
  scale_x_continuous(breaks=phi_list)+#
  labs(x=\"phi\",y=\"empirical power (n=250, α=0.05)\")+#
  theme_minimal()#
#
exception_df<-read.csv(\"/Users/chenyujian/Downloads/VaR_exceptions.csv\",row.names=1)#
alpha_vec<-c(0.05,0.025,0.01)#
colnames(exception_df)<-as.character(alpha_vec)#
n_win<-250; series_len<-nrow(exception_df)#
plot_df<-data.frame()#
for(a in alpha_vec){#
  X<-exception_df[[as.character(a)]]#
  dist<-fb_lrind(n_win,a); LRv<-dist$LR; Pv<-dist$prob#
  idx_max<-series_len-n_win+1#
  for(idx in 1:idx_max){#
    seg<-X[idx:(idx+n_win-1)]#
    LR<-my_compute_LRind(seg,a)#
    p_e<-get_pval_exact(LRv,Pv,LR)#
    p_c<-1-pchisq(LR,1)#
    plot_df<-rbind(plot_df,#
      data.frame(idx=idx,alpha=a,method=\"exact\",p_value=p_e),#
      data.frame(idx=idx,alpha=a,method=\"chi2\", p_value=p_c))#
  }#
}#
ggplot(plot_df,aes(idx,p_value,color=method))+geom_line()+#
  facet_wrap(~alpha,labeller=label_both,ncol=1)+#
  geom_hline(yintercept=0.05,linetype=\"dashed\",colour=\"red\")+#
  labs(x=\"window start index\",y=\"p-value\")+#
  theme_minimal()#
You said:#
再发一遍代码，现在生成不出结果#
ChatGPT said:#
r#
Copy#
Edit#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x > EPS ? x : EPS);}#
struct State{int la,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long enc(int la,int T00,int T10,int T01,int T11,int M){#
  long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double a,double pr=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int M=n+10;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[enc(0,0,0,0,0,M)]={0,0,0,0,0,1-a};#
  cur[enc(1,0,0,0,0,M)]={1,0,0,0,0,a};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<pr) continue;#
      int la=kv.second.la,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {State s=kv.second; if(la==0) s.T00++; else s.T10++; s.la=0; s.prob=p*(1-a);#
       auto &slot=nx[enc(0,s.T00,s.T10,s.T01,s.T11,M)]; if(slot.prob==0) slot=s; else slot.prob+=s.prob;}#
      {State s=kv.second; if(la==0) s.T01++; else s.T11++; s.la=1; s.prob=p*a;#
       auto &slot=nx[enc(1,s.T00,s.T10,s.T01,s.T11,M)]; if(slot.prob==0) slot=s; else slot.prob+=s.prob;}#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10,T1=T01+T11;#
      double num=T0*s_log(1-a)+T1*s_log(a);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01? (double)T01/s01:1.0;#
      double pi11=s11? (double)T11/s11:1.0;#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)+T10*s_log(1-pi11)+T11*s_log(pi11);#
      LR=-2*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &x,auto &y){return x.first<y.first;});#
  NumericVector LR,P; for(size_t i=0;i<vec.size();){ double v=vec[i].first,pr=0; while(i<vec.size()&&fabs(vec[i].first-v)<1e-15){pr+=vec[i].second;++i;} LR.push_back(v); P.push_back(pr);}#
  return List::create(Named("LR")=LR,Named("prob")=P);#
}')#
#
fb_lrind <- function(n,a) fb_lrind_fastcpp(n,a,1e-15)#
#
my_LR <- function(X,a){#
  n<-length(X); if(n<2) return(0)#
  T00<-T01<-T10<-T11<-0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1 else#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1 else#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1 else T11<-T11+1#
  }#
  T0<-T00+T10; T1<-T01+T11#
  num<-T0*safe_log(1-a)+T1*safe_log(a)#
  s01<-T00+T01; pi01<-if(s01) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11) T11/s11 else 1#
  den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
#
p_exact <- function(dist,LR) 1-sum(dist$prob[dist$LR<LR])#
#
gen_markov <- function(n,a,phi){#
  p11<-phi; p01<-a*(1-phi)/(1-a)#
  X<-numeric(n); X[1]<-rbinom(1,1,a)#
  for(i in 2:n) X[i]<-rbinom(1,1,ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_vec<-c(50,100,150,200,250,300,500)#
a_vec<-c(0.01,0.025,0.05)#
N<-2000#
size_tab<-power_tab<-data.frame()#
#
for(n in n_vec)for(a in a_vec){#
  dist<-fb_lrind(n,a)#
  LRv<-dist$LR; Pv<-dist$prob#
  ex_size<-ch_size<-numeric(N)#
  for(i in 1:N){#
    LR<-my_LR(rbinom(n,1,a),a)#
    ex_size[i]<-p_exact(dist,LR)<0.05#
    ch_size[i]<-(1-pchisq(LR,1))<0.05#
  }#
  size_tab<-rbind(size_tab,#
    data.frame(n,a,#
      size_exact=mean(ex_size),se_exact=sqrt(mean(ex_size)*(1-mean(ex_size))/N),#
      size_chi2=mean(ch_size),se_chi2=sqrt(mean(ch_size)*(1-mean(ch_size))/N)))#
  ex_pow<-ch_pow<-numeric(N)#
  for(i in 1:N){#
    LR<-my_LR(gen_markov(n,a,0.6),a)#
    ex_pow[i]<-p_exact(dist,LR)<0.05#
    ch_pow[i]<-(1-pchisq(LR,1))<0.05#
  }#
  power_tab<-rbind(power_tab,#
    data.frame(n,a,#
      pow_exact=mean(ex_pow),se_pe=sqrt(mean(ex_pow)*(1-mean(ex_pow))/N),#
      pow_chi2=mean(ch_pow),se_pc=sqrt(mean(ch_pow)*(1-mean(ch_pow))/N)))#
}#
#
p_size<-ggplot(pivot_longer(size_tab,cols=c(size_exact,size_chi2),names_to=\"m\",values_to=\"v\"),aes(factor(n),v,fill=m))+#
  geom_bar(stat=\"identity\",position=\"dodge\")+#
  geom_errorbar(aes(ymin=v-1.96*ifelse(m==\"size_exact\",se_exact,se_chi2),#
                    ymax=v+1.96*ifelse(m==\"size_exact\",se_exact,se_chi2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~a,labeller=label_both)+geom_hline(yintercept=0.05,col=\"red\",linetype=\"dashed\")+#
  labs(x=\"n\",y=\"empirical size\")+theme_minimal()#
#
p_pow<-ggplot(pivot_longer(power_tab,cols=c(pow_exact,pow_chi2),names_to=\"m\",values_to=\"v\"),aes(factor(n),v,fill=m))+#
  geom_bar(stat=\"identity\",position=\"dodge\")+#
  geom_errorbar(aes(ymin=v-1.96*ifelse(m==\"pow_exact\",se_pe,se_pc),#
                    ymax=v+1.96*ifelse(m==\"pow_exact\",se_pe,se_pc)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~a,labeller=label_both)+labs(x=\"n\",y=\"empirical power (phi=0.6)\")+theme_minimal()#
#
print(p_pow/p_size)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
# 安全对数，避免 log(0)#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
# 编译 C++ 函数 fb_lrind_fastcpp() ----#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){#
  return std::log( x > EPS ? x : EPS );#
}#
#
struct State {#
  int la, T00, T10, T01, T11;#
  double prob;#
};#
#
struct LLHash {#
  size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M = NMAX + 10LL;#
  long long S2 = M, S3 = S2*M, S4 = S3*M, S5 = S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n, double alpha=0.05, double prune=1e-15){#
  if(n < 1)#
    return List::create(Named("LR")=NumericVector(0),#
                        Named("prob")=NumericVector(0));#
#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> cur;#
#
  // 初始化状态 (第一条观测是 0 或 1)#
  {#
    State s0{0,0,0,0,0,1.0 - alpha};#
    cur[encode5(0,0,0,0,0,NMAX)] = s0;#
    State s1{1,0,0,0,0,alpha};#
    cur[encode5(1,0,0,0,0,NMAX)] = s1;#
  }#
#
  // 依次延展到 n 条观测序列#
  for(int k = 1; k < n; k++){#
    std::unordered_map<long long, State, LLHash> nx;#
    nx.reserve(cur.size()*2);#
#
    for(auto &kv : cur){#
      double p = kv.second.prob;#
      if(p < prune) continue; // prune 较小概率#
#
      int la = kv.second.la;#
      int T00 = kv.second.T00,#
          T10 = kv.second.T10,#
          T01 = kv.second.T01,#
          T11 = kv.second.T11;#
#
      // 下一个观测为 0#
      {#
        State ns = kv.second;#
        if(la == 0) ns.T00++; else ns.T10++;#
        ns.la   = 0;#
        ns.prob = p * (1.0 - alpha);#
        auto &slot = nx[encode5(ns.la, ns.T00, ns.T10, ns.T01, ns.T11, NMAX)];#
        if(slot.prob == 0) slot = ns; else slot.prob += ns.prob;#
      }#
      // 下一个观测为 1#
      {#
        State ns = kv.second;#
        if(la == 0) ns.T01++; else ns.T11++;#
        ns.la   = 1;#
        ns.prob = p * alpha;#
        auto &slot = nx[encode5(ns.la, ns.T00, ns.T10, ns.T01, ns.T11, NMAX)];#
        if(slot.prob == 0) slot = ns; else slot.prob += ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
#
  // 计算所有序列对应的 LR 并累加分布#
  std::unordered_map<double,double> dist;#
  for(auto &kv : cur){#
    double p = kv.second.prob;#
    if(p <= 0) continue;#
#
    int T00 = kv.second.T00,#
        T10 = kv.second.T10,#
        T01 = kv.second.T01,#
        T11 = kv.second.T11;#
#
    double LR = 0.0;#
    // n>1 时计算似然比#
    if(n > 1){#
      int T0 = T00 + T10, T1 = T01 + T11;#
      // 受限模型: Bernoulli( alpha ) 的对数似然#
      double num = T0 * s_log(1.0 - alpha) + T1 * s_log(alpha);#
#
      // 非受限模型：二状态马尔可夫#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01 > 0 ? (double)T01 / s01 : 1.0;#
      double pi11 = s11 > 0 ? (double)T11 / s11 : 1.0;#
      double den = T00*s_log(1.0 - pi01) + T01*s_log(pi01)#
                 + T10*s_log(1.0 - pi11) + T11*s_log(pi11);#
      LR = -2.0 * (num - den);#
    }#
    dist[LR] += p;#
  }#
#
  // 整理 LR 分布#
  std::vector<std::pair<double,double>> vec(dist.begin(), dist.end());#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){#
    return a.first < b.first;#
  });#
  NumericVector LRout, Pout;#
  for(size_t i=0; i<vec.size(); ){#
    double curLR = vec[i].first, curP = 0.0;#
    while(i < vec.size() && fabs(vec[i].first - curLR) < 1e-15){#
      curP += vec[i].second; ++i;#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout,#
                      Named("prob")=Pout);#
}#
')#
#
# 给 R 函数做一个包装，更简化调用#
fb_lrind <- function(n, alpha) fb_lrind_fastcpp(n, alpha, 1e-15)#
#
# 计算样本数据 X 在「原假设: Bernoulli(alpha)」下的 LR#
my_compute_LRind <- function(X, alpha){#
  n <- length(X)#
  if(n < 2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0 && X[i]==0) T00 <- T00+1 else#
    if(X[i-1]==0 && X[i]==1) T01 <- T01+1 else#
    if(X[i-1]==1 && X[i]==0) T10 <- T10+1 else T11 <- T11+1#
  }#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  # 受限模型 对数似然: (1-alpha) 和 alpha#
  num <- T0 * safe_log(1 - alpha) + T1 * safe_log(alpha)#
  # 非受限模型 (Markov) 的 MLE#
  s01 <- T00 + T01#
  pi01 <- if(s01 > 0) T01/s01 else 1#
  s11 <- T10 + T11#
  pi11 <- if(s11 > 0) T11/s11 else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2 * (num - den)#
}#
#
# 在精确分布中计算 p 值 (右尾)#
get_pval_exact <- function(LRvals, probvals, LRobs){#
  1 - sum(probvals[LRvals < LRobs])#
}#
#
# 生成二状态马尔可夫数据 (用来做 Power 分析)#
gen_markov <- function(n, alpha, phi=0.6){#
  # 状态转移:#
  # p(1->1) = phi#
  # p(0->1) = alpha*(1-phi)/(1-alpha) 使得边际为 alpha#
  p11 <- phi#
  p01 <- alpha*(1-phi)/(1-alpha)#
  X <- numeric(n)#
  X[1] <- rbinom(1, 1, alpha)#
  for(i in 2:n){#
    X[i] <- rbinom(1, 1, ifelse(X[i-1]==1, p11, p01))#
  }#
  X#
}#
#
# -------------------#
# I. 检验 size 与 power 的模拟#
# -------------------#
set.seed(123)#
n_list     <- c(50, 100, 150, 200, 250, 300, 500)#
alpha_list <- c(0.01, 0.025, 0.05)#
Nrep       <- 2000#
#
results_size  <- data.frame()#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    # 枚举出在 H0 下 LR 的精确分布#
    dist   <- fb_lrind(n_, alpha_)#
    LRvals <- dist$LR#
    probvals <- dist$prob#
#
    # (1) 尺度/size (拒真概率) - 在 H0 的数据下模拟#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      # 生成 i.i.d. Bernoulli(alpha_) 数据#
      X  <- rbinom(n_, 1, alpha_)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      rej_ex[i] <- (p_ex < 0.05)#
      rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex)#
    se_ex   <- sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch <- mean(rej_ch)#
    se_ch   <- sqrt(size_ch*(1-size_ch)/Nrep)#
    results_size <- rbind(results_size, data.frame(#
      n = n_,#
      alpha = alpha_,#
      size_exact    = size_ex,#
      se_size_exact = se_ex,#
      size_chi2     = size_ch,#
      se_size_chi2  = se_ch#
    ))#
#
    # (2) power - 在 H1(马尔可夫) 的数据下模拟#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X  <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR,1)#
      pow_ex[i] <- (p_ex < 0.05)#
      pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex  <- mean(pow_ex)#
    se_pe <- sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch  <- mean(pow_ch)#
    se_pc <- sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power <- rbind(results_power, data.frame(#
      n = n_,#
      alpha = alpha_,#
      power_exact    = p_ex,#
      se_power_exact = se_pe,#
      power_chi2     = p_ch,#
      se_power_chi2  = se_pc#
    ))#
  }#
}#
#
# 整理结果便于作图#
size_df <- pivot_longer(#
  results_size,#
  cols = c(size_exact, size_chi2),#
  names_to = "method",#
  values_to = "value"#
)#
#
power_df <- pivot_longer(#
  results_power,#
  cols = c(power_exact, power_chi2),#
  names_to = "method",#
  values_to = "value"#
)#
#
# 作图：size#
p_size <- ggplot(size_df, aes(factor(n), value, fill=method)) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = value - 1.96 * ifelse(method=="size_exact", se_size_exact, se_size_chi2),#
      ymax = value + 1.96 * ifelse(method=="size_exact", se_size_exact, se_size_chi2)#
    ),#
    position = position_dodge(0.9), width = 0.25#
  ) +#
  facet_wrap(~alpha, labeller = label_both) +#
  geom_hline(yintercept=0.05, colour="red", linetype="dashed") +#
  labs(x="n", y="empirical size (α=5%)") +#
  theme_minimal()#
#
# 作图：power#
p_power <- ggplot(power_df, aes(factor(n), value, fill=method)) +#
  geom_bar(stat="identity", position="dodge") +#
  geom_errorbar(#
    aes(#
      ymin = value - 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2),#
      ymax = value + 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2)#
    ),#
    position = position_dodge(0.9),#
    width = 0.25#
  ) +#
  facet_wrap(~alpha, labeller = label_both) +#
  labs(x="n", y="empirical power (φ=0.6)") +#
  theme_minimal()#
#
# 展示 power / size#
print(p_power / p_size)
n_phi <- 250#
alpha_phi <- 0.05#
phi_list <- c(0.2, 0.4, 0.6, 0.8, 0.9)#
dist_phi <- fb_lrind(n_phi, alpha_phi)#
LRv <- dist_phi$LR#
Pv  <- dist_phi$prob#
#
phi_df <- data.frame()#
Nrep   <- 2000#
#
for(ph in phi_list){#
  ex <- ch <- numeric(Nrep)#
  for(i in 1:Nrep){#
    X <- gen_markov(n_phi, alpha_phi, ph)#
    LR <- my_compute_LRind(X, alpha_phi)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 1)#
    ex[i] <- (p_e < 0.05)#
    ch[i] <- (p_c < 0.05)#
  }#
  phi_df <- rbind(#
    phi_df,#
    data.frame(#
      phi=ph, method="exact", power=mean(ex),#
      se = sqrt(mean(ex)*(1-mean(ex))/Nrep)#
    ),#
    data.frame(#
      phi=ph, method="chi2", power=mean(ch),#
      se = sqrt(mean(ch)*(1-mean(ch))/Nrep)#
    )#
  )#
}#
#
ggplot(phi_df, aes(phi, power, color=method)) +#
  geom_line() + geom_point() +#
  geom_errorbar(#
    aes(ymin=power - 1.96*se, ymax=power + 1.96*se),#
    width=0.02#
  ) +#
  scale_x_continuous(breaks=phi_list) +#
  labs(x="phi", y="empirical power (n=250, α=0.05)") +#
  theme_minimal()
phi_df
ggplot(phi_df, aes(phi, power, color=method))
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    cur[encode5(0,0,0,0,0,NMAX)]=s0;#
    State s1{1,0,0,0,0,alpha};#
    cur[encode5(1,0,0,0,0,NMAX)]=s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double num=T0*s_log(1.0-alpha)+T1*s_log(alpha);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      LR=-2.0*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first,curP=0.0;#
    while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha) fb_lrind_fastcpp(n, alpha, 1e-15)#
#
my_compute_LRind <- function(X, alpha){#
  n<-length(X); if(n<2) return(0)#
  T00<-T01<-T10<-T11<-0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1 else#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1 else#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1 else T11<-T11+1#
  }#
  T0<-T00+T10; T1<-T01+T11#
  num<-T0*safe_log(1-alpha)+T1*safe_log(alpha)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1 - sum(probvals[LRvals<LRobs])#
#
gen_markov <- function(n,alpha,phi=0.6){#
  p11<-phi; p01<-alpha*(1-phi)/(1-alpha)#
  X<-numeric(n); X[1]<-rbinom(1,1,alpha)#
  for(i in 2:n) X[i]<-rbinom(1,1,ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results_size<-data.frame(); results_power<-data.frame()#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrind(n_,alpha_)#
    LRvals<-dist$LR; probvals<-dist$prob#
    rej_ex<-rej_ch<-numeric(Nrep)#
    for(i in 1:Nrep){#
      X<-rbinom(n_,1,alpha_)#
      LR<-my_compute_LRind(X,alpha_)#
      p_ex<-get_pval_exact(LRvals,probvals,LR)#
      p_ch<-1-pchisq(LR,2)#
      rej_ex[i]<-(p_ex<0.05); rej_ch[i]<-(p_ch<0.05)#
    }#
    size_ex<-mean(rej_ex)#
    se_ex<-sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch<-mean(rej_ch)#
    se_ch<-sqrt(size_ch*(1-size_ch)/Nrep)#
    results_size<-rbind(results_size,data.frame(#
      n=n_,alpha=alpha_,size_exact=size_ex,se_size_exact=se_ex,#
      size_chi2=size_ch,se_size_chi2=se_ch))#
    pow_ex<-pow_ch<-numeric(Nrep)#
    for(i in 1:Nrep){#
      X<-gen_markov(n_,alpha_,0.6)#
      LR<-my_compute_LRind(X,alpha_)#
      p_ex<-get_pval_exact(LRvals,probvals,LR)#
      p_ch<-1-pchisq(LR,2)#
      pow_ex[i]<-(p_ex<0.05); pow_ch[i]<-(p_ch<0.05)#
    }#
    p_ex<-mean(pow_ex)#
    se_pe<-sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch<-mean(pow_ch)#
    se_pc<-sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power<-rbind(results_power,data.frame(#
      n=n_,alpha=alpha_,power_exact=p_ex,se_power_exact=se_pe,#
      power_chi2=p_ch,se_power_chi2=se_pc))#
  }#
}#
#
size_df<-pivot_longer(results_size,cols=c(size_exact,size_chi2),#
                      names_to="method",values_to="value")#
power_df<-pivot_longer(results_power,cols=c(power_exact,power_chi2),#
                       names_to="method",values_to="value")#
#
p_size<-ggplot(size_df,aes(factor(n),value,fill=method))+#
  geom_bar(stat="identity",position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2),#
                    ymax=value+1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~alpha,labeller=label_both)+#
  geom_hline(yintercept=0.05,colour="red",linetype="dashed")+#
  labs(x="n",y="empirical size (α=5%)")+#
  theme_minimal()#
#
p_power<-ggplot(power_df,aes(factor(n),value,fill=method))+#
  geom_bar(stat="identity",position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2),#
                    ymax=value+1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~alpha,labeller=label_both)+#
  labs(x="n",y="empirical power (φ=0.6)")+#
  theme_minimal()#
#
print(p_power/p_size)
n_phi<-250; alpha_phi<-0.05; phi_list<-c(0.2,0.4,0.6,0.8,0.9)#
dist_phi<-fb_lrind(n_phi,alpha_phi); LRv<-dist_phi$LR; Pv<-dist_phi$prob#
phi_df<-data.frame()#
for(ph in phi_list){#
  ex<-ch<-numeric(Nrep)#
  for(i in 1:Nrep){#
    X<-gen_markov(n_phi,alpha_phi,ph)#
    LR<-my_compute_LRind(X,alpha_phi)#
    p_e<-get_pval_exact(LRv,Pv,LR)#
    p_c<-1-pchisq(LR,2)#
    ex[i]<-(p_e<0.05); ch[i]<-(p_c<0.05)#
  }#
  phi_df<-rbind(phi_df,#
               data.frame(phi=ph,method="exact",power=mean(ex),#
                          se=sqrt(mean(ex)*(1-mean(ex))/Nrep)),#
               data.frame(phi=ph,method="chi2",power=mean(ch),#
                          se=sqrt(mean(ch)*(1-mean(ch))/Nrep)))#
}#
#
ggplot(phi_df,aes(phi,power,color=method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin=power-1.96*se,ymax=power+1.96*se),width=0.02)+#
  scale_x_continuous(breaks=phi_list)+#
  labs(x="phi",y="empirical power (n=250, α=0.05)")+#
  theme_minimal()
exception_df<-read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv",row.names=1)#
alpha_vec<-c(0.05,0.025,0.01)#
colnames(exception_df)<-as.character(alpha_vec)#
n_win<-250#
series_len<-nrow(exception_df)#
plot_df<-data.frame()#
for(a in alpha_vec){#
  X<-exception_df[[as.character(a)]]#
  dist<-fb_lrind(n_win,a)#
  LRv<-dist$LR#
  Pv<-dist$prob#
  idx_max<-series_len-n_win+1#
  for(idx in 1:idx_max){#
    seg<-X[idx:(idx+n_win-1)]#
    LR<-my_compute_LRind(seg,a)#
    p_e<-get_pval_exact(LRv,Pv,LR)#
    p_c<-1-pchisq(LR,2)#
    plot_df<-rbind(plot_df,#
                   data.frame(idx=idx,alpha=a,method="exact",p_value=p_e),#
                   data.frame(idx=idx,alpha=a,method="chi2",p_value=p_c))#
  }#
}#
ggplot(plot_df,aes(idx,p_value,color=method))+geom_line()+#
  facet_wrap(~alpha,labeller=label_both,ncol=1)+#
  geom_hline(yintercept=0.05,linetype="dashed",colour="red")+#
  labs(x="window start index",y="p-value")+#
  theme_minimal()
# 手动 Monte-Carlo 基准，直接数 LR > q(chi2, .95)#
n <- 300; alpha <- 0.01; B <- 5e5#
thr <- qchisq(.95, 2)#
cnt <- 0#
for(i in 1:B){#
  x <- rbinom(n,1,alpha)#
  LR <- my_compute_LRind(x, alpha)#
  if(LR > thr) cnt <- cnt+1#
}#
cat("empirical chi2 size =", cnt/B)  # ≈ 6-7 %
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    cur[encode5(0,0,0,0,0,NMAX)]=s0;#
    State s1{1,0,0,0,0,alpha};#
    cur[encode5(1,0,0,0,0,NMAX)]=s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double num=T0*s_log(1.0-alpha)+T1*s_log(alpha);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      LR=-2.0*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first,curP=0.0;#
    while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha) fb_lrind_fastcpp(n, alpha, 1e-15)#
#
my_compute_LRind <- function(X, alpha){#
  n<-length(X); if(n<2) return(0)#
  T00<-T01<-T10<-T11<-0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00<-T00+1 else#
    if(X[i-1]==0&&X[i]==1) T01<-T01+1 else#
    if(X[i-1]==1&&X[i]==0) T10<-T10+1 else T11<-T11+1#
  }#
  T0<-T00+T10; T1<-T01+T11#
  num<-T0*safe_log(1-alpha)+T1*safe_log(alpha)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
#
get_pval_exact <- function(LRvals,probvals,LRobs) 1 - sum(probvals[LRvals<LRobs])#
#
gen_markov <- function(n,alpha,phi=0.6){#
  p11<-phi; p01<-alpha*(1-phi)/(1-alpha)#
  X<-numeric(n); X[1]<-rbinom(1,1,alpha)#
  for(i in 2:n) X[i]<-rbinom(1,1,ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list<-c(50,100,150,200,250,300,500)#
alpha_list<-c(0.01,0.025,0.05)#
Nrep<-2000#
results_size<-data.frame(); results_power<-data.frame()#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist<-fb_lrind(n_,alpha_)#
    LRvals<-dist$LR; probvals<-dist$prob#
    rej_ex<-rej_ch<-numeric(Nrep)#
    for(i in 1:Nrep){#
      X<-rbinom(n_,1,alpha_)#
      LR<-my_compute_LRind(X,alpha_)#
      p_ex<-get_pval_exact(LRvals,probvals,LR)#
      p_ch<-1-pchisq(LR,2)#
      rej_ex[i]<-(p_ex<0.05); rej_ch[i]<-(p_ch<0.05)#
    }#
    size_ex<-mean(rej_ex)#
    se_ex<-sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch<-mean(rej_ch)#
    se_ch<-sqrt(size_ch*(1-size_ch)/Nrep)#
    results_size<-rbind(results_size,data.frame(#
      n=n_,alpha=alpha_,size_exact=size_ex,se_size_exact=se_ex,#
      size_chi2_2=size_ch,se_size_chi2_2=se_ch))#
    pow_ex<-pow_ch<-numeric(Nrep)#
    for(i in 1:Nrep){#
      X<-gen_markov(n_,alpha_,0.6)#
      LR<-my_compute_LRind(X,alpha_)#
      p_ex<-get_pval_exact(LRvals,probvals,LR)#
      p_ch<-1-pchisq(LR,2)#
      pow_ex[i]<-(p_ex<0.05); pow_ch[i]<-(p_ch<0.05)#
    }#
    p_ex<-mean(pow_ex)#
    se_pe<-sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch<-mean(pow_ch)#
    se_pc<-sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power<-rbind(results_power,data.frame(#
      n=n_,alpha=alpha_,power_exact=p_ex,se_power_exact=se_pe,#
      power_chi2_2=p_ch,se_power_chi2_2=se_pc))#
  }#
}#
#
size_df<-pivot_longer(results_size,cols=c(size_exact,size_chi2_2),#
                      names_to="method",values_to="value")#
size_df$method[size_df$method=="size_chi2_2"] <- "size_chi2(2)"#
power_df<-pivot_longer(results_power,cols=c(power_exact,power_chi2_2),#
                       names_to="method",values_to="value")#
power_df$method[power_df$method=="power_chi2_2"] <- "power_chi2(2)"#
#
p_size<-ggplot(size_df,aes(factor(n),value,fill=method))+#
  geom_bar(stat="identity",position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2_2),#
                    ymax=value+1.96*ifelse(method=="size_exact",se_size_exact,se_size_chi2_2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~alpha,labeller=label_both)+#
  geom_hline(yintercept=0.05,colour="red",linetype="dashed")+#
  labs(x="n",y="empirical size (α=5%)")+#
  theme_minimal()#
#
p_power<-ggplot(power_df,aes(factor(n),value,fill=method))+#
  geom_bar(stat="identity",position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2_2),#
                    ymax=value+1.96*ifelse(method=="power_exact",se_power_exact,se_power_chi2_2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~alpha,labeller=label_both)+#
  labs(x="n",y="empirical power (φ=0.6)")+#
  theme_minimal()#
#
print(p_power/p_size)
n_phi<-250#
alpha_phi<-0.05#
phi_list<-c(0.2,0.4,0.6,0.8,0.9)#
dist_phi<-fb_lrind(n_phi,alpha_phi)#
LRv<-dist_phi$LR#
Pv<-dist_phi$prob#
phi_df<-data.frame()#
for(ph in phi_list){#
  ex<-ch<-numeric(Nrep)#
  for(i in 1:Nrep){#
    X<-gen_markov(n_phi,alpha_phi,ph)#
    LR<-my_compute_LRind(X,alpha_phi)#
    p_e<-get_pval_exact(LRv,Pv,LR)#
    p_c<-1-pchisq(LR,2)#
    ex[i]<-(p_e<0.05)#
    ch[i]<-(p_c<0.05)#
  }#
  phi_df<-rbind(phi_df,#
               data.frame(phi=ph,method="exact",power=mean(ex),#
                          se=sqrt(mean(ex)*(1-mean(ex))/Nrep)),#
               data.frame(phi=ph,method="chi2(2)",power=mean(ch),#
                          se=sqrt(mean(ch)*(1-mean(ch))/Nrep)))#
}#
#
ggplot(phi_df,aes(phi,power,color=method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin=power-1.96*se,ymax=power+1.96*se),width=0.02)+#
  scale_x_continuous(breaks=phi_list)+#
  labs(x="phi",y="empirical power (n=250, α=0.05)")+#
  theme_minimal()
exception_df<-read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv",row.names=1)#
alpha_vec<-c(0.05,0.025,0.01)#
colnames(exception_df)<-as.character(alpha_vec)#
n_win<-250#
series_len<-nrow(exception_df)#
plot_df<-data.frame()#
for(a in alpha_vec){#
  X<-exception_df[[as.character(a)]]#
  dist<-fb_lrind(n_win,a)#
  LRv<-dist$LR#
  Pv<-dist$prob#
  idx_max<-series_len-n_win+1#
  for(idx in 1:idx_max){#
    seg<-X[idx:(idx+n_win-1)]#
    LR<-my_compute_LRind(seg,a)#
    p_e<-get_pval_exact(LRv,Pv,LR)#
    p_c<-1-pchisq(LR,2)#
    plot_df<-rbind(plot_df,#
                   data.frame(idx=idx,alpha=a,method="exact",p_value=p_e),#
                   data.frame(idx=idx,alpha=a,method="chi2(2)",p_value=p_c))#
  }#
}#
ggplot(plot_df,aes(idx,p_value,color=method))+#
  geom_line()+#
  facet_wrap(~alpha,labeller=label_both,ncol=1)+#
  geom_hline(yintercept=0.05,linetype="dashed",colour="red")+#
  labs(x="window start index",y="p-value")+#
  theme_minimal()
# Empirical comparison of LR_ind vs  χ²(1)  #
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    cur[encode5(0,0,0,0,0,NMAX)]=s0;#
    State s1{1,0,0,0,0,alpha};#
    cur[encode5(1,0,0,0,0,NMAX)]=s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat = (double)T1 / (double)(n-1);#
      double num = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      LR=-2.0*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first,curP=0.0;#
    while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha) fb_lrind_fastcpp(n, alpha, 1e-15)#
#
my_compute_LRind <- function(X, alpha){#
  n <- length(X); if(n < 2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00 <- T00 + 1 else#
    if(X[i-1]==0&&X[i]==1) T01 <- T01 + 1 else#
    if(X[i-1]==1&&X[i]==0) T10 <- T10 + 1 else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10; T1 <- T01 + T11#
  pHat <- if(n > 1) T1 / (n - 1) else 0#
  num  <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  s01 <- T00 + T01; pi01 <- if(s01 > 0) T01/s01 else 1#
  s11 <- T10 + T11; pi11 <- if(s11 > 0) T11/s11 else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
gen_markov <- function(n, alpha, phi = 0.6){#
  p11 <- phi; p01 <- alpha*(1 - phi)/(1 - alpha)#
  X <- numeric(n); X[1] <- rbinom(1, 1, alpha)#
  for(i in 2:n) X[i] <- rbinom(1, 1, ifelse(X[i-1]==1, p11, p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results_size <- data.frame(); results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrind(n_, alpha_)#
    LRvals <- dist$LR; probvals <- dist$prob#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      rej_ex[i] <- (p_ex < 0.05); rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex)#
    se_ex <- sqrt(size_ex*(1 - size_ex)/Nrep)#
    size_ch <- mean(rej_ch)#
    se_ch <- sqrt(size_ch*(1 - size_ch)/Nrep)#
    results_size <- rbind(results_size,#
      data.frame(n = n_, alpha = alpha_, size_exact = size_ex, se_size_exact = se_ex,#
                 size_chi2_1 = size_ch, se_size_chi2_1 = se_ch))#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      pow_ex[i] <- (p_ex < 0.05); pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex <- mean(pow_ex)#
    se_pe <- sqrt(p_ex*(1 - p_ex)/Nrep)#
    p_ch <- mean(pow_ch)#
    se_pc <- sqrt(p_ch*(1 - p_ch)/Nrep)#
    results_power <- rbind(results_power,#
      data.frame(n = n_, alpha = alpha_, power_exact = p_ex, se_power_exact = se_pe,#
                 power_chi2_1 = p_ch, se_power_chi2_1 = se_pc))#
  }#
}#
#
size_df <- pivot_longer(results_size, cols = c(size_exact, size_chi2_1),#
                        names_to = "method", values_to = "value")#
size_df$method[size_df$method == "size_chi2_1"] <- "size_chi2(1)"#
#
power_df <- pivot_longer(results_power, cols = c(power_exact, power_chi2_1),#
                         names_to = "method", values_to = "value")#
power_df$method[power_df$method == "power_chi2_1"] <- "power_chi2(1)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill = method))+#
  geom_bar(stat = "identity", position = "dodge")+#
  geom_errorbar(aes(ymin = value - 1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1),#
                    ymax = value + 1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_wrap(~alpha, labeller = label_both)+#
  geom_hline(yintercept = 0.05, colour = "red", linetype = "dashed")+#
  labs(x = "n", y = "empirical size (α=5%)")+#
  theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill = method))+#
  geom_bar(stat = "identity", position = "dodge")+#
  geom_errorbar(aes(ymin = value - 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1),#
                    ymax = value + 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_wrap(~alpha, labeller = label_both)+#
  labs(x = "n", y = "empirical power (φ=0.6)")+#
  theme_minimal()#
#
print(p_power / p_size)
## Power vs. phi#
n_phi <- 250#
alpha_phi <- 0.05#
phi_list <- c(0.2,0.4,0.6,0.8,0.9)#
dist_phi <- fb_lrind(n_phi, alpha_phi)#
LRv <- dist_phi$LR; Pv <- dist_phi$prob#
phi_df <- data.frame()#
for(ph in phi_list){#
  ex <- ch <- numeric(Nrep)#
  for(i in 1:Nrep){#
    X <- gen_markov(n_phi, alpha_phi, ph)#
    LR <- my_compute_LRind(X, alpha_phi)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 1)#
    ex[i] <- (p_e < 0.05)#
    ch[i] <- (p_c < 0.05)#
  }#
  phi_df <- rbind(phi_df,#
    data.frame(phi = ph, method = "exact",   power = mean(ex),#
               se = sqrt(mean(ex)*(1 - mean(ex))/Nrep)),#
    data.frame(phi = ph, method = "chi2(1)", power = mean(ch),#
               se = sqrt(mean(ch)*(1 - mean(ch))/Nrep)))#
}#
#
ggplot(phi_df, aes(phi, power, color = method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin = power - 1.96*se, ymax = power + 1.96*se), width = 0.02)+#
  scale_x_continuous(breaks = phi_list)+#
  labs(x = "phi", y = "empirical power (n=250, α=0.05)")+#
  theme_minimal()
## Rolling-window p-values on real data#
exception_df <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names = 1)#
alpha_vec <- c(0.05,0.025,0.01)#
colnames(exception_df) <- as.character(alpha_vec)#
n_win <- 250#
series_len <- nrow(exception_df)#
plot_df <- data.frame()#
for(a in alpha_vec){#
  X <- exception_df[[as.character(a)]]#
  dist <- fb_lrind(n_win, a)#
  LRv <- dist$LR; Pv <- dist$prob#
  idx_max <- series_len - n_win + 1#
  for(idx in 1:idx_max){#
    seg <- X[idx:(idx + n_win - 1)]#
    LR <- my_compute_LRind(seg, a)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 1)#
    plot_df <- rbind(plot_df,#
      data.frame(idx = idx, alpha = a, method = "exact",   p_value = p_e),#
      data.frame(idx = idx, alpha = a, method = "chi2(1)", p_value = p_c))#
  }#
}#
ggplot(plot_df, aes(idx, p_value, color = method))+#
  geom_line()+#
  facet_wrap(~alpha, labeller = label_both, ncol = 1)+#
  geom_hline(yintercept = 0.05, linetype = "dashed", colour = "red")+#
  labs(x = "window start index", y = "p-value")+#
  theme_minimal()
exception_df <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names = 1)#
alpha_vec <- c(0.05,0.025,0.01)#
colnames(exception_df) <- as.character(alpha_vec)#
n_win <- 250#
series_len <- nrow(exception_df)#
plot_df <- data.frame()#
for(a in alpha_vec){#
  X <- exception_df[[as.character(a)]]#
  dist <- fb_lrind(n_win, a)#
  LRv <- dist$LR; Pv <- dist$prob#
  idx_max <- series_len - n_win + 1#
  for(idx in 1:idx_max){#
    seg <- X[idx:(idx + n_win - 1)]#
    LR <- my_compute_LRind(seg, a)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 1)#
    plot_df <- rbind(plot_df,#
      data.frame(idx = idx, alpha = a, method = "exact",   p_value = p_e),#
      data.frame(idx = idx, alpha = a, method = "chi2(1)", p_value = p_c))#
  }#
}#
ggplot(plot_df, aes(idx, p_value, color = method))+#
  geom_line()+#
  facet_wrap(~alpha, labeller = label_both, ncol = 1)+#
  geom_hline(yintercept = 0.05, linetype = "dashed", colour = "red")+#
  labs(x = "window start index", y = "p-value")+#
  theme_minimal()
# Empirical Comparison on simulated data: #
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    cur[encode5(0,0,0,0,0,NMAX)]=s0;#
    State s1{1,0,0,0,0,alpha};#
    cur[encode5(1,0,0,0,0,NMAX)]=s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat = (double)T1 / (double)(n-1);#
      double num = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      LR=-2.0*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first,curP=0.0;#
    while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha) fb_lrind_fastcpp(n, alpha, 1e-15)#
#
my_compute_LRind <- function(X, alpha){#
  n <- length(X); if(n < 2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00 <- T00 + 1 else#
    if(X[i-1]==0&&X[i]==1) T01 <- T01 + 1 else#
    if(X[i-1]==1&&X[i]==0) T10 <- T10 + 1 else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10; T1 <- T01 + T11#
  pHat <- if(n > 1) T1 / (n - 1) else 0#
  num  <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  s01 <- T00 + T01; pi01 <- if(s01 > 0) T01/s01 else 1#
  s11 <- T10 + T11; pi11 <- if(s11 > 0) T11/s11 else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
gen_markov <- function(n, alpha, phi = 0.6){#
  p11 <- phi; p01 <- alpha*(1 - phi)/(1 - alpha)#
  X <- numeric(n); X[1] <- rbinom(1, 1, alpha)#
  for(i in 2:n) X[i] <- rbinom(1, 1, ifelse(X[i-1]==1, p11, p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results_size <- data.frame(); results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrind(n_, alpha_)#
    LRvals <- dist$LR; probvals <- dist$prob#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      rej_ex[i] <- (p_ex < 0.05); rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex)#
    se_ex <- sqrt(size_ex*(1 - size_ex)/Nrep)#
    size_ch <- mean(rej_ch)#
    se_ch <- sqrt(size_ch*(1 - size_ch)/Nrep)#
    results_size <- rbind(results_size,#
      data.frame(n = n_, alpha = alpha_, size_exact = size_ex, se_size_exact = se_ex,#
                 size_chi2_1 = size_ch, se_size_chi2_1 = se_ch))#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      pow_ex[i] <- (p_ex < 0.05); pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex <- mean(pow_ex)#
    se_pe <- sqrt(p_ex*(1 - p_ex)/Nrep)#
    p_ch <- mean(pow_ch)#
    se_pc <- sqrt(p_ch*(1 - p_ch)/Nrep)#
    results_power <- rbind(results_power,#
      data.frame(n = n_, alpha = alpha_, power_exact = p_ex, se_power_exact = se_pe,#
                 power_chi2_1 = p_ch, se_power_chi2_1 = se_pc))#
  }#
}#
#
size_df <- pivot_longer(results_size, cols = c(size_exact, size_chi2_1),#
                        names_to = "method", values_to = "value")#
size_df$method[size_df$method == "size_chi2_1"] <- "size_chi2(1)"#
#
power_df <- pivot_longer(results_power, cols = c(power_exact, power_chi2_1),#
                         names_to = "method", values_to = "value")#
power_df$method[power_df$method == "power_chi2_1"] <- "power_chi2(1)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill = method))+#
  geom_bar(stat = "identity", position = "dodge")+#
  geom_errorbar(aes(ymin = value - 1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1),#
                    ymax = value + 1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_wrap(~alpha, labeller = label_both)+#
  geom_hline(yintercept = 0.05, colour = "red", linetype = "dashed")+#
  labs(x = "n", y = "empirical size (α=5%)")+#
  theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill = method))+#
  geom_bar(stat = "identity", position = "dodge")+#
  geom_errorbar(aes(ymin = value - 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1),#
                    ymax = value + 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_wrap(~alpha, labeller = label_both)+#
  labs(x = "n", y = "empirical power (φ=0.6)")+#
  theme_minimal()#
#
print(p_power / p_size)
library(Rcpp)#
library(stats)#
#
safe_log <- function(x){#
  eps <- 1e-15#
  log(ifelse(x > eps, x, eps))#
}#
#
LRuc_count <- function(x, n, p){#
  eps  <- 1e-15#
  p_   <- max(min(p, 1 - eps), eps)#
  phat <- if (x == 0) 0 else if (x == n) 1 else x / n#
  ph_  <- max(min(phat, 1 - eps), eps)#
  num  <- x * safe_log(p_) + (n - x) * safe_log(1 - p_)#
  den  <- x * safe_log(ph_) + (n - x) * safe_log(1 - ph_)#
  -2 * (num - den)#
}#
#
LRind_counts_loc <- function(T00, T10, T01, T11, n){#
  if (n <= 1) return(0)#
  T0   <- T00 + T10#
  T1   <- T01 + T11#
  pHat <- if ((n - 1) > 0) T1 / (n - 1) else 0#
  num  <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
  pi01 <- if ((T00 + T01) > 0) T01 / (T00 + T01) else 1#
  pi11 <- if ((T10 + T11) > 0) T11 / (T10 + T11) else 1#
  den  <- T00 * safe_log(1 - pi01) + T01 * safe_log(pi01) +#
          T10 * safe_log(1 - pi11) + T11 * safe_log(pi11)#
  -2 * (num - den)#
}#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log(x > EPS ? x : EPS); }#
#
struct State{#
  int la, c1, T00, T10, T01, T11;#
  double prob;#
};#
#
struct LLHash{#
  std::size_t operator()(long long x) const{ return std::hash<long long>()(x); }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long S2 = NMAX + 10;#
  long long S3 = S2 * (NMAX + 10);#
  long long S4 = S3 * (NMAX + 10);#
  long long S5 = S4 * (NMAX + 10);#
  long long S6 = S5 * (NMAX + 10);#
  return (long long)la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15){#
  if(n < 1) return List::create(_["LR"]=NumericVector(0), _["prob"]=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long, State, LLHash> cur;#
#
  State s0{0,0,0,0,0,0,1.0-alpha};#
  cur[encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX)] = s0;#
  State s1{1,1,0,0,0,0,alpha};#
  cur[encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX)] = s1;#
#
  for(int k=1; k<n; ++k){#
    std::unordered_map<long long, State, LLHash> nxt;#
    nxt.reserve(cur.size()*2);#
    for(auto &kv: cur){#
      if(kv.second.prob < prune_threshold) continue;#
      const State &st = kv.second;#
      double p0 = 1.0 - alpha, p1 = alpha;#
#
      State ns = st;#
      (ns.la==0 ? ns.T00 : ns.T10)++; ns.la = 0; ns.prob = st.prob * p0;#
      long long c = encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
      nxt[c].prob += ns.prob; if(nxt[c].prob == ns.prob) nxt[c] = ns;#
#
      ns = st;#
      (ns.la==0 ? ns.T01 : ns.T11)++; ns.c1++; ns.la = 1; ns.prob = st.prob * p1;#
      c = encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
      nxt[c].prob += ns.prob; if(nxt[c].prob == ns.prob) nxt[c] = ns;#
    }#
    cur.clear();#
    for(auto &kv: nxt) if(kv.second.prob >= prune_threshold) cur[kv.first] = kv.second;#
  }#
#
  std::unordered_map<double,double> LRmap;#
  for(auto &kv: cur){#
    if(kv.second.prob <= 0.0) continue;#
    const State &st = kv.second;#
    int c1=st.c1, T00=st.T00, T10=st.T10, T01=st.T01, T11=st.T11;#
#
    double phat = c1==0 ? 0.0 : (c1==n ? 1.0 : (double)c1/n);#
    double p_ = std::max(std::min(alpha,1.0-EPS),EPS);#
    double ph_= std::max(std::min(phat ,1.0-EPS),EPS);#
    double lruc = -2.0*( c1*std::log(p_)+(n-c1)*std::log(1.0-p_)#
                       - c1*std::log(ph_)-(n-c1)*std::log(1.0-ph_) );#
#
    double lrind = 0.0;#
    if(n > 1){#
      int T0=T00+T10, T1=T01+T11;#
      double pH = (double)T1/(n-1);#
      double num = T0*s_log(1.0-pH)+T1*s_log(pH);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den = T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind = -2.0*(num - den);#
    }#
    LRmap[lruc + lrind] += st.prob;#
  }#
#
  std::vector<std::pair<double,double>> v(LRmap.begin(), LRmap.end());#
  std::sort(v.begin(), v.end(), [](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR, Pr;#
  if(!v.empty()){#
    double curLR=v[0].first, curP=v[0].second;#
    for(size_t i=1;i<v.size();++i){#
      if(std::fabs(v[i].first-curLR)<1e-15) curP += v[i].second;#
      else{ LR.push_back(curLR); Pr.push_back(curP); curLR=v[i].first; curP=v[i].second; }#
    }#
    LR.push_back(curLR); Pr.push_back(curP);#
  }#
  return List::create(_["LR"]=LR, _["prob"]=Pr);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15){#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
main <- function(){#
  alpha_test <- 0.05#
  for(n_ in c(15,100,500,1000)){#
    t0 <- proc.time()#
    res <- fb_lrcc(n_, alpha_test)#
    dt <- proc.time() - t0#
    cat(sprintf("\n=== n = %d, alpha = %.3f ===\n", n_, alpha_test))#
    cat(sprintf("time = %.3fs, #LR = %d, sum(prob) = %.6f\n",#
                dt["elapsed"], length(res$LR), sum(res$prob)))#
  }#
}#
main()
## LRcc#
# Forward Algorithm#
#
library(Rcpp)#
#
# ----- safe_log with EPS protection -----#
safe_log <- function(x){#
  eps <- 1e-15#
  log(ifelse(x > eps, x, eps))#
}#
#
LRuc_count <- function(x,n,p) {#
  if(x==0) {#
    phat <- 0#
  } else if(x==n) {#
    phat <- 1#
  } else {#
    phat <- x/n#
  }#
  eps <- 1e-15#
  p_ <- max(min(p,1-eps),eps)#
  ph_ <- max(min(phat,1-eps),eps)#
  num <- x*safe_log(p_) + (n - x)*safe_log(1 - p_)#
  den <- x*safe_log(ph_) + (n - x)*safe_log(1 - ph_)#
  -2*(num - den)#
}#
#
LRind_counts_loc <- function(T00,T10,T01,T11,n) {#
  if(n<=1) return(0)#
  T0 <- T00 + T10#
  T1 <- T01 + T11#
  pHat <- if((n-1)>0) T1/(n-1) else 0#
  num <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){#
  return std::log( x > EPS ? x : EPS );#
}#
#
struct State {#
  int la;  #
  int c1;  #
  int T00; #
  int T10; #
  int T01; #
  int T11; #
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long SHIFT2 = NMAX + 10;#
  long long SHIFT3 = SHIFT2*(NMAX + 10);#
  long long SHIFT4 = SHIFT3*(NMAX + 10);#
  long long SHIFT5 = SHIFT4*(NMAX + 10);#
  long long SHIFT6 = SHIFT5*(NMAX + 10);#
  return (long long)la#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)T00#
       + SHIFT4*(long long)T10#
       + SHIFT5*(long long)T01#
       + SHIFT6*(long long)T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n<1){#
    NumericVector LR(0),prob(0);#
    return List::create(Named("LR")=LR, Named("prob")=prob);#
  }#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> curMap;#
#
  // initialization#
  {#
    State s0; s0.la=0; s0.c1=0; s0.T00=0; s0.T10=0; s0.T01=0; s0.T11=0; s0.prob=1.0-alpha;#
    long long c0=encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX);#
    curMap[c0]=s0;#
#
    State s1; s1.la=1; s1.c1=1; s1.T00=0; s1.T10=0; s1.T01=0; s1.T11=0; s1.prob=alpha;#
    long long c1=encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX);#
    curMap[c1]=s1;#
  }#
#
  // forward#
  for(int k=1; k<n; k++){#
    std::unordered_map<long long,State,LLHash> newMap;#
    newMap.reserve(curMap.size()*2);#
    for(auto &kv: curMap){#
      double p=kv.second.prob;#
      if(p<prune_threshold) continue;#
      int la = kv.second.la;#
      int c1 = kv.second.c1;#
      int T00= kv.second.T00;#
      int T10= kv.second.T10;#
      int T01= kv.second.T01;#
      int T11= kv.second.T11;#
      double p0 = 1.0 - alpha;#
      double p1 = alpha;#
#
      // next state if we observe 0#
      {#
        State ns = kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0;#
        ns.prob = p*p0;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
#
      // next state if we observe 1#
      {#
        State ns = kv.second;#
        if(la==0){ ns.T01++; ns.c1++; } else { ns.T11++; ns.c1++; }#
        ns.la=1;#
        ns.prob = p*p1;#
        long long c=encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
        auto it=newMap.find(c);#
        if(it==newMap.end()) newMap[c]=ns; else it->second.prob += ns.prob;#
      }#
    }#
#
    curMap.clear();#
    for(auto &km: newMap){#
      if(km.second.prob>=prune_threshold){#
        curMap[km.first]=km.second;#
      }#
    }#
  }#
#
  // gather distribution#
  std::unordered_map<double,double> lrDist;#
  for(auto &kv: curMap){#
    double p = kv.second.prob;#
    if(p<=0.0) continue;#
#
    int c1=kv.second.c1;#
    int T00=kv.second.T00;#
    int T10=kv.second.T10;#
    int T01=kv.second.T01;#
    int T11=kv.second.T11;#
#
    // LRuc#
    double lruc=0.0;#
    {#
      double phat=0.0;#
      if(c1==0)      phat=0.0;#
      else if(c1==n) phat=1.0;#
      else           phat=(double)c1/(double)n;#
#
      double p_=std::max(std::min(alpha,1.0-EPS),EPS);#
      double ph_=std::max(std::min(phat,1.0-EPS),EPS);#
      double num=c1*std::log(p_)+(n-c1)*std::log(1.0-p_);#
      double den=c1*std::log(ph_)+(n-c1)*std::log(1.0-ph_);#
      lruc=-2.0*(num - den);#
    }#
#
    // LRind#
    double lrind=0.0;#
    {#
      if(n>1){#
        int T0=T00+T10;#
        int T1=T01+T11;#
        double ph=(double)T1/(double)(n-1);#
        double num= T0*s_log(1.0-ph)+ T1*s_log(ph);#
        int s01=T00+T01;#
        int s11=T10+T11;#
        double pi01=(s01>0)?((double)T01/(double)s01):1.0;#
        double pi11=(s11>0)?((double)T11/(double)s11):1.0;#
        double den= T00*s_log(1.0-pi01)+ T01*s_log(pi01)#
                   + T10*s_log(1.0-pi11)+ T11*s_log(pi11);#
        lrind=-2.0*(num - den);#
      }#
    }#
    double LR = lruc+lrind;#
    lrDist[LR]+=p;#
  }#
#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(lrDist.size());#
  for(auto &kv: lrDist){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(),vec.end(),[](auto &a, auto &b){return a.first<b.first;});#
#
  NumericVector LRout, Pout;#
  if(!vec.empty()){#
    double curLR = vec[0].first;#
    double curP  = vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR = vec[i].first;#
        curP  = vec[i].second;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
main <- function() {#
  alpha_test <- 0.05#
  for(n_ in c(15,100,500,1000)) {#
    t1 <- proc.time()#
    fb_res <- fb_lrcc(n_, alpha_test)#
    t2 <- proc.time() - t1#
    cat(sprintf("\n=== n= %d, alpha= %.3f ===\n", n_, alpha_test))#
    cat(sprintf("Forward time= %.3fs, #distinct LR= %d, sum(prob)= %.6f\n",#
                t2["elapsed"], length(fb_res$LR), sum
library(Rcpp)#
library(stats)#
#
safe_log <- function(x){#
  eps <- 1e-15#
  log(ifelse(x > eps, x, eps))#
}#
#
LRuc_count <- function(x, n, p){#
  eps  <- 1e-15#
  p_   <- max(min(p, 1 - eps), eps)#
  phat <- if (x == 0) 0 else if (x == n) 1 else x / n#
  ph_  <- max(min(phat, 1 - eps), eps)#
  num  <- x * safe_log(p_) + (n - x) * safe_log(1 - p_)#
  den  <- x * safe_log(ph_) + (n - x) * safe_log(1 - ph_)#
  -2 * (num - den)#
}#
#
LRind_counts_loc <- function(T00, T10, T01, T11, n){#
  if (n <= 1) return(0)#
  T0   <- T00 + T10#
  T1   <- T01 + T11#
  pHat <- if ((n - 1) > 0) T1 / (n - 1) else 0#
  num  <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
  pi01 <- if ((T00 + T01) > 0) T01 / (T00 + T01) else 1#
  pi11 <- if ((T10 + T11) > 0) T11 / (T10 + T11) else 1#
  den  <- T00 * safe_log(1 - pi01) + T01 * safe_log(pi01) +#
          T10 * safe_log(1 - pi11) + T11 * safe_log(pi11)#
  -2 * (num - den)#
}#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log(x > EPS ? x : EPS); }#
#
struct State{#
  int la, c1, T00, T10, T01, T11;#
  double prob;#
};#
#
struct LLHash{#
  std::size_t operator()(long long x) const{ return std::hash<long long>()(x); }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long S2 = NMAX + 10;#
  long long S3 = S2 * (NMAX + 10);#
  long long S4 = S3 * (NMAX + 10);#
  long long S5 = S4 * (NMAX + 10);#
  long long S6 = S5 * (NMAX + 10);#
  return (long long)la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15){#
  if(n < 1) return List::create(_["LR"]=NumericVector(0), _["prob"]=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long, State, LLHash> cur;#
#
  State s0{0,0,0,0,0,0,1.0-alpha};#
  cur[encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX)] = s0;#
  State s1{1,1,0,0,0,0,alpha};#
  cur[encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX)] = s1;#
#
  for(int k=1; k<n; ++k){#
    std::unordered_map<long long, State, LLHash> nxt;#
    nxt.reserve(cur.size()*2);#
    for(auto &kv: cur){#
      if(kv.second.prob < prune_threshold) continue;#
      const State &st = kv.second;#
      double p0 = 1.0 - alpha, p1 = alpha;#
#
      State ns = st;#
      (ns.la==0 ? ns.T00 : ns.T10)++; ns.la = 0; ns.prob = st.prob * p0;#
      long long c = encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
      nxt[c].prob += ns.prob; if(nxt[c].prob == ns.prob) nxt[c] = ns;#
#
      ns = st;#
      (ns.la==0 ? ns.T01 : ns.T11)++; ns.c1++; ns.la = 1; ns.prob = st.prob * p1;#
      c = encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
      nxt[c].prob += ns.prob; if(nxt[c].prob == ns.prob) nxt[c] = ns;#
    }#
    cur.clear();#
    for(auto &kv: nxt) if(kv.second.prob >= prune_threshold) cur[kv.first] = kv.second;#
  }#
#
  std::unordered_map<double,double> LRmap;#
  for(auto &kv: cur){#
    if(kv.second.prob <= 0.0) continue;#
    const State &st = kv.second;#
    int c1=st.c1, T00=st.T00, T10=st.T10, T01=st.T01, T11=st.T11;#
#
    double phat = c1==0 ? 0.0 : (c1==n ? 1.0 : (double)c1/n);#
    double p_ = std::max(std::min(alpha,1.0-EPS),EPS);#
    double ph_= std::max(std::min(phat ,1.0-EPS),EPS);#
    double lruc = -2.0*( c1*std::log(p_)+(n-c1)*std::log(1.0-p_)#
                       - c1*std::log(ph_)-(n-c1)*std::log(1.0-ph_) );#
#
    double lrind = 0.0;#
    if(n > 1){#
      int T0=T00+T10, T1=T01+T11;#
      double pH = (double)T1/(n-1);#
      double num = T0*s_log(1.0-pH)+T1*s_log(pH);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den = T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind = -2.0*(num - den);#
    }#
    LRmap[lruc + lrind] += st.prob;#
  }#
#
  std::vector<std::pair<double,double>> v(LRmap.begin(), LRmap.end());#
  std::sort(v.begin(), v.end(), [](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR, Pr;#
  if(!v.empty()){#
    double curLR=v[0].first, curP=v[0].second;#
    for(size_t i=1;i<v.size();++i){#
      if(std::fabs(v[i].first-curLR)<1e-15) curP += v[i].second;#
      else{ LR.push_back(curLR); Pr.push_back(curP); curLR=v[i].first; curP=v[i].second; }#
    }#
    LR.push_back(curLR); Pr.push_back(curP);#
  }#
  return List::create(_["LR"]=LR, _["prob"]=Pr);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15){#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
main <- function(){#
  alpha_test <- 0.05#
  for(n_ in c(15,100,500,1000)){#
    t0 <- proc.time()#
    res <- fb_lrcc(n_, alpha_test)#
    dt <- proc.time() - t0#
    cat(sprintf("\n=== n = %d, alpha = %.3f ===\n", n_, alpha_test))#
    cat(sprintf("time = %.3fs, #LR = %d, sum(prob) = %.6f\n",#
                dt["elapsed"], length(res$LR), sum(res$prob)))#
  }#
}#
main()
# Runtime Comparison:#
#
main <- function() {#
  alpha_list <- c(0.01,0.025,0.05,0.10)#
  n_list <- c(250,500,1000,2000)#
  cat("   n     alpha   #distinct_LR    sum(prob)       time(s)\n")#
  for(alpha_ in alpha_list) {#
    for(n_ in n_list) {#
      t0 <- proc.time()#
      res <- fb_lrcc(n_, alpha_, 1e-15)#
      elapsed <- proc.time() - t0#
      LRvals <- res$LR#
      probvals <- res$prob#
      sumprob <- sum(probvals)#
      cat(sprintf("%5d  %7.3f  %12d  %10.8f  %10.4f\n",#
                  n_, alpha_, length(LRvals), sumprob, elapsed["elapsed"]))#
    }#
    cat("\n")#
  }#
}#
main()#
#
# Under different pruning thresholds#
#
main <- function() {#
  thresholds <- c(1e-17,1e-16,1e-15,1e-14,1e-13,1e-12,1e-11,1e-10)#
  alpha_list <- c(0.01,0.05,0.10)#
  n_list <- c(500,1000)#
  for(n_ in n_list) {#
    cat(sprintf("\nn = %d\n", n_))#
    for(alpha_ in alpha_list) {#
      cat(sprintf("\n=== alpha = %.3f ===\n", alpha_))#
      cat("prune_threshold     #distinct_LR     sum(prob)        time(s)\n")#
      for(th in thresholds) {#
        t0 <- proc.time()#
        res <- fb_lrcc(n_, alpha_, th)#
        elapsed <- proc.time() - t0#
        LRvals <- res$LR#
        probvals <- res$prob#
        sumprob <- sum(probvals)#
        distinct_LR <- length(LRvals)#
        cat(sprintf("%-14g %14d %12.8f %12.4f\n",#
                    th, distinct_LR, sumprob, elapsed["elapsed"]))#
      }#
    }#
  }#
}#
main()
# Comparison of CDFs#
#
mc_lrcc <- function(n, alpha=0.05, Nrep=20000) {#
  LR_values <- numeric(Nrep)#
  for(i in seq_len(Nrep)) {#
    path <- rbinom(n, 1, alpha)#
    T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
    for(t in 2:n) {#
      if(path[t-1]==0 && path[t]==0) T00 <- T00+1#
      else if(path[t-1]==0 && path[t]==1) T01 <- T01+1#
      else if(path[t-1]==1 && path[t]==0) T10 <- T10+1#
      else T11 <- T11+1#
    }#
    x <- sum(path)#
    lruc  <- LRuc_count(x, n, alpha)#
    lrind <- LRind_counts_loc(T00, T10, T01, T11, n)#
    LR_values[i] <- lruc + lrind#
  }#
  arr <- sort(LR_values)#
  idx_diff <- which(diff(arr) > 0)#
  uniq_idx <- c(idx_diff, length(arr))#
  LRuniq <- arr[uniq_idx]#
  prob_ <- numeric(length(uniq_idx))#
  start <- 1#
  for(j in seq_along(uniq_idx)) {#
    e <- uniq_idx[j]#
    prob_[j] <- (e - start + 1) / Nrep#
    start <- e + 1#
  }#
  list(LR = LRuniq, prob = prob_)#
}#
#
step_cdf_plot <- function(LRvals, probs, col="blue", lty=1) {#
  cdf <- cumsum(probs)#
  x <- c(0, LRvals)#
  y <- c(0, cdf)#
  lines(x, y, type="s", col=col, lty=lty)#
  points(x, y, pch=16, cex=0.5, col=col)#
}#
#
plot_three_distributions_cc <- function(n, alpha, fb_res, mc_res) {#
  plot(0, 0, type="n", xlab="LRcc value", ylab="CDF",#
       xlim=c(0, max(c(fb_res$LR, mc_res$LR, 10))), ylim=c(0, 1.02),#
       main=sprintf("LRcc CDF\nn=%d, alpha=%.3f", n, alpha))#
  step_cdf_plot(fb_res$LR, fb_res$prob, col="blue", lty=1)#
  step_cdf_plot(mc_res$LR, mc_res$prob, col="green", lty=2)#
  xm <- max(c(fb_res$LR, mc_res$LR, 10))#
  xseq <- seq(0, xm + 0.2, length.out=300)#
  chi_cdf <- pchisq(xseq, df=2)#
  lines(xseq, chi_cdf, col="red")#
  legend("bottomright",#
         legend=c("Exact(DP)", "Empirical(MC)", "Chi2(2)"),#
         col=c("blue", "green", "red"), lty=c(1, 2, 1), bty="n")#
}#
#
main <- function() {#
  set.seed(42)#
  alpha_list <- c(0.01, 0.05, 0.10)#
  n_list <- c(15, 100, 500)#
  prune_threshold <- 1e-15#
  Nrep <- 20000#
  cat("   n     alpha   #distinct_LR    sum(prob)       time(s)\n")#
  for(alpha_ in alpha_list) {#
    for(n_ in n_list) {#
      t0 <- proc.time()#
      fb_res <- fb_lrcc(n_, alpha_, prune_threshold)#
      t1 <- proc.time() - t0#
      cat(sprintf("%5d  %7.3f  %12d  %10.8f  %10.4f\n",#
                  n_, alpha_, length(fb_res$LR), sum(fb_res$prob), t1["elapsed"]))#
      t2 <- proc.time()#
      mc_res <- mc_lrcc(n_, alpha_, Nrep)#
      t3 <- proc.time() - t2#
      dev.new(width=5.5, height=4)#
      plot_three_distributions_cc(n_, alpha_, fb_res, mc_res)#
    }#
  }#
  cat("\nDone. Generated 9 figures (3 values of alpha x 3 values of n).\n")#
}#
#
main()
# KS distance v.s. pruning thresholds#
#
cdf_xy <- function(LRvals, probvals) {#
  csum <- cumsum(probvals)#
  x <- c(0, LRvals)#
  y <- c(0, csum)#
  list(x=x, y=y)#
}#
#
cdf_val <- function(x, xx, yy) {#
  if(x <= xx[1]) return(0)#
  if(x >= xx[length(xx)]) return(yy[length(yy)])#
  i <- findInterval(x, xx, rightmost.closed=TRUE)#
  yy[i]#
}#
#
cdf_diff <- function(LRvals, probvals, df=2) {#
  tmp <- cdf_xy(LRvals, probvals)#
  xs <- tmp$x#
  ys <- tmp$y#
  if(!length(xs)) return(0)#
  xm <- xs[length(xs)] + 1#
  seqx <- seq(0, xm, length.out=600)#
  supd <- 0#
  for(xx in seqx) {#
    Ft <- cdf_val(xx, xs, ys)#
    Fc <- pchisq(xx, df)#
    d <- abs(Ft - Fc)#
    if(d > supd) supd <- d#
  }#
  supd#
}#
#
main <- function() {#
  n <- 500#
  alpha_list <- c(0.01, 0.025, 0.05)#
  thresholds <- c(1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10)#
  cat("n=500\n")#
  cat(" alpha    prune_threshold     #distinct_LR     sum(prob)     KS_distance\n")#
  results <- list()#
  for(alpha_ in alpha_list) {#
    thr_vals <- numeric(length(thresholds))#
    ks_vals <- numeric(length(thresholds))#
    for(i in seq_along(thresholds)) {#
      th <- thresholds[i]#
      dist_ <- fb_lrcc(n, alpha_, th)#
      LRvals <- dist_$LR#
      probvals <- dist_$prob#
      sum_prob <- sum(probvals)#
      distinct_LR <- length(LRvals)#
      ks_d <- cdf_diff(LRvals, probvals, 2)#
      cat(sprintf(" %6.3f   %-12g   %12d   %10.8f   %9.6f\n",#
                  alpha_, th, distinct_LR, sum_prob, ks_d))#
      thr_vals[i] <- th#
      ks_vals[i] <- ks_d#
    }#
    results[[as.character(alpha_)]] <- list(th=thr_vals, ks=ks_vals)#
    cat("\n")#
  }#
  plot(NULL, xlim=range(thresholds), ylim=c(0,1), log="x",#
       xlab="prune_threshold", ylab="KS distance",#
       main="KS distance vs prune_threshold (n=500) - LRcc")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(alpha_ in alpha_list) {#
    lines(results[[as.character(alpha_)]]$th, results[[as.character(alpha_)]]$ks,#
          type="b", pch=19, col=cols[i])#
    i <- i + 1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list),#
         col=cols, pch=19, lty=1, bty="n")#
}#
#
main()
# KS distance v.s. alpha#
#
main <- function() {#
  n_list <- c(250, 500, 1000)#
  alpha_vals <- seq(0.01, 0.1, length.out=21)#
  curves <- list()#
  for(n_ in n_list) {#
    diffs <- numeric(length(alpha_vals))#
    for(i in seq_along(alpha_vals)) {#
      alpha_ <- alpha_vals[i]#
      dist_ <- fb_lrcc(n_, alpha_)#
      diffs[i] <- cdf_diff(dist_$LR, dist_$prob, 2)#
    }#
    curves[[as.character(n_)]] <- diffs#
  }#
  plot(NA, NA, xlim=range(alpha_vals), ylim=c(0,1),#
       xlab="alpha", ylab="KS distance",#
       main="CDF difference (LRcc vs Chi2) vs alpha")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(n_ in n_list) {#
    lines(alpha_vals, curves[[as.character(n_)]], col=cols[i], lwd=2)#
    points(alpha_vals, curves[[as.character(n_)]], col=cols[i], pch=19, cex=0.7)#
    i <- i+1#
  }#
  legend("topright", legend=paste("n=", n_list), col=cols, pch=19, lty=1, bty="n")#
}#
#
main()
# KS distance v.s. n#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;                       // <- added EPS#
static inline double s_log(double x){           // <- EPS-protected log#
  return std::log( x > EPS ? x : EPS );#
}#
#
struct CCState {#
  int last;#
  int c1;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_cc_state(int last,int c1,int s00,int s10,int s01,int s11,int nmax){#
  long long NSTEP = (long long)nmax + 10;#
  long long SHIFT2 = NSTEP;#
  long long SHIFT3 = SHIFT2*NSTEP;#
  long long SHIFT4 = SHIFT3*NSTEP;#
  long long SHIFT5 = SHIFT4*NSTEP;#
  long long SHIFT6 = SHIFT5*NSTEP;#
  return (long long)last#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)s00#
       + SHIFT4*(long long)s10#
       + SHIFT5*(long long)s01#
       + SHIFT6*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List initialize_cc_fastcpp(double alpha=0.05) {#
  CCState s0; #
  s0.last=0; s0.c1=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0 - alpha;#
  CCState s1; #
  s1.last=1; s1.c1=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
#
  IntegerVector vl(2), vc1(2), vs00(2), vs10(2), vs01(2), vs11(2);#
  NumericVector vp(2);#
  vl[0]   = s0.last;  vc1[0]  = s0.c1;  vs00[0] = s0.s00;  vs10[0] = s0.s10;  vs01[0] = s0.s01;  vs11[0] = s0.s11;  vp[0] = s0.prob;#
  vl[1]   = s1.last;  vc1[1]  = s1.c1;  vs00[1] = s1.s00;  vs10[1] = s1.s10;  vs01[1] = s1.s01;  vs11[1] = s1.s11;  vp[1] = s1.prob;#
  return List::create(Named("last")=vl, Named("c1")=vc1, Named("s00")=vs00, Named("s10")=vs10, Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_cc_fastcpp(List curDist, double alpha=0.05, double prune_threshold=1e-15, int nmax=2000){#
  IntegerVector last  = curDist["last"];#
  IntegerVector c1v   = curDist["c1"];#
  IntegerVector s00v  = curDist["s00"];#
  IntegerVector s10v  = curDist["s10"];#
  IntegerVector s01v  = curDist["s01"];#
  IntegerVector s11v  = curDist["s11"];#
  NumericVector probv = curDist["prob"];#
#
  std::unordered_map<long long, CCState, LLHash> newMap;#
  newMap.reserve(last.size()*2);#
#
  for(int i=0; i<last.size(); i++){#
    double p = probv[i];#
    if(p < prune_threshold) continue;#
    CCState st;#
    st.last = last[i];#
    st.c1   = c1v[i];#
    st.s00  = s00v[i];#
    st.s10  = s10v[i];#
    st.s01  = s01v[i];#
    st.s11  = s11v[i];#
    st.prob = p;#
    {#
      CCState ns = st;#
      if(ns.last==0) ns.s00++; else ns.s10++;#
      ns.last=0;#
      ns.prob = p*(1.0 - alpha);#
      long long code = encode_cc_state(ns.last, ns.c1, ns.s00, ns.s10, ns.s01, ns.s11, nmax);#
      auto it = newMap.find(code);#
      if(it==newMap.end()) newMap[code] = ns; else it->second.prob += ns.prob;#
    }#
    {#
      CCState ns = st;#
      if(ns.last==0) ns.s01++; else ns.s11++;#
      ns.last=1;#
      ns.c1++;#
      ns.prob = p*alpha;#
      long long code = encode_cc_state(ns.last, ns.c1, ns.s00, ns.s10, ns.s01, ns.s11, nmax);#
      auto it = newMap.find(code);#
      if(it==newMap.end()) newMap[code] = ns; else it->second.prob += ns.prob;#
    }#
  }#
  std::vector<CCState> vec; #
  vec.reserve(newMap.size());#
  for(auto &kv : newMap){#
    if(kv.second.prob >= prune_threshold){#
      vec.push_back(kv.second);#
    }#
  }#
  int sz = vec.size();#
  IntegerVector vl(sz), vc1(sz), vs00(sz), vs10(sz), vs01(sz), vs11(sz);#
  NumericVector vp(sz);#
  for(int i=0; i<sz; i++){#
    vl[i]   = vec[i].last;#
    vc1[i]  = vec[i].c1;#
    vs00[i] = vec[i].s00;#
    vs10[i] = vec[i].s10;#
    vs01[i] = vec[i].s01;#
    vs11[i] = vec[i].s11;#
    vp[i]   = vec[i].prob;#
  }#
  return List::create(Named("last")=vl, Named("c1")=vc1, Named("s00")=vs00, Named("s10")=vs10, Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List dist_cc_at_current_fastcpp(List curDist, int t, double alpha=0.05){#
  IntegerVector last  = curDist["last"];#
  IntegerVector c1v   = curDist["c1"];#
  IntegerVector s00v  = curDist["s00"];#
  IntegerVector s10v  = curDist["s10"];#
  IntegerVector s01v  = curDist["s01"];#
  IntegerVector s11v  = curDist["s11"];#
  NumericVector probv = curDist["prob"];#
#
  std::unordered_map<double,double> dmap;#
  dmap.reserve(last.size());#
#
  double eps=1e-15;#
  for(int i=0; i<last.size(); i++){#
    double p = probv[i];#
    if(p<=0.0) continue;#
    int c1  = c1v[i];#
    int x00 = s00v[i], x10 = s10v[i], x01 = s01v[i], x11 = s11v[i];#
    double phat=0.0;#
    if(c1==0)      phat=0.0;#
    else if(c1==t) phat=1.0;#
    else           phat=(double)c1/(double)t;#
    double p_ = std::max(std::min(alpha,1.0-eps),eps);#
    double ph_ = std::max(std::min(phat,1.0-eps),eps);#
    double num = c1*s_log(p_) + (t-c1)*s_log(1.0-p_);#
    double den = c1*s_log(ph_) + (t-c1)*s_log(1.0-ph_);#
    double lruc = -2.0*(num - den);#
    double lrind=0.0;#
    if(t>1){#
      int T0 = x00 + x10;#
      int T1 = x01 + x11;#
      double pHat = (double)T1/(double)(t-1);#
      double numI = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
      int s01_ = x00+x01;#
      int s11_ = x10+x11;#
      double pi01 = (s01_>0)? ((double)x01/(double)s01_) : 1.0;#
      double pi11 = (s11_>0)? ((double)x11/(double)s11_) : 1.0;#
      double denI = x00*s_log(1.0-pi01) + x01*s_log(pi01) +#
                    x10*s_log(1.0-pi11) + x11*s_log(pi11);#
      lrind = -2.0*(numI - denI);#
    }#
    double LRcc = lruc + lrind;#
    dmap[LRcc] += p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(dmap.size());#
  for(auto &kv: dmap){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){return a.first<b.first;});#
  NumericVector LRvals, Pvals;#
  if(!vec.empty()){#
    double curLR=vec[0].first;#
    double curP=vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRvals.push_back(curLR);#
        Pvals.push_back(curP);#
        curLR=vec[i].first;#
        curP=vec[i].second;#
      }#
    }#
    LRvals.push_back(curLR);#
    Pvals.push_back(curP);#
  }#
  return List::create(Named("LR")=LRvals, Named("prob")=Pvals);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  if(!length(LRvals)) return(list(x=numeric(0),y=numeric(0)))#
  cum <- cumsum(probvals)#
  if(LRvals[1]>=0) {#
    x <- c(0, LRvals)#
    y <- c(0, cum)#
  } else {#
    x <- LRvals#
    y <- cum#
  }#
  list(x=x,y=y)#
}#
#
cdf_val <- function(x, xs, ys){#
  if(!length(xs)) return(0)#
  if(x<=xs[1]) return(0)#
  if(x>=xs[length(xs)]) return(ys[length(xs)])#
  i <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[i]#
}#
#
ks_diff <- function(LRvals, probvals, df=2){#
  d <- cdf_xy(LRvals, probvals)#
  xs <- d$x#
  ys <- d$y#
  if(!length(xs)) return(0)#
  xmax <- xs[length(xs)] + 1#
  seqx <- seq(0, xmax, length.out=800)#
  supd <- 0#
  for(xv in seqx){#
    Ft <- cdf_val(xv, xs, ys)#
    Fc <- pchisq(xv, df)#
    double_diff <- abs(Ft - Fc)#
    if(double_diff>supd) supd<-double_diff#
  }#
  supd#
}#
#
main_cc <- function(){#
  alpha_list <- c(0.01,0.025,0.05)#
  nmax <- 2000#
  nmin <- 1#
  step <- 1#
  plot(NA, xlim=c(nmin,nmax), ylim=c(0,1), xlab="n", ylab="KS distance", main="CDF difference (LRcc vs Chi2) vs n")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_cc_fastcpp(a)#
    nvals <- seq(nmin,nmax,by=step)#
    ksvals <- numeric(length(nvals))#
    for(ix in seq_along(nvals)){#
      t <- nvals[ix]#
      resNow <- dist_cc_at_current_fastcpp(dist_k, t, a)#
      kd <- ks_diff(resNow$LR, resNow$prob, 2)#
      ksvals[ix] <- kd#
      if(t < nmax) {#
        dist_k <- step_forward_cc_fastcpp(dist_k, a, 1e-15, nmax)#
      }#
    }#
    lines(nvals, ksvals, col=cols[i], lwd=2)#
    i <- i+1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list), col=cols, lty=1#
main_cc()
# KS distance v.s. n#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;                                    // EPS for log-protection#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct CCState {#
  int last;#
  int c1;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_cc_state(int last,int c1,int s00,int s10,int s01,int s11,int nmax){#
  long long NSTEP = (long long)nmax + 10;#
  long long SHIFT2 = NSTEP;#
  long long SHIFT3 = SHIFT2*NSTEP;#
  long long SHIFT4 = SHIFT3*NSTEP;#
  long long SHIFT5 = SHIFT4*NSTEP;#
  long long SHIFT6 = SHIFT5*NSTEP;#
  return (long long)last#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)s00#
       + SHIFT4*(long long)s10#
       + SHIFT5*(long long)s01#
       + SHIFT6*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List initialize_cc_fastcpp(double alpha=0.05) {#
  CCState s0; s0.last=0; s0.c1=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0-alpha;#
  CCState s1; s1.last=1; s1.c1=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
#
  IntegerVector vl(2), vc1(2), vs00(2), vs10(2), vs01(2), vs11(2);#
  NumericVector vp(2);#
  vl[0]=s0.last; vc1[0]=s0.c1; vs00[0]=s0.s00; vs10[0]=s0.s10; vs01[0]=s0.s01; vs11[0]=s0.s11; vp[0]=s0.prob;#
  vl[1]=s1.last; vc1[1]=s1.c1; vs00[1]=s1.s00; vs10[1]=s1.s10; vs01[1]=s1.s01; vs11[1]=s1.s11; vp[1]=s1.prob;#
  return List::create(Named("last")=vl, Named("c1")=vc1, Named("s00")=vs00,#
                      Named("s10")=vs10, Named("s01")=vs01, Named("s11")=vs11,#
                      Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_cc_fastcpp(List curDist, double alpha=0.05, double prune_threshold=1e-15, int nmax=2000){#
  IntegerVector last=curDist["last"], c1v=curDist["c1"], s00v=curDist["s00"],#
                s10v=curDist["s10"], s01v=curDist["s01"], s11v=curDist["s11"];#
  NumericVector probv=curDist["prob"];#
#
  std::unordered_map<long long,CCState,LLHash> newMap;#
  newMap.reserve(last.size()*2);#
#
  for(int i=0;i<last.size();i++){#
    double p=probv[i];#
    if(p<prune_threshold) continue;#
    CCState st{last[i],c1v[i],s00v[i],s10v[i],s01v[i],s11v[i],p};#
#
    { // observe 0#
      CCState ns=st;#
      (ns.last==0 ? ns.s00 : ns.s10)++;#
      ns.last=0; ns.prob=p*(1.0-alpha);#
      long long code=encode_cc_state(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      newMap[code].prob+=ns.prob; if(newMap[code].prob==ns.prob) newMap[code]=ns;#
    }#
    { // observe 1#
      CCState ns=st;#
      (ns.last==0 ? ns.s01 : ns.s11)++; ns.c1++;#
      ns.last=1; ns.prob=p*alpha;#
      long long code=encode_cc_state(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      newMap[code].prob+=ns.prob; if(newMap[code].prob==ns.prob) newMap[code]=ns;#
    }#
  }#
#
  std::vector<CCState> vec; vec.reserve(newMap.size());#
  for(auto &kv:newMap) if(kv.second.prob>=prune_threshold) vec.push_back(kv.second);#
#
  int sz=vec.size();#
  IntegerVector vl(sz),vc1(sz),vs00(sz),vs10(sz),vs01(sz),vs11(sz); NumericVector vp(sz);#
  for(int i=0;i<sz;i++){#
    vl[i]=vec[i].last; vc1[i]=vec[i].c1; vs00[i]=vec[i].s00; vs10[i]=vec[i].s10;#
    vs01[i]=vec[i].s01; vs11[i]=vec[i].s11; vp[i]=vec[i].prob;#
  }#
  return List::create(Named("last")=vl, Named("c1")=vc1, Named("s00")=vs00,#
                      Named("s10")=vs10, Named("s01")=vs01, Named("s11")=vs11,#
                      Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List dist_cc_at_current_fastcpp(List curDist, int t, double alpha=0.05){#
  IntegerVector last=curDist["last"], c1v=curDist["c1"], s00v=curDist["s00"],#
                s10v=curDist["s10"], s01v=curDist["s01"], s11v=curDist["s11"];#
  NumericVector probv=curDist["prob"];#
#
  std::unordered_map<double,double> dmap; dmap.reserve(last.size());#
#
  for(int i=0;i<last.size();i++){#
    double p=probv[i]; if(p<=0.0) continue;#
    int c1=c1v[i], x00=s00v[i], x10=s10v[i], x01=s01v[i], x11=s11v[i];#
#
    double phat = (c1==0)?0.0:((c1==t)?1.0:(double)c1/t);#
    double p_   = std::max(std::min(alpha,1.0-EPS),EPS);#
    double ph_  = std::max(std::min(phat ,1.0-EPS),EPS);#
    double lruc = -2.0*( c1*s_log(p_) + (t-c1)*s_log(1.0-p_)#
                       - c1*s_log(ph_) - (t-c1)*s_log(1.0-ph_) );#
#
    double lrind=0.0;#
    if(t>1){#
      int T0=x00+x10, T1=x01+x11;#
      double pH=(double)T1/(t-1);#
      double num=T0*s_log(1.0-pH)+T1*s_log(pH);#
#
      int s01_=x00+x01, s11_=x10+x11;#
      double pi01=(s01_>0)?(double)x01/s01_:1.0;#
      double pi11=(s11_>0)?(double)x11/s11_:1.0;#
      double den=x00*s_log(1.0-pi01)+x01*s_log(pi01)+#
                 x10*s_log(1.0-pi11)+x11*s_log(pi11);#
      lrind=-2.0*(num - den);#
    }#
    dmap[lruc+lrind]+=p;#
  }#
#
  std::vector<std::pair<double,double>> v; v.reserve(dmap.size());#
  for(auto &kv:dmap) v.push_back(kv);#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
#
  NumericVector LR,Pr;#
  if(!v.empty()){#
    double curLR=v[0].first, curP=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(std::fabs(v[i].first-curLR)<1e-15) curP+=v[i].second;#
      else{ LR.push_back(curLR); Pr.push_back(curP); curLR=v[i].first; curP=v[i].second; }#
    }#
    LR.push_back(curLR); Pr.push_back(curP);#
  }#
  return List::create(Named("LR")=LR, Named("prob")=Pr);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  if(!length(LRvals)) return(list(x=numeric(0),y=numeric(0)))#
  cum <- cumsum(probvals)#
  if(LRvals[1]>=0){#
    list(x=c(0,LRvals), y=c(0,cum))#
  }else{#
    list(x=LRvals, y=cum)#
  }#
}#
#
cdf_val <- function(x, xs, ys){#
  if(!length(xs)) return(0)#
  if(x<=xs[1]) return(0)#
  if(x>=xs[length(xs)]) return(ys[length(ys)])#
  ys[findInterval(x,xs, rightmost.closed=TRUE)]#
}#
#
ks_diff <- function(LRvals, probvals, df=2){#
  d <- cdf_xy(LRvals, probvals)#
  if(!length(d$x)) return(0)#
  xsamp <- seq(0, tail(d$x,1)+1, length.out=800)#
  max(abs(cdf_val(xsamp,d$x,d$y) - pchisq(xsamp, df)))#
}#
#
main_cc <- function(){#
  alpha_list <- c(0.01,0.025,0.05)#
  nmax <- 2000#
  nmin <- 1#
  step <- 1#
  plot(NA, xlim=c(nmin,nmax), ylim=c(0,1), xlab="n", ylab="KS distance",#
       main="CDF difference (LRcc vs Chi2) vs n")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_cc_fastcpp(a)#
    nvals <- seq(nmin, nmax, by=step)#
    ksvals <- numeric(length(nvals))#
    for(ix in seq_along(nvals)){#
      t <- nvals[ix]#
      resNow <- dist_cc_at_current_fastcpp(dist_k, t, a)#
      ksvals[ix] <- ks_diff(resNow$LR, resNow$prob, 2)#
      if(t < nmax) dist_k <- step_forward_cc_fastcpp(dist_k, a, 1e-15, nmax)#
    }#
    lines(nvals, ksvals, col=cols[i], lwd=2)#
    i <- i+1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list),#
         col=cols, lty=1, lwd=2, bty="n")#
}#
#
main_cc()
# KS distance v.s. n  (LRcc)#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct CCState{#
  int last,c1,s00,s10,s01,s11;#
  double prob;#
};#
#
struct LLHash{#
  std::size_t operator()(long long x)const{ return std::hash<long long>()(x); }#
};#
#
static inline long long encode_cc_state(int last,int c1,int s00,int s10,int s01,int s11,int nmax){#
  long long N = (long long)nmax + 10;#
  long long S2=N, S3=S2*N, S4=S3*N, S5=S4*N, S6=S5*N;#
  return (long long)last + S2*c1 + S3*s00 + S4*s10 + S5*s01 + S6*s11;#
}#
#
// -------- initial distribution ------------------------------------------#
[[Rcpp::export]]#
List initialize_cc_fastcpp(double alpha=0.05){#
  CCState s0{0,0,0,0,0,0,1.0-alpha};#
  CCState s1{1,1,0,0,0,0,alpha};#
  IntegerVector vl={s0.last,s1.last}, vc1={s0.c1,s1.c1},#
                vs00={s0.s00,s1.s00}, vs10={s0.s10,s1.s10},#
                vs01={s0.s01,s1.s01}, vs11={s0.s11,s1.s11};#
  NumericVector vp={s0.prob,s1.prob};#
  return List::create(_["last"]=vl,_["c1"]=vc1,_["s00"]=vs00,_["s10"]=vs10,#
                      _["s01"]=vs01,_["s11"]=vs11,_["prob"]=vp);#
}#
#
// -------- one-step forward ----------------------------------------------#
[[Rcpp::export]]#
List step_forward_cc_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"], c1=cur["c1"], a=cur["s00"], b=cur["s10"],#
                c=cur["s01"], d=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<long long,CCState,LLHash> mp; mp.reserve(l.size()*2);#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    CCState st{l[i],c1[i],a[i],b[i],c[i],d[i],p[i]};#
    // observe 0#
    CCState ns=st; (ns.last==0?ns.s00:ns.s10)++; ns.last=0; ns.prob*=1.0-alpha;#
    long long code=encode_cc_state(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
    mp[code].prob+=ns.prob; if(mp[code].prob==ns.prob) mp[code]=ns;#
    // observe 1#
    ns=st; (ns.last==0?ns.s01:ns.s11)++; ns.c1++; ns.last=1; ns.prob*=alpha;#
    code=encode_cc_state(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
    mp[code].prob+=ns.prob; if(mp[code].prob==ns.prob) mp[code]=ns;#
  }#
  // to vectors#
  std::vector<CCState> v; v.reserve(mp.size());#
  for(auto &kv:mp) if(kv.second.prob>=th) v.push_back(kv.second);#
  int n=v.size();#
  IntegerVector vl(n),vc1(n),vs00(n),vs10(n),vs01(n),vs11(n); NumericVector vp(n);#
  for(int i=0;i<n;i++){#
    vl[i]=v[i].last; vc1[i]=v[i].c1; vs00[i]=v[i].s00; vs10[i]=v[i].s10;#
    vs01[i]=v[i].s01; vs11[i]=v[i].s11; vp[i]=v[i].prob;#
  }#
  return List::create(_["last"]=vl,_["c1"]=vc1,_["s00"]=vs00,_["s10"]=vs10,#
                      _["s01"]=vs01,_["s11"]=vs11,_["prob"]=vp);#
}#
#
// -------- exact LRcc distribution at time t -----------------------------#
[[Rcpp::export]]#
List dist_cc_at_current_fastcpp(List cur,int t,double alpha=0.05){#
  IntegerVector l=cur["last"],c1=cur["c1"],a=cur["s00"],b=cur["s10"],#
                c=cur["s01"],d=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<=0.0) continue;#
    int x00=a[i],x10=b[i],x01=c[i],x11=d[i], n1=c1[i];#
    double phat=(n1==0)?0.0:((n1==t)?1.0:(double)n1/t);#
    double p_ = std::max(std::min(alpha,1.0-EPS),EPS);#
    double ph_= std::max(std::min(phat ,1.0-EPS),EPS);#
    double lruc=-2.0*( n1*s_log(p_) + (t-n1)*s_log(1.0-p_)#
                     - n1*s_log(ph_) - (t-n1)*s_log(1.0-ph_) );#
    double lrind=0.0;#
    if(t>1){#
      int T0=x00+x10, T1=x01+x11;#
      double pH=(double)T1/(t-1);#
      double num=T0*s_log(1.0-pH)+T1*s_log(pH);#
      int s01_=x00+x01, s11_=x10+x11;#
      double pi01=(s01_>0)?(double)x01/s01_:1.0;#
      double pi11=(s11_>0)?(double)x11/s11_:1.0;#
      double den=x00*s_log(1.0-pi01)+x01*s_log(pi01)+#
                 x10*s_log(1.0-pi11)+x11*s_log(pi11);#
      lrind=-2.0*(num - den);#
    }#
    mp[lruc+lrind]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  if(!v.empty()){#
    double cur=v[0].first,sum=v[0].second;#
    for(size_t i=1;i<v.size();i++){#
      if(std::fabs(v[i].first-cur)<1e-15) sum+=v[i].second;#
      else{ LR.push_back(cur); Pr.push_back(sum); cur=v[i].first; sum=v[i].second; }#
    }#
    LR.push_back(cur); Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  csum <- cumsum(probvals)#
  list(x=c(0,LRvals), y=c(0,csum))#
}#
#
cdf_val <- function(x, xs, ys){#
  if(x <= xs[1]) return(0)#
  if(x >= xs[length(xs)]) return(ys[length(ys)])#
  ys[findInterval(x, xs, rightmost.closed=TRUE)]#
}#
#
ks_diff <- function(LRvals, probvals, df=2){#
  d <- cdf_xy(LRvals, probvals)#
  xs <- d$x; ys <- d$y#
  if(!length(xs)) return(0)#
  xmax <- xs[length(xs)] + 1#
  seqx <- seq(0, xmax, length.out=800)#
  supd <- 0#
  for(xv in seqx){#
    Ft <- cdf_val(xv, xs, ys)#
    Fc <- pchisq(xv, df)#
    d  <- abs(Ft - Fc)#
    if(d > supd) supd <- d#
  }#
  supd#
}#
#
main_cc <- function(){#
  alpha_list <- c(0.01,0.025,0.05)#
  nmax <- 2000#
  nmin <- 1#
  step <- 1#
  plot(NA, xlim=c(nmin,nmax), ylim=c(0,1), xlab="n", ylab="KS distance",#
       main="CDF difference (LRcc vs Chi2) vs n")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_cc_fastcpp(a)#
    nvals <- seq(nmin, nmax, by=step)#
    ksvals <- numeric(length(nvals))#
    for(ix in seq_along(nvals)){#
      t <- nvals[ix]#
      res <- dist_cc_at_current_fastcpp(dist_k, t, a)#
      ksvals[ix] <- ks_diff(res$LR, res$prob, 2)#
      if(t < nmax) dist_k <- step_forward_cc_fastcpp(dist_k, a, 1e-15, nmax)#
    }#
    lines(nvals, ksvals, col=cols[i], lwd=2)#
    i <- i+1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list),#
         col=cols, lty=1, lwd=2, bty="n")#
}#
#
main_cc()
# KS distance v.s. n#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return (x>0.0)?std::log(x):0.0;#
}#
#
struct CCState {#
  int last;#
  int c1;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_cc_state(int last,int c1,int s00,int s10,int s01,int s11,int nmax){#
  long long NSTEP = (long long)nmax + 10;#
  long long SHIFT2 = NSTEP;#
  long long SHIFT3 = SHIFT2*NSTEP;#
  long long SHIFT4 = SHIFT3*NSTEP;#
  long long SHIFT5 = SHIFT4*NSTEP;#
  long long SHIFT6 = SHIFT5*NSTEP;#
  return (long long)last#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)s00#
       + SHIFT4*(long long)s10#
       + SHIFT5*(long long)s01#
       + SHIFT6*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List initialize_cc_fastcpp(double alpha=0.05) {#
  CCState s0; #
  s0.last=0; s0.c1=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0 - alpha;#
  CCState s1; #
  s1.last=1; s1.c1=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
#
  IntegerVector vl(2), vc1(2), vs00(2), vs10(2), vs01(2), vs11(2);#
  NumericVector vp(2);#
  vl[0]   = s0.last;  vc1[0]  = s0.c1;  vs00[0] = s0.s00;  vs10[0] = s0.s10;  vs01[0] = s0.s01;  vs11[0] = s0.s11;  vp[0] = s0.prob;#
  vl[1]   = s1.last;  vc1[1]  = s1.c1;  vs00[1] = s1.s00;  vs10[1] = s1.s10;  vs01[1] = s1.s01;  vs11[1] = s1.s11;  vp[1] = s1.prob;#
  return List::create(Named("last")=vl, Named("c1")=vc1, Named("s00")=vs00, Named("s10")=vs10, Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_cc_fastcpp(List curDist, double alpha=0.05, double prune_threshold=1e-15, int nmax=2000){#
  IntegerVector last  = curDist["last"];#
  IntegerVector c1v   = curDist["c1"];#
  IntegerVector s00v  = curDist["s00"];#
  IntegerVector s10v  = curDist["s10"];#
  IntegerVector s01v  = curDist["s01"];#
  IntegerVector s11v  = curDist["s11"];#
  NumericVector probv = curDist["prob"];#
#
  std::unordered_map<long long, CCState, LLHash> newMap;#
  newMap.reserve(last.size()*2);#
#
  for(int i=0; i<last.size(); i++){#
    double p = probv[i];#
    if(p < prune_threshold) continue;#
    CCState st;#
    st.last = last[i];#
    st.c1   = c1v[i];#
    st.s00  = s00v[i];#
    st.s10  = s10v[i];#
    st.s01  = s01v[i];#
    st.s11  = s11v[i];#
    st.prob = p;#
    {#
      CCState ns = st;#
      if(ns.last==0) ns.s00++; else ns.s10++;#
      ns.last=0;#
      ns.prob = p*(1.0 - alpha);#
      long long code = encode_cc_state(ns.last, ns.c1, ns.s00, ns.s10, ns.s01, ns.s11, nmax);#
      auto it = newMap.find(code);#
      if(it==newMap.end()) newMap[code] = ns; else it->second.prob += ns.prob;#
    }#
    {#
      CCState ns = st;#
      if(ns.last==0) ns.s01++; else ns.s11++;#
      ns.last=1;#
      ns.c1++;#
      ns.prob = p*alpha;#
      long long code = encode_cc_state(ns.last, ns.c1, ns.s00, ns.s10, ns.s01, ns.s11, nmax);#
      auto it = newMap.find(code);#
      if(it==newMap.end()) newMap[code] = ns; else it->second.prob += ns.prob;#
    }#
  }#
  std::vector<CCState> vec; #
  vec.reserve(newMap.size());#
  for(auto &kv : newMap){#
    if(kv.second.prob >= prune_threshold){#
      vec.push_back(kv.second);#
    }#
  }#
  int sz = vec.size();#
  IntegerVector vl(sz), vc1(sz), vs00(sz), vs10(sz), vs01(sz), vs11(sz);#
  NumericVector vp(sz);#
  for(int i=0; i<sz; i++){#
    vl[i]   = vec[i].last;#
    vc1[i]  = vec[i].c1;#
    vs00[i] = vec[i].s00;#
    vs10[i] = vec[i].s10;#
    vs01[i] = vec[i].s01;#
    vs11[i] = vec[i].s11;#
    vp[i]   = vec[i].prob;#
  }#
  return List::create(Named("last")=vl, Named("c1")=vc1, Named("s00")=vs00, Named("s10")=vs10, Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List dist_cc_at_current_fastcpp(List curDist, int t, double alpha=0.05){#
  IntegerVector last  = curDist["last"];#
  IntegerVector c1v   = curDist["c1"];#
  IntegerVector s00v  = curDist["s00"];#
  IntegerVector s10v  = curDist["s10"];#
  IntegerVector s01v  = curDist["s01"];#
  IntegerVector s11v  = curDist["s11"];#
  NumericVector probv = curDist["prob"];#
#
  std::unordered_map<double,double> dmap;#
  dmap.reserve(last.size());#
#
  double eps=1e-15;#
  for(int i=0; i<last.size(); i++){#
    double p = probv[i];#
    if(p<=0.0) continue;#
    int c1  = c1v[i];#
    int x00 = s00v[i], x10 = s10v[i], x01 = s01v[i], x11 = s11v[i];#
    double phat=0.0;#
    if(c1==0)      phat=0.0;#
    else if(c1==t) phat=1.0;#
    else           phat=(double)c1/(double)t;#
    double p_ = std::max(std::min(alpha,1.0-eps),eps);#
    double ph_ = std::max(std::min(phat,1.0-eps),eps);#
    double num = c1*std::log(p_)+(t-c1)*std::log(1.0-p_);#
    double den = c1*std::log(ph_)+(t-c1)*std::log(1.0-ph_);#
    double lruc = -2.0*(num - den);#
    double lrind=0.0;#
    if(t>1){#
      int T0 = x00 + x10;#
      int T1 = x01 + x11;#
      double pHat = (t>1)?((double)T1/(double)(t-1)):0.0;#
      double numI=0.0;#
      if((1.0-pHat)>0.0) numI += T0*std::log(1.0-pHat);#
      if(pHat>0.0)       numI += T1*std::log(pHat);#
      int s01_ = x00+x01;#
      int s11_ = x10+x11;#
      double pi01=(s01_>0)?((double)x01/(double)s01_):1.0;#
      double pi11=(s11_>0)?((double)x11/(double)s11_):1.0;#
      double denI=0.0;#
      if((1.0-pi01)>0.0) denI += x00*std::log(1.0-pi01);#
      if(pi01>0.0)       denI += x01*std::log(pi01);#
      if((1.0-pi11)>0.0) denI += x10*std::log(1.0-pi11);#
      if(pi11>0.0)       denI += x11*std::log(pi11);#
      lrind = -2.0*(numI - denI);#
    }#
    double LRcc = lruc + lrind;#
    dmap[LRcc] += p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(dmap.size());#
  for(auto &kv: dmap){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){return a.first<b.first;});#
  NumericVector LRvals, Pvals;#
  if(!vec.empty()){#
    double curLR=vec[0].first;#
    double curP=vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRvals.push_back(curLR);#
        Pvals.push_back(curP);#
        curLR=vec[i].first;#
        curP=vec[i].second;#
      }#
    }#
    LRvals.push_back(curLR);#
    Pvals.push_back(curP);#
  }#
  return List::create(Named("LR")=LRvals, Named("prob")=Pvals);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  if(!length(LRvals)) return(list(x=numeric(0),y=numeric(0)))#
  cum <- cumsum(probvals)#
  if(LRvals[1]>=0) {#
    x <- c(0, LRvals)#
    y <- c(0, cum)#
  } else {#
    x <- LRvals#
    y <- cum#
  }#
  list(x=x,y=y)#
}#
#
cdf_val <- function(x, xs, ys){#
  if(!length(xs)) return(0)#
  if(x<=xs[1]) return(0)#
  if(x>=xs[length(xs)]) return(ys[length(xs)])#
  i <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[i]#
}#
#
ks_diff <- function(LRvals, probvals, df=2){#
  d <- cdf_xy(LRvals, probvals)#
  xs <- d$x#
  ys <- d$y#
  if(!length(xs)) return(0)#
  xmax <- xs[length(xs)] + 1#
  seqx <- seq(0, xmax, length.out=800)#
  supd <- 0#
  for(xv in seqx){#
    Ft <- cdf_val(xv, xs, ys)#
    Fc <- pchisq(xv, df)#
    double_diff <- abs(Ft - Fc)#
    if(double_diff>supd) supd<-double_diff#
  }#
  supd#
}#
#
main_cc <- function(){#
  alpha_list <- c(0.01,0.025,0.05)#
  nmax <- 2000#
  nmin <- 1#
  step <- 1#
  plot(NA, xlim=c(nmin,nmax), ylim=c(0,1), xlab="n", ylab="KS distance", main="CDF difference (LRcc vs Chi2) vs n")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_cc_fastcpp(a)#
    nvals <- seq(nmin,nmax,by=step)#
    ksvals <- numeric(length(nvals))#
    for(ix in seq_along(nvals)){#
      t <- nvals[ix]#
      resNow <- dist_cc_at_current_fastcpp(dist_k, t, a)#
      kd <- ks_diff(resNow$LR, resNow$prob, 2)#
      ksvals[ix] <- kd#
      if(t < nmax) {#
        dist_k <- step_forward_cc_fastcpp(dist_k, a, 1e-15, nmax)#
      }#
    }#
    lines(nvals, ksvals, col=cols[i], lwd=2)#
    i <- i+1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list), col=cols, lty=1, lwd=2, bty="n")#
}#
#
main_cc()
# KS distance v.s. n  (LRcc)#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct CCState{ int last,c1,s00,s10,s01,s11; double prob; };#
struct LLHash{ std::size_t operator()(long long x)const{ return std::hash<long long>()(x); } };#
#
static inline long long encode_cc_state(int last,int c1,int s00,int s10,int s01,int s11,int nmax){#
  long long N=(long long)nmax+10, S2=N,S3=S2*N,S4=S3*N,S5=S4*N,S6=S5*N;#
  return (long long)last + S2*c1 + S3*s00 + S4*s10 + S5*s01 + S6*s11;#
}#
#
// initialise -------------------------------------------------------------#
[[Rcpp::export]]#
List initialize_cc_fastcpp(double alpha=0.05){#
  CCState s0{0,0,0,0,0,0,1.0-alpha}, s1{1,1,0,0,0,0,alpha};#
  return List::create(#
    _["last"] = IntegerVector::create(s0.last,s1.last),#
    _["c1"]   = IntegerVector::create(s0.c1,s1.c1),#
    _["s00"]  = IntegerVector::create(s0.s00,s1.s00),#
    _["s10"]  = IntegerVector::create(s0.s10,s1.s10),#
    _["s01"]  = IntegerVector::create(s0.s01,s1.s01),#
    _["s11"]  = IntegerVector::create(s0.s11,s1.s11),#
    _["prob"] = NumericVector::create(s0.prob,s1.prob) );#
}#
#
// one-step forward --------------------------------------------------------#
[[Rcpp::export]]#
List step_forward_cc_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"], c1=cur["c1"], a=cur["s00"], b=cur["s10"],#
                c=cur["s01"], d=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<long long,CCState,LLHash> mp; mp.reserve(l.size()*2);#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    CCState st{l[i],c1[i],a[i],b[i],c[i],d[i],p[i]};#
    // observe 0#
    CCState ns=st; (ns.last==0?ns.s00:ns.s10)++; ns.last=0; ns.prob*=1.0-alpha;#
    long long code=encode_cc_state(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
    mp[code].prob+=ns.prob; if(mp[code].prob==ns.prob) mp[code]=ns;#
    // observe 1#
    ns=st; (ns.last==0?ns.s01:ns.s11)++; ns.c1++; ns.last=1; ns.prob*=alpha;#
    code=encode_cc_state(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
    mp[code].prob+=ns.prob; if(mp[code].prob==ns.prob) mp[code]=ns;#
  }#
  // pack to list#
  int n=mp.size();#
  IntegerVector vl(n),vc1(n),vs00(n),vs10(n),vs01(n),vs11(n); NumericVector vp(n); int idx=0;#
  for(auto &kv:mp) if(kv.second.prob>=th){#
    vl[idx]=kv.second.last; vc1[idx]=kv.second.c1; vs00[idx]=kv.second.s00;#
    vs10[idx]=kv.second.s10; vs01[idx]=kv.second.s01; vs11[idx]=kv.second.s11;#
    vp[idx]=kv.second.prob; idx++;#
  }#
  vl.resize(idx);vc1.resize(idx);vs00.resize(idx);vs10.resize(idx);vs01.resize(idx);vs11.resize(idx);vp.resize(idx);#
  return List::create(_["last"]=vl,_["c1"]=vc1,_["s00"]=vs00,_["s10"]=vs10,#
                      _["s01"]=vs01,_["s11"]=vs11,_["prob"]=vp);#
}#
#
// LRcc distribution at time t --------------------------------------------#
[[Rcpp::export]]#
List dist_cc_at_current_fastcpp(List cur,int t,double alpha=0.05){#
  IntegerVector l=cur["last"],c1=cur["c1"],a=cur["s00"],b=cur["s10"],#
                c=cur["s01"],d=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<=0.0) continue;#
    int n1=c1[i], x00=a[i], x10=b[i], x01=c[i], x11=d[i];#
    double phat=(n1==0)?0.0:((n1==t)?1.0:(double)n1/t);#
    double p_ = std::max(std::min(alpha,1.0-EPS),EPS);#
    double ph_= std::max(std::min(phat ,1.0-EPS),EPS);#
    double lruc=-2.0*( n1*s_log(p_) + (t-n1)*s_log(1.0-p_)#
                     - n1*s_log(ph_) - (t-n1)*s_log(1.0-ph_) );#
    double lrind=0.0;#
    if(t>1){#
      int T0=x00+x10, T1=x01+x11;#
      double pH=(double)T1/(t-1);#
      double num=T0*s_log(1.0-pH)+T1*s_log(pH);#
      int s01_=x00+x01, s11_=x10+x11;#
      double pi01=(s01_>0)?(double)x01/s01_:1.0;#
      double pi11=(s11_>0)?(double)x11/s11_:1.0;#
      double den=x00*s_log(1.0-pi01)+x01*s_log(pi01)+#
                 x10*s_log(1.0-pi11)+x11*s_log(pi11);#
      lrind=-2.0*(num - den);#
    }#
    mp[lruc+lrind]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(), mp.end());#
  std::sort(v.begin(), v.end(), [](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0;#
    while(i<v.size() && std::fabs(v[i].first-cur)<1e-15){ sum+=v[i].second; i++; }#
    LR.push_back(cur); Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
# ---------- R helpers -----------------------------------------------------#
#
cdf_xy <- function(LRvals, probvals){#
  ok <- !is.na(LRvals) & !is.na(probvals) & probvals>0#
  LRvals <- LRvals[ok]; probvals <- probvals[ok]#
  if(!length(LRvals)) return(list(x=numeric(0),y=numeric(0)))#
  o <- order(LRvals)#
  xs <- c(0, LRvals[o])#
  ys <- c(0, cumsum(probvals[o]))#
  list(x=xs, y=ys)#
}#
#
cdf_val <- function(x, xx, yy){#
  if(!length(xx)) return(0)#
  if(x <= xx[1]) return(0)#
  if(x >= xx[length(xx)]) return(yy[length(yy)])#
  yy[findInterval(x, xx, rightmost.closed=TRUE)]#
}#
#
ks_diff <- function(LRvals, probvals, df=2){#
  d <- cdf_xy(LRvals, probvals)#
  if(!length(d$x)) return(0)#
  xsamp <- seq(0, tail(d$x,1)+1, length.out=800)#
  max(abs(cdf_val(xsamp,d$x,d$y) - pchisq(xsamp, df)))#
}#
#
# ---------- main plot -----------------------------------------------------#
#
main_cc <- function(){#
  alpha_list <- c(0.01,0.025,0.05)#
  nmax <- 2000#
  plot(NA, xlim=c(1,nmax), ylim=c(0,1), xlab="n", ylab="KS distance",#
       main="CDF difference (LRcc vs Chi2) vs n")#
  cols <- c("red","blue","green"); i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_cc_fastcpp(a)#
    nvals <- 1:nmax#
    ksvals <- numeric(nmax)#
    for(t in nvals){#
      res <- dist_cc_at_current_fastcpp(dist_k, t, a)#
      ksvals[t] <- ks_diff(res$LR, res$prob, 2)#
      if(t < nmax) dist_k <- step_forward_cc_fastcpp(dist_k, a, 1e-15, nmax)#
    }#
    lines(nvals, ksvals, col=cols[i], lwd=2); i <- i+1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list),#
         col=cols, lty=1, lwd=2, bty="n")#
}#
#
main_cc()
# KS distance v.s. n  ------------------------------------------------------#
#
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct CCState { int last,c1,s00,s10,s01,s11; double prob; };#
struct LLHash  { std::size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long ENC(int l,int c1,int a,int b,int c,int d,int n){#
  long long step=(long long)n+10, s2=step,s3=s2*step,s4=s3*step,s5=s4*step,s6=s5*step;#
  return l + s2*c1 + s3*a + s4*b + s5*c + s6*d;#
}#
#
// ---------- initial distribution ----------#
[[Rcpp::export]]#
List initialize_cc_fastcpp(double alpha=0.05){#
  CCState s0{0,0,0,0,0,0,1.0-alpha}, s1{1,1,0,0,0,0,alpha};#
  return List::create(_["last"]={s0.last,s1.last},#
                      _["c1"]  ={s0.c1 ,s1.c1 },#
                      _["s00"] ={s0.s00,s1.s00},#
                      _["s10"] ={s0.s10,s1.s10},#
                      _["s01"] ={s0.s01,s1.s01},#
                      _["s11"] ={s0.s11,s1.s11},#
                      _["prob"]={s0.prob,s1.prob});#
}#
#
// ---------- one-step forward ----------#
[[Rcpp::export]]#
List step_forward_cc_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"], c1=cur["c1"], a=cur["s00"], b=cur["s10"],#
                c=cur["s01"], d=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<long long,CCState,LLHash> mp; mp.reserve(l.size()*2);#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    CCState st{l[i],c1[i],a[i],b[i],c[i],d[i],p[i]};#
    { CCState ns=st; (ns.last==0?ns.s00:ns.s10)++; ns.last=0; ns.prob*=1.0-alpha;#
      mp[ENC(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax)].prob+=ns.prob; }#
    { CCState ns=st; (ns.last==0?ns.s01:ns.s11)++; ns.c1++; ns.last=1; ns.prob*=alpha;#
      mp[ENC(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax)].prob+=ns.prob; }#
  }#
  int m=mp.size();#
  IntegerVector L(m),C1(m),A(m),B(m),C(m),D(m); NumericVector P(m); int idx=0;#
  for(auto &kv:mp){#
    if(kv.second.prob<th) continue;#
    L[idx]=kv.second.last; C1[idx]=kv.second.c1; A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;  D[idx]=kv.second.s11; P[idx]=kv.second.prob; idx++;#
  }#
  L.resize(idx);C1.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["c1"]=C1,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
// ---------- LRcc distribution at time t ----------#
[[Rcpp::export]]#
List dist_cc_at_current_fastcpp(List cur,int t,double alpha=0.05){#
  IntegerVector l=cur["last"], c1=cur["c1"], a=cur["s00"], b=cur["s10"],#
                c=cur["s01"], d=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<=0.0) continue;#
    int n1=c1[i], x00=a[i], x10=b[i], x01=c[i], x11=d[i];#
    double phat=(n1==0)?0.0:((n1==t)?1.0:(double)n1/t);#
    double p_  = std::max(std::min(alpha,1.0-EPS),EPS);#
    double ph_ = std::max(std::min(phat ,1.0-EPS),EPS);#
    double lruc=-2.0*( n1*safe_log(p_) + (t-n1)*safe_log(1.0-p_)#
                     - n1*safe_log(ph_) - (t-n1)*safe_log(1.0-ph_) );#
    double lrind=0.0;#
    if(t>1){#
      int T0=x00+x10, T1=x01+x11;#
      double pH=(double)T1/(t-1);#
      double num=T0*safe_log(1.0-pH)+T1*safe_log(pH);#
      int s01_=x00+x01, s11_=x10+x11;#
      double pi01=(s01_>0)?(double)x01/s01_:1.0;#
      double pi11=(s11_>0)?(double)x11/s11_:1.0;#
      double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+#
                 x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
      lrind=-2.0*(num - den);#
    }#
    mp[lruc+lrind]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0;#
    while(i<v.size() && std::fabs(v[i].first-cur)<1e-15){ sum+=v[i].second; i++; }#
    LR.push_back(cur); Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
# ---------- helpers (sorted xs) ----------#
cdf_xy <- function(LRvals, probvals){#
  o  <- order(LRvals)#
  x0 <- c(LRvals[o], 0)#
  y0 <- c(cumsum(probvals[o]), 0)#
  o2 <- order(x0)#
  list(x = x0[o2], y = y0[o2])#
}#
#
cdf_val <- function(x, xs, ys){#
  ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
}#
#
ks_diff <- function(LRvals, probvals, df = 2){#
  if(!length(LRvals)) return(0)#
  d   <- cdf_xy(LRvals, probvals)#
  xs  <- seq(0, tail(d$x,1)+1, length.out = 800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
# ---------- main plot ----------#
main_cc <- function(){#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax <- 2000#
  plot(NA, xlim=c(1, nmax), ylim=c(0,1), xlab="n", ylab="KS distance",#
       main="CDF difference (LRcc vs Chi2) vs n")#
  cols <- c("red","blue","green"); i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_cc_fastcpp(a)#
    ksvals <- numeric(nmax)#
    for(t in 1:nmax){#
      res <- dist_cc_at_current_fastcpp(dist_k, t, a)#
      ksvals[t] <- ks_diff(res$LR, res$prob, 2)#
      if(t < nmax) dist_k <- step_forward_cc_fastcpp(dist_k, a, 1e-15, nmax)#
    }#
    lines(1:nmax, ksvals, col=cols[i], lwd=2); i <- i + 1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list),#
         col=cols, lty=1, lwd=2, bty="n")#
}#
#
main_cc()
# Histogram of KS distance#
#
library(Rcpp)#
#
forward_all_t_cc <- function(nmax, alpha, prune_threshold=1e-15) {#
  fw <- vector("list", nmax+1)#
  dist0 <- initialize_cc_fastcpp(alpha)#
  fw[[1]] <- list(last=dist0$last, c1=dist0$c1, s00=dist0$s00, s10=dist0$s10, s01=dist0$s01, s11=dist0$s11, prob=dist0$prob)#
  for(t in 2:(nmax+1)){#
    fw[[t]] <- step_forward_cc_fastcpp(fw[[t-1]], alpha, prune_threshold, nmax)#
  }#
  fw#
}#
#
LR_dist_from_forward_cc <- function(fw, t, alpha) {#
  if(t<=1) return(list(LR=0, prob=1))#
  lrres <- dist_cc_at_current_fastcpp(fw[[t]], t, alpha)#
  list(LR=lrres$LR, prob=lrres$prob)#
}#
#
cdf_val_cc <- function(x, xs, ys){#
  if(x <= xs[1]) return(0)#
  if(x >= xs[length(xs)]) return(ys[length(ys)])#
  i <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[i]#
}#
#
cdf_diff_cc <- function(LRvals, probvals, df=2){#
  ok <- !is.na(LRvals) & !is.na(probvals) & (probvals > 0)#
  if(!any(ok)) return(0)#
  LRvals <- LRvals[ok]#
  probvals <- probvals[ok]#
  LRvals[LRvals < 0] <- 0#
  o <- order(LRvals)#
  LRvals <- LRvals[o]#
  probvals <- probvals[o]#
  csum <- cumsum(probvals)#
  xs <- c(0, LRvals)#
  ys <- c(0, csum)#
  testx <- seq(0, xs[length(xs)] + 1, length.out=400)#
  supd <- 0#
  for(xv in testx){#
    ft <- cdf_val_cc(xv, xs, ys)#
    fc <- pchisq(xv, df)#
    d <- abs(ft - fc)#
    if(d > supd) supd <- d#
  }#
  supd#
}#
#
generate_data_points_cc <- function(){#
  n_list <- c(250, 500, 1000, 2000)#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax <- 2000#
  diff_mat <- matrix(0, nrow=nmax, ncol=length(alpha_list))#
  for(j in seq_along(alpha_list)){#
    fw <- forward_all_t_cc(nmax, alpha_list[j], 1e-15)#
    for(t in 1:nmax){#
      lp <- LR_dist_from_forward_cc(fw, t, alpha_list[j])#
      diff_mat[t, j] <- cdf_diff_cc(lp$LR, lp$prob, 2)#
    }#
  }#
  results <- list()#
  idx <- 1#
  for(n_ in n_list){#
    for(a_ in alpha_list){#
      j <- which(alpha_list==a_)#
      ks <- diff_mat[n_, j]#
      results[[idx]] <- c(n_, a_, ks)#
      idx <- idx + 1#
    }#
  }#
  results#
}#
#
plot_grouped_bar_cc <- function(results){#
  vals <- do.call(rbind, results)#
  n_list <- sort(unique(vals[,1]))#
  alpha_list <- sort(unique(vals[,2]))#
  m <- matrix(0, nrow=length(n_list), ncol=length(alpha_list))#
  for(i in seq_len(nrow(vals))){#
    rr <- vals[i,]#
    r_n <- which(n_list==rr[1])#
    c_a <- which(alpha_list==rr[2])#
    m[r_n, c_a] <- rr[3]#
  }#
  colset <- c("blue","orange","green3","red","purple")#
  barplot(t(m), beside=TRUE, names.arg=n_list, col=colset[1:length(alpha_list)],#
          xlab="n", ylab="KS distance", main="Histogram of KS distance (LRcc vs Chi2)")#
  abline(h=0.05, col="red", lty=2)#
  abline(h=0.1, col="red", lty=2)#
  legend_labels <- c(paste0("alpha=", alpha_list), "Threshold=0.05", "Threshold=0.1")#
  legend_colors <- c(colset[1:length(alpha_list)], "red", "red")#
  legend_lines <- c(rep(NA, length(alpha_list)), 2, 2)#
  legend_fill <- c(colset[1:length(alpha_list)], NA, NA)#
  legend("topright", legend=legend_labels, col=legend_colors, lty=legend_lines, fill=legend_fill, bty="n")#
}#
#
main_cc_bar <- function(){#
  results <- generate_data_points_cc()#
  for(i in seq_along(results)){#
    x <- results[[i]]#
    cat(sprintf("n=%d, alpha=%.3f, KS=%.5f\n", x[1], x[2], x[3]))#
    if(i %% 3 == 0) cat("\n")#
  }#
  plot_grouped_bar_cc(results)#
}#
#
res_cc <- main_cc_bar()
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
#---------  Exact LRcc distribution via dynamic programming -------------##
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);} #
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M,S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  State s0{0,0,0,0,0,0,1.0-alpha}; cur[enc6(0,0,0,0,0,0,NMAX)]=s0;#
  State s1{1,1,0,0,0,0,alpha};      cur[enc6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.c1++; ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double lruc=0.0,lrind=0.0;#
    {#
      double p_ = alpha; if(p_<EPS) p_=EPS; if(p_>1-EPS) p_=1-EPS;#
      double phat=c1==0?0.0:(c1==n?1.0:(double)c1/n);#
      double ph_=std::max(std::min(phat,1.0-EPS),EPS);#
      lruc = -2.0*( c1*std::log(p_) + (n-c1)*std::log(1.0-p_) - c1*std::log(ph_) - (n-c1)*std::log(1.0-ph_) );#
    }#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat=(double)T1/(double)(n-1);#
      double num=T0*s_log(1.0-pHat)+T1*s_log(pHat);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind = -2.0*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first, curP=0.0;#
    while(i<vec.size() && fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
#---------  Path-wise LRcc  ---------------------------------------------##
LRuc_count <- function(x, n, p){#
  p_   <- pmax(pmin(p, 1 - EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat, 1 - EPS), EPS)#
  -2*(x*safe_log(p_) + (n-x)*safe_log(1-p_) - x*safe_log(ph_) - (n-x)*safe_log(1-ph_))#
}#
LRind_count <- function(T00,T10,T01,T11,n){#
  if(n<=1) return(0)#
  T0 <- T00+T10; T1<-T01+T11#
  pHat <- T1/(n-1)#
  num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); if(n<1) return(0)#
  x <- sum(X)#
  counts <- matrix(0,2,2)#
  if(n>1){#
    for(t in 2:n){counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1]+1}#
  }#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  LRuc_count(x,n,alpha)+LRind_count(T00,T10,T01,T11,n)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
gen_markov <- function(n, alpha, phi=0.6){#
  p11 <- phi; p01 <- alpha*(1-phi)/(1-alpha)#
  X <- numeric(n); X[1] <- rbinom(1,1,alpha)#
  for(i in 2:n) X[i] <- rbinom(1,1, ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results_size <- data.frame(); results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)#
    LRvals <- dist$LR; probvals <- dist$prob#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRcc(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 2)#
      rej_ex[i] <- (p_ex < 0.05); rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex); se_ex <- sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch <- mean(rej_ch); se_ch <- sqrt(size_ch*(1-size_ch)/Nrep)#
    results_size <- rbind(results_size, data.frame(n=n_, alpha=alpha_, size_exact=size_ex, se_size_exact=se_ex,#
                                                  size_chi2_2=size_ch, se_size_chi2_2=se_ch))#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRcc(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 2)#
      pow_ex[i] <- (p_ex < 0.05); pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex <- mean(pow_ex); se_pe <- sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch <- mean(pow_ch); se_pc <- sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power <- rbind(results_power, data.frame(n=n_, alpha=alpha_, power_exact=p_ex, se_power_exact=se_pe,#
                                                    power_chi2_2=p_ch, se_power_chi2_2=se_pc))#
  }#
}#
#
size_df <- pivot_longer(results_size, cols=c(size_exact,size_chi2_2), names_to="method", values_to="value")#
size_df$method[size_df$method=="size_chi2_2"] <- "size_chi2(2)"#
#
power_df <- pivot_longer(results_power, cols=c(power_exact,power_chi2_2), names_to="method", values_to="value")#
power_df$method[power_df$method=="power_chi2_2"] <- "power_chi2(2)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_2),#
                    ymax=value+1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+geom_hline(yintercept=0.05, colour="red", linetype="dashed")+#
  labs(x="n", y="empirical size (α=5%)")+theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2),#
                    ymax=value+1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+labs(x="n", y="empirical power (φ=0.6)")+theme_minimal()#
#
print(p_power / p_size)
n_phi <- 250#
alpha_phi <- 0.05#
phi_list <- c(0.2, 0.4, 0.6, 0.8, 0.9)#
dist_phi <- fb_lrcc(n_phi, alpha_phi)#
LRv <- dist_phi$LR; Pv <- dist_phi$prob#
phi_df <- data.frame()#
for(ph in phi_list){#
  ex <- ch <- numeric(Nrep)#
  for(i in 1:Nrep){#
    X  <- gen_markov(n_phi, alpha_phi, ph)#
    LR <- my_compute_LRcc(X, alpha_phi)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 2)#
    ex[i] <- (p_e < 0.05)#
    ch[i] <- (p_c < 0.05)#
  }#
  phi_df <- rbind(phi_df,#
    data.frame(phi=ph, method="exact",   power=mean(ex),#
               se=sqrt(mean(ex)*(1-mean(ex))/Nrep)),#
    data.frame(phi=ph, method="chi2(2)", power=mean(ch),#
               se=sqrt(mean(ch)*(1-mean(ch))/Nrep)))#
}#
#
ggplot(phi_df, aes(phi, power, color=method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin=power-1.96*se, ymax=power+1.96*se), width=0.02)+#
  scale_x_continuous(breaks=phi_list)+#
  labs(x="phi", y="empirical power (n=250, α=0.05)")+#
  theme_minimal()
exception_df <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names = 1)#
alpha_vec <- c(0.05, 0.025, 0.01)#
colnames(exception_df) <- as.character(alpha_vec)#
#
n_win <- 250#
series_len <- nrow(exception_df)#
plot_df <- data.frame()#
#
for(a in alpha_vec){#
  X_full <- exception_df[[as.character(a)]]#
  dist   <- fb_lrcc(n_win, a)#
  LRv    <- dist$LR; Pv <- dist$prob#
  idx_max <- series_len - n_win + 1#
  for(idx in 1:idx_max){#
    seg  <- X_full[idx:(idx + n_win - 1)]#
    LR   <- my_compute_LRcc(seg, a)#
    p_e  <- get_pval_exact(LRv, Pv, LR)#
    p_c  <- 1 - pchisq(LR, 2)#
    plot_df <- rbind(plot_df,#
      data.frame(idx = idx, alpha = a, method = "exact",   p_value = p_e),#
      data.frame(idx = idx, alpha = a, method = "chi2(2)", p_value = p_c))#
  }#
}#
#
ggplot(plot_df, aes(idx, p_value, color = method)) +#
  geom_line() +#
  facet_wrap(~alpha, labeller = label_both, ncol = 1) +#
  geom_hline(yintercept = 0.05, linetype = "dashed", colour = "red") +#
  labs(x = "window start index", y = "p-value") +#
  theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2),#
                    ymax=value+1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+labs(x="n", y="empirical power (φ=0.6)")+theme_minimal()#
#
print(p_power / p_size)#
#
#---------  Power vs phi  ----------------------------------------------##
#
n_phi <- 250#
alpha_phi <- 0.05#
phi_list <- c(0.2, 0.4, 0.6, 0.8, 0.9)#
dist_phi <- fb_lrcc(n_phi, alpha_phi)#
LRv <- dist_phi$LR; Pv <- dist_phi$prob#
phi_df <- data.frame()#
for(ph in phi_list){#
  ex <- ch <- numeric(Nrep)#
  for(i in 1:Nrep){#
    X  <- gen_markov(n_phi, alpha_phi, ph)#
    LR <- my_compute_LRcc(X, alpha_phi)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 2)#
    ex[i] <- (p_e < 0.05)#
    ch[i] <- (p_c < 0.05)#
  }#
  phi_df <- rbind(phi_df,#
    data.frame(phi=ph, method="exact",   power=mean(ex),#
               se=sqrt(mean(ex)*(1-mean(ex))/Nrep)),#
    data.frame(phi=ph, method="chi2(2)", power=mean(ch),#
               se=sqrt(mean(ch)*(1-mean(ch))/Nrep)))#
}#
#
ggplot(phi_df, aes(phi, power, color=method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin=power-1.96*se, ymax=power+1.96*se), width=0.02)+#
  scale_x_continuous(breaks=phi_list)+#
  labs(x="phi", y="empirical power (n=250, α=0.05)")+#
  theme_minimal()
exception_df <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names = 1)#
alpha_vec <- c(0.05, 0.025, 0.01)#
colnames(exception_df) <- as.character(alpha_vec)#
#
n_win <- 250#
series_len <- nrow(exception_df)#
plot_df <- data.frame()#
#
for(a in alpha_vec){#
  X_full <- exception_df[[as.character(a)]]#
  dist   <- fb_lrcc(n_win, a)#
  LRv    <- dist$LR; Pv <- dist$prob#
  idx_max <- series_len - n_win + 1#
  for(idx in 1:idx_max){#
    seg  <- X_full[idx:(idx + n_win - 1)]#
    LR   <- my_compute_LRcc(seg, a)#
    p_e  <- get_pval_exact(LRv, Pv, LR)#
    p_c  <- 1 - pchisq(LR, 2)#
    plot_df <- rbind(plot_df,#
      data.frame(idx = idx, alpha = a, method = "exact",   p_value = p_e),#
      data.frame(idx = idx, alpha = a, method = "chi2(2)", p_value = p_c))#
  }#
}#
#
ggplot(plot_df, aes(idx, p_value, color = method)) +#
  geom_line() +#
  facet_wrap(~alpha, labeller = label_both, ncol = 1) +#
  geom_hline(yintercept = 0.05, linetype = "dashed", colour = "red") +#
  labs(x = "window start index", y = "p-value") +#
  theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2),#
                    ymax=value+1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+labs(x="n", y="empirical power (φ=0.6)")+theme_minimal()#
#
print(p_power / p_size)#
#
#---------  Power vs phi  ----------------------------------------------##
#
n_phi <- 250#
alpha_phi <- 0.05#
phi_list <- c(0.2, 0.4, 0.6, 0.8, 0.9)#
dist_phi <- fb_lrcc(n_phi, alpha_phi)#
LRv <- dist_phi$LR; Pv <- dist_phi$prob#
phi_df <- data.frame()#
for(ph in phi_list){#
  ex <- ch <- numeric(Nrep)#
  for(i in 1:Nrep){#
    X  <- gen_markov(n_phi, alpha_phi, ph)#
    LR <- my_compute_LRcc(X, alpha_phi)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 2)#
    ex[i] <- (p_e < 0.05)#
    ch[i] <- (p_c < 0.05)#
  }#
  phi_df <- rbind(phi_df,#
    data.frame(phi=ph, method="exact",   power=mean(ex),#
               se=sqrt(mean(ex)*(1-mean(ex))/Nrep)),#
    data.frame(phi=ph, method="chi2(2)", power=mean(ch),#
               se=sqrt(mean(ch)*(1-mean(ch))/Nrep)))#
}#
#
ggplot(phi_df, aes(phi, power, color=method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin=power-1.96*se, ymax=power+1.96*se), width=0.02)+#
  scale_x_continuous(breaks=phi_list)+#
  labs(x="phi", y="empirical power (n=250, α=0.05)")+#
  theme_minimal()#
exception_df <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names = 1)#
alpha_vec <- c(0.05, 0.025, 0.01)#
colnames(exception_df) <- as.character(alpha_vec)#
#
n_win <- 250#
series_len <- nrow(exception_df)#
plot_df <- data.frame()#
#
for(a in alpha_vec){#
  X_full <- exception_df[[as.character(a)]]#
  dist   <- fb_lrcc(n_win, a)#
  LRv    <- dist$LR; Pv <- dist$prob#
  idx_max <- series_len - n_win + 1#
  for(idx in 1:idx_max){#
    seg  <- X_full[idx:(idx + n_win - 1)]#
    LR   <- my_compute_LRcc(seg, a)#
    p_e  <- get_pval_exact(LRv, Pv, LR)#
    p_c  <- 1 - pchisq(LR, 2)#
    plot_df <- rbind(plot_df,#
      data.frame(idx = idx, alpha = a, method = "exact",   p_value = p_e),#
      data.frame(idx = idx, alpha = a, method = "chi2(2)", p_value = p_c))#
  }#
}#
#
ggplot(plot_df, aes(idx, p_value, color = method)) +#
  geom_line() +#
  facet_wrap(~alpha, labeller = label_both, ncol = 1) +#
  geom_hline(yintercept = 0.05, linetype = "dashed", colour = "red") +#
  labs(x = "window start index", y = "p-value") +#
  theme_minimal()
# Empirical Comparison on simulated data:#
#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);} #
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M,S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  State s0{0,0,0,0,0,0,1.0-alpha}; cur[enc6(0,0,0,0,0,0,NMAX)]=s0;#
  State s1{1,1,0,0,0,0,alpha};      cur[enc6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.c1++; ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double lruc=0.0,lrind=0.0;#
    {#
      double p_ = alpha; if(p_<EPS) p_=EPS; if(p_>1-EPS) p_=1-EPS;#
      double phat=c1==0?0.0:(c1==n?1.0:(double)c1/n);#
      double ph_=std::max(std::min(phat,1.0-EPS),EPS);#
      lruc = -2.0*( c1*std::log(p_) + (n-c1)*std::log(1.0-p_) - c1*std::log(ph_) - (n-c1)*std::log(1.0-ph_) );#
    }#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat=(double)T1/(double)(n-1);#
      double num=T0*s_log(1.0-pHat)+T1*s_log(pHat);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind = -2.0*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first, curP=0.0;#
    while(i<vec.size() && fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
LRuc_count <- function(x, n, p){#
  p_   <- pmax(pmin(p, 1 - EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat, 1 - EPS), EPS)#
  -2*(x*safe_log(p_) + (n-x)*safe_log(1-p_) - x*safe_log(ph_) - (n-x)*safe_log(1-ph_))#
}#
LRind_count <- function(T00,T10,T01,T11,n){#
  if(n<=1) return(0)#
  T0 <- T00+T10; T1<-T01+T11#
  pHat <- T1/(n-1)#
  num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); if(n<1) return(0)#
  x <- sum(X)#
  counts <- matrix(0,2,2)#
  if(n>1){#
    for(t in 2:n){counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1]+1}#
  }#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  LRuc_count(x,n,alpha)+LRind_count(T00,T10,T01,T11,n)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
gen_markov <- function(n, alpha, phi=0.6){#
  p11 <- phi; p01 <- alpha*(1-phi)/(1-alpha)#
  X <- numeric(n); X[1] <- rbinom(1,1,alpha)#
  for(i in 2:n) X[i] <- rbinom(1,1, ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results_size <- data.frame(); results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)#
    LRvals <- dist$LR; probvals <- dist$prob#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRcc(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 2)#
      rej_ex[i] <- (p_ex < 0.05); rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex); se_ex <- sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch <- mean(rej_ch); se_ch <- sqrt(size_ch*(1-size_ch)/Nrep)#
    results_size <- rbind(results_size, data.frame(n=n_, alpha=alpha_, size_exact=size_ex, se_size_exact=se_ex,#
                                                  size_chi2_2=size_ch, se_size_chi2_2=se_ch))#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRcc(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 2)#
      pow_ex[i] <- (p_ex < 0.05); pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex <- mean(pow_ex); se_pe <- sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch <- mean(pow_ch); se_pc <- sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power <- rbind(results_power, data.frame(n=n_, alpha=alpha_, power_exact=p_ex, se_power_exact=se_pe,#
                                                    power_chi2_2=p_ch, se_power_chi2_2=se_pc))#
  }#
}#
#
size_df <- pivot_longer(results_size, cols=c(size_exact,size_chi2_2), names_to="method", values_to="value")#
size_df$method[size_df$method=="size_chi2_2"] <- "size_chi2(2)"#
#
power_df <- pivot_longer(results_power, cols=c(power_exact,power_chi2_2), names_to="method", values_to="value")#
power_df$method[power_df$method=="power_chi2_2"] <- "power_chi2(2)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_2),#
                    ymax=value+1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+geom_hline(yintercept=0.05, colour="red", linetype="dashed")+#
  labs(x="n", y="empirical size (α=5%)")+theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2),#
                    ymax=value+1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+labs(x="n", y="empirical power (φ=0.6)")+theme_minimal()#
#
print(p_power / p_size)
## Power v.s. phi#
#
n_phi <- 250#
alpha_phi <- 0.05#
phi_list <- c(0.2, 0.4, 0.6, 0.8, 0.9)#
dist_phi <- fb_lrcc(n_phi, alpha_phi)#
LRv <- dist_phi$LR; Pv <- dist_phi$prob#
phi_df <- data.frame()#
for(ph in phi_list){#
  ex <- ch <- numeric(Nrep)#
  for(i in 1:Nrep){#
    X  <- gen_markov(n_phi, alpha_phi, ph)#
    LR <- my_compute_LRcc(X, alpha_phi)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 2)#
    ex[i] <- (p_e < 0.05)#
    ch[i] <- (p_c < 0.05)#
  }#
  phi_df <- rbind(phi_df,#
    data.frame(phi=ph, method="exact",   power=mean(ex),#
               se=sqrt(mean(ex)*(1-mean(ex))/Nrep)),#
    data.frame(phi=ph, method="chi2(2)", power=mean(ch),#
               se=sqrt(mean(ch)*(1-mean(ch))/Nrep)))#
}#
#
ggplot(phi_df, aes(phi, power, color=method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin=power-1.96*se, ymax=power+1.96*se), width=0.02)+#
  scale_x_continuous(breaks=phi_list)+#
  labs(x="phi", y="empirical power (n=250, α=0.05)")+#
  theme_minimal()
# Compare daily rolling-window p-values on the real VaR exception 0/1 series#
#
exception_df <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names = 1)#
alpha_vec <- c(0.05, 0.025, 0.01)#
colnames(exception_df) <- as.character(alpha_vec)#
#
n_win <- 250#
series_len <- nrow(exception_df)#
plot_df <- data.frame()#
#
for(a in alpha_vec){#
  X_full <- exception_df[[as.character(a)]]#
  dist   <- fb_lrcc(n_win, a)#
  LRv    <- dist$LR; Pv <- dist$prob#
  idx_max <- series_len - n_win + 1#
  for(idx in 1:idx_max){#
    seg  <- X_full[idx:(idx + n_win - 1)]#
    LR   <- my_compute_LRcc(seg, a)#
    p_e  <- get_pval_exact(LRv, Pv, LR)#
    p_c  <- 1 - pchisq(LR, 2)#
    plot_df <- rbind(plot_df,#
      data.frame(idx = idx, alpha = a, method = "exact",   p_value = p_e),#
      data.frame(idx = idx, alpha = a, method = "chi2(2)", p_value = p_c))#
  }#
}#
#
ggplot(plot_df, aes(idx, p_value, color = method)) +#
  geom_line() +#
  facet_wrap(~alpha, labeller = label_both, ncol = 1) +#
  geom_hline(yintercept = 0.05, linetype = "dashed", colour = "red") +#
  labs(x = "window start index", y = "p-value") +#
  theme_minimal()
# Empirical Comparison on simulated data: #
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    cur[encode5(0,0,0,0,0,NMAX)]=s0;#
    State s1{1,0,0,0,0,alpha};#
    cur[encode5(1,0,0,0,0,NMAX)]=s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat = (double)T1 / (double)(n-1);#
      double num = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      LR=-2.0*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first,curP=0.0;#
    while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha) fb_lrind_fastcpp(n, alpha, 1e-15)#
#
my_compute_LRind <- function(X, alpha){#
  n <- length(X); if(n < 2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00 <- T00 + 1 else#
    if(X[i-1]==0&&X[i]==1) T01 <- T01 + 1 else#
    if(X[i-1]==1&&X[i]==0) T10 <- T10 + 1 else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10; T1 <- T01 + T11#
  pHat <- if(n > 1) T1 / (n - 1) else 0#
  num  <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  s01 <- T00 + T01; pi01 <- if(s01 > 0) T01/s01 else 1#
  s11 <- T10 + T11; pi11 <- if(s11 > 0) T11/s11 else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
gen_markov <- function(n, alpha, phi = 0.6){#
  p11 <- phi; p01 <- alpha*(1 - phi)/(1 - alpha)#
  X <- numeric(n); X[1] <- rbinom(1, 1, alpha)#
  for(i in 2:n) X[i] <- rbinom(1, 1, ifelse(X[i-1]==1, p11, p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results_size <- data.frame(); results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrind(n_, alpha_)#
    LRvals <- dist$LR; probvals <- dist$prob#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      rej_ex[i] <- (p_ex < 0.05); rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex)#
    se_ex <- sqrt(size_ex*(1 - size_ex)/Nrep)#
    size_ch <- mean(rej_ch)#
    se_ch <- sqrt(size_ch*(1 - size_ch)/Nrep)#
    results_size <- rbind(results_size,#
      data.frame(n = n_, alpha = alpha_, size_exact = size_ex, se_size_exact = se_ex,#
                 size_chi2_1 = size_ch, se_size_chi2_1 = se_ch))#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      pow_ex[i] <- (p_ex < 0.05); pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex <- mean(pow_ex)#
    se_pe <- sqrt(p_ex*(1 - p_ex)/Nrep)#
    p_ch <- mean(pow_ch)#
    se_pc <- sqrt(p_ch*(1 - p_ch)/Nrep)#
    results_power <- rbind(results_power,#
      data.frame(n = n_, alpha = alpha_, power_exact = p_ex, se_power_exact = se_pe,#
                 power_chi2_1 = p_ch, se_power_chi2_1 = se_pc))#
  }#
}#
#
size_df <- pivot_longer(results_size, cols = c(size_exact, size_chi2_1),#
                        names_to = "method", values_to = "value")#
size_df$method[size_df$method == "size_chi2_1"] <- "size_chi2(1)"#
#
power_df <- pivot_longer(results_power, cols = c(power_exact, power_chi2_1),#
                         names_to = "method", values_to = "value")#
power_df$method[power_df$method == "power_chi2_1"] <- "power_chi2(1)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill = method))+#
  geom_bar(stat = "identity", position = "dodge")+#
  geom_errorbar(aes(ymin = value - 1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1),#
                    ymax = value + 1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_wrap(~alpha, labeller = label_both)+#
  geom_hline(yintercept = 0.05, colour = "red", linetype = "dashed")+#
  labs(x = "n", y = "empirical size (α=5%)")+#
  theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill = method))+#
  geom_bar(stat = "identity", position = "dodge")+#
  geom_errorbar(aes(ymin = value - 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1),#
                    ymax = value + 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_wrap(~alpha, labeller = label_both)+#
  labs(x = "n", y = "empirical power (φ=0.6)")+#
  theme_minimal()#
#
print(p_power / p_size)#
# Empirical Comparison on simulated data: #
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    cur[encode5(0,0,0,0,0,NMAX)]=s0;#
    State s1{1,0,0,0,0,alpha};#
    cur[encode5(1,0,0,0,0,NMAX)]=s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat = (double)T1 / (double)(n-1);#
      double num = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      LR=-2.0*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first,curP=0.0;#
    while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha) fb_lrind_fastcpp(n, alpha, 1e-15)#
#
my_compute_LRind <- function(X, alpha){#
  n <- length(X); if(n < 2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00 <- T00 + 1 else#
    if(X[i-1]==0&&X[i]==1) T01 <- T01 + 1 else#
    if(X[i-1]==1&&X[i]==0) T10 <- T10 + 1 else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10; T1 <- T01 + T11#
  pHat <- if(n > 1) T1 / (n - 1) else 0#
  num  <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  s01 <- T00 + T01; pi01 <- if(s01 > 0) T01/s01 else 1#
  s11 <- T10 + T11; pi11 <- if(s11 > 0) T11/s11 else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
gen_markov <- function(n, alpha, phi = 0.6){#
  p11 <- phi; p01 <- alpha*(1 - phi)/(1 - alpha)#
  X <- numeric(n); X[1] <- rbinom(1, 1, alpha)#
  for(i in 2:n) X[i] <- rbinom(1, 1, ifelse(X[i-1]==1, p11, p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results_size <- data.frame(); results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrind(n_, alpha_)#
    LRvals <- dist$LR; probvals <- dist$prob#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      rej_ex[i] <- (p_ex < 0.05); rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex)#
    se_ex <- sqrt(size_ex*(1 - size_ex)/Nrep)#
    size_ch <- mean(rej_ch)#
    se_ch <- sqrt(size_ch*(1 - size_ch)/Nrep)#
    results_size <- rbind(results_size,#
      data.frame(n = n_, alpha = alpha_, size_exact = size_ex, se_size_exact = se_ex,#
                 size_chi2_1 = size_ch, se_size_chi2_1 = se_ch))#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      pow_ex[i] <- (p_ex < 0.05); pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex <- mean(pow_ex)#
    se_pe <- sqrt(p_ex*(1 - p_ex)/Nrep)#
    p_ch <- mean(pow_ch)#
    se_pc <- sqrt(p_ch*(1 - p_ch)/Nrep)#
    results_power <- rbind(results_power,#
      data.frame(n = n_, alpha = alpha_, power_exact = p_ex, se_power_exact = se_pe,#
                 power_chi2_1 = p_ch, se_power_chi2_1 = se_pc))#
  }#
}#
#
size_df <- pivot_longer(results_size, cols = c(size_exact, size_chi2_1),#
                        names_to = "method", values_to = "value")#
size_df$method[size_df$method == "size_chi2_1"] <- "size_chi2(1)"#
#
power_df <- pivot_longer(results_power, cols = c(power_exact, power_chi2_1),#
                         names_to = "method", values_to = "value")#
power_df$method[power_df$method == "power_chi2_1"] <- "power_chi2(1)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill = method))+#
  geom_bar(stat = "identity", position = "dodge")+#
  geom_errorbar(aes(ymin = value - 1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1),#
                    ymax = value + 1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_wrap(~alpha, labeller = label_both)+#
  geom_hline(yintercept = 0.05, colour = "red", linetype = "dashed")+#
  labs(x = "n", y = "empirical size (α=5%)")+#
  theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill = method))+#
  geom_bar(stat = "identity", position = "dodge")+#
  geom_errorbar(aes(ymin = value - 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1),#
                    ymax = value + 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_wrap(~alpha, labeller = label_both)+#
  labs(x = "n", y = "empirical power (φ=0.6)")+#
  theme_minimal()#
#
print(p_power / p_size)
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);} #
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M,S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  State s0{0,0,0,0,0,0,1.0-alpha}; cur[enc6(0,0,0,0,0,0,NMAX)]=s0;#
  State s1{1,1,0,0,0,0,alpha};      cur[enc6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.c1++; ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double lruc=0.0,lrind=0.0;#
    {#
      double p_ = alpha; if(p_<EPS) p_=EPS; if(p_>1-EPS) p_=1-EPS;#
      double phat=c1==0?0.0:(c1==n?1.0:(double)c1/n);#
      double ph_=std::max(std::min(phat,1.0-EPS),EPS);#
      lruc = -2.0*( c1*std::log(p_) + (n-c1)*std::log(1.0-p_) - c1*std::log(ph_) - (n-c1)*std::log(1.0-ph_) );#
    }#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat=(double)T1/(double)(n-1);#
      double num=T0*s_log(1.0-pHat)+T1*s_log(pHat);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind = -2.0*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first, curP=0.0;#
    while(i<vec.size() && fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
LRuc_count <- function(x, n, p){#
  p_   <- pmax(pmin(p, 1 - EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat, 1 - EPS), EPS)#
  -2*(x*safe_log(p_) + (n-x)*safe_log(1-p_) - x*safe_log(ph_) - (n-x)*safe_log(1-ph_))#
}#
LRind_count <- function(T00,T10,T01,T11,n){#
  if(n<=1) return(0)#
  T0 <- T00+T10; T1<-T01+T11#
  pHat <- T1/(n-1)#
  num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); if(n<1) return(0)#
  x <- sum(X)#
  counts <- matrix(0,2,2)#
  if(n>1){#
    for(t in 2:n){counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1]+1}#
  }#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  LRuc_count(x,n,alpha)+LRind_count(T00,T10,T01,T11,n)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
gen_markov <- function(n, alpha, phi=0.6){#
  p11 <- phi; p01 <- alpha*(1-phi)/(1-alpha)#
  X <- numeric(n); X[1] <- rbinom(1,1,alpha)#
  for(i in 2:n) X[i] <- rbinom(1,1, ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results_size <- data.frame(); results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)#
    LRvals <- dist$LR; probvals <- dist$prob#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRcc(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 2)#
      rej_ex[i] <- (p_ex < 0.05); rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex); se_ex <- sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch <- mean(rej_ch); se_ch <- sqrt(size_ch*(1-size_ch)/Nrep)#
    results_size <- rbind(results_size, data.frame(n=n_, alpha=alpha_, size_exact=size_ex, se_size_exact=se_ex,#
                                                  size_chi2_2=size_ch, se_size_chi2_2=se_ch))#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRcc(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 2)#
      pow_ex[i] <- (p_ex < 0.05); pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex <- mean(pow_ex); se_pe <- sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch <- mean(pow_ch); se_pc <- sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power <- rbind(results_power, data.frame(n=n_, alpha=alpha_, power_exact=p_ex, se_power_exact=se_pe,#
                                                    power_chi2_2=p_ch, se_power_chi2_2=se_pc))#
  }#
}#
#
size_df <- pivot_longer(results_size, cols=c(size_exact,size_chi2_2), names_to="method", values_to="value")#
size_df$method[size_df$method=="size_chi2_2"] <- "size_chi2(2)"#
#
power_df <- pivot_longer(results_power, cols=c(power_exact,power_chi2_2), names_to="method", values_to="value")#
power_df$method[power_df$method=="power_chi2_2"] <- "power_chi2(2)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_2),#
                    ymax=value+1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+geom_hline(yintercept=0.05, colour="red", linetype="dashed")+#
  labs(x="n", y="empirical size (significance level = 5%)")+theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2),#
                    ymax=value+1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+labs(x="n", y="empirical power (φ=0.6)")+theme_minimal()#
#
print(p_power / p_size)#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);} #
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M,S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  State s0{0,0,0,0,0,0,1.0-alpha}; cur[enc6(0,0,0,0,0,0,NMAX)]=s0;#
  State s1{1,1,0,0,0,0,alpha};      cur[enc6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.c1++; ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double lruc=0.0,lrind=0.0;#
    {#
      double p_ = alpha; if(p_<EPS) p_=EPS; if(p_>1-EPS) p_=1-EPS;#
      double phat=c1==0?0.0:(c1==n?1.0:(double)c1/n);#
      double ph_=std::max(std::min(phat,1.0-EPS),EPS);#
      lruc = -2.0*( c1*std::log(p_) + (n-c1)*std::log(1.0-p_) - c1*std::log(ph_) - (n-c1)*std::log(1.0-ph_) );#
    }#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat=(double)T1/(double)(n-1);#
      double num=T0*s_log(1.0-pHat)+T1*s_log(pHat);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind = -2.0*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first, curP=0.0;#
    while(i<vec.size() && fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
LRuc_count <- function(x, n, p){#
  p_   <- pmax(pmin(p, 1 - EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat, 1 - EPS), EPS)#
  -2*(x*safe_log(p_) + (n-x)*safe_log(1-p_) - x*safe_log(ph_) - (n-x)*safe_log(1-ph_))#
}#
LRind_count <- function(T00,T10,T01,T11,n){#
  if(n<=1) return(0)#
  T0 <- T00+T10; T1<-T01+T11#
  pHat <- T1/(n-1)#
  num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); if(n<1) return(0)#
  x <- sum(X)#
  counts <- matrix(0,2,2)#
  if(n>1){#
    for(t in 2:n){counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1]+1}#
  }#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  LRuc_count(x,n,alpha)+LRind_count(T00,T10,T01,T11,n)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
gen_markov <- function(n, alpha, phi=0.6){#
  p11 <- phi; p01 <- alpha*(1-phi)/(1-alpha)#
  X <- numeric(n); X[1] <- rbinom(1,1,alpha)#
  for(i in 2:n) X[i] <- rbinom(1,1, ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results_size <- data.frame(); results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)#
    LRvals <- dist$LR; probvals <- dist$prob#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRcc(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 2)#
      rej_ex[i] <- (p_ex < 0.05); rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex); se_ex <- sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch <- mean(rej_ch); se_ch <- sqrt(size_ch*(1-size_ch)/Nrep)#
    results_size <- rbind(results_size, data.frame(n=n_, alpha=alpha_, size_exact=size_ex, se_size_exact=se_ex,#
                                                  size_chi2_2=size_ch, se_size_chi2_2=se_ch))#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRcc(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 2)#
      pow_ex[i] <- (p_ex < 0.05); pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex <- mean(pow_ex); se_pe <- sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch <- mean(pow_ch); se_pc <- sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power <- rbind(results_power, data.frame(n=n_, alpha=alpha_, power_exact=p_ex, se_power_exact=se_pe,#
                                                    power_chi2_2=p_ch, se_power_chi2_2=se_pc))#
  }#
}#
#
size_df <- pivot_longer(results_size, cols=c(size_exact,size_chi2_2), names_to="method", values_to="value")#
size_df$method[size_df$method=="size_chi2_2"] <- "size_chi2(2)"#
#
power_df <- pivot_longer(results_power, cols=c(power_exact,power_chi2_2), names_to="method", values_to="value")#
power_df$method[power_df$method=="power_chi2_2"] <- "power_chi2(2)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_2),#
                    ymax=value+1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+geom_hline(yintercept=0.05, colour="red", linetype="dashed")+#
  labs(x="n", y="empirical size (significance level = 5%)")+theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2),#
                    ymax=value+1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+labs(x="n", y="empirical power (φ=0.6)")+theme_minimal()#
#
print(p_power / p_size)
n_phi <- 250#
alpha_phi <- 0.05#
phi_list <- c(0.2, 0.4, 0.6, 0.8, 0.9)#
dist_phi <- fb_lrcc(n_phi, alpha_phi)#
LRv <- dist_phi$LR; Pv <- dist_phi$prob#
phi_df <- data.frame()#
for(ph in phi_list){#
  ex <- ch <- numeric(Nrep)#
  for(i in 1:Nrep){#
    X  <- gen_markov(n_phi, alpha_phi, ph)#
    LR <- my_compute_LRcc(X, alpha_phi)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 2)#
    ex[i] <- (p_e < 0.05)#
    ch[i] <- (p_c < 0.05)#
  }#
  phi_df <- rbind(phi_df,#
    data.frame(phi=ph, method="exact",   power=mean(ex),#
               se=sqrt(mean(ex)*(1-mean(ex))/Nrep)),#
    data.frame(phi=ph, method="chi2(2)", power=mean(ch),#
               se=sqrt(mean(ch)*(1-mean(ch))/Nrep)))#
}#
#
ggplot(phi_df, aes(phi, power, color=method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin=power-1.96*se, ymax=power+1.96*se), width=0.02)+#
  scale_x_continuous(breaks=phi_list)+#
  labs(x="phi", y="empirical power (n=250, α=0.05)")+#
  theme_minimal()
exception_df <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names = 1)#
alpha_vec <- c(0.05, 0.025, 0.01)#
colnames(exception_df) <- as.character(alpha_vec)#
#
n_win <- 250#
series_len <- nrow(exception_df)#
plot_df <- data.frame()#
#
for(a in alpha_vec){#
  X_full <- exception_df[[as.character(a)]]#
  dist   <- fb_lrcc(n_win, a)#
  LRv    <- dist$LR; Pv <- dist$prob#
  idx_max <- series_len - n_win + 1#
  for(idx in 1:idx_max){#
    seg  <- X_full[idx:(idx + n_win - 1)]#
    LR   <- my_compute_LRcc(seg, a)#
    p_e  <- get_pval_exact(LRv, Pv, LR)#
    p_c  <- 1 - pchisq(LR, 2)#
    plot_df <- rbind(plot_df,#
      data.frame(idx = idx, alpha = a, method = "exact",   p_value = p_e),#
      data.frame(idx = idx, alpha = a, method = "chi2(2)", p_value = p_c))#
  }#
}#
#
ggplot(plot_df, aes(idx, p_value, color = method)) +#
  geom_line() +#
  facet_wrap(~alpha, labeller = label_both, ncol = 1) +#
  geom_hline(yintercept = 0.05, linetype = "dashed", colour = "red") +#
  labs(x = "window start index", y = "p-value") +#
  theme_minimal()
################################################################
# Empirical comparison on simulated data — LRind version#
# 目标：替换 gen_markov，使   p = 1.4 * alpha,  phi = 0.6#
################################################################
#
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS      <- 1e-15#
SAFE_LOG <- function(x) log(pmax(x, EPS))#
#
## ----------  C++ forward algorithm for LRind  ----------------#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log(x>EPS?x:EPS); }#
#
struct State{ int la,T00,T10,T01,T11; double prob; };#
struct LLHash{ size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
#
static inline long long enc5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL, S2=M, S3=S2*M, S4=S3*M, S5=S4*M;#
  return la + S2*T00 + S3*T10 + S4*T01 + S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n, double alpha=0.05, double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0), Named("prob")=NumericVector(0));#
  int NMAX = n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[enc5(0,0,0,0,0,NMAX)] = {0,0,0,0,0,1.0-alpha};#
  cur[enc5(1,0,0,0,0,NMAX)] = {1,0,0,0,0,alpha};#
#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la, T00=kv.second.T00, T10=kv.second.T10,#
          T01=kv.second.T01, T11=kv.second.T11;#
#
      State ns=kv.second; (la==0?ns.T00:ns.T10)++; ns.la=0; ns.prob=p*(1.0-alpha);#
      nx[enc5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob += ns.prob;#
#
      ns=kv.second; (la==0?ns.T01:ns.T11)++; ns.la=1; ns.prob=p*alpha;#
      nx[enc5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob += ns.prob;#
    }#
    cur.swap(nx);#
  }#
#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat=(double)T1/(n-1);#
      double num=T0*s_log(1.0-pHat)+T1*s_log(pHat);#
      double pi01=(T00+T01)>0? (double)T01/(T00+T01):1.0;#
      double pi11=(T10+T11)>0? (double)T11/(T10+T11):1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+#
                 T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      LR=-2.0*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> v(dist.begin(),dist.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,pr=0; while(i<v.size()&&fabs(v[i].first-cur)<1e-15){pr+=v[i].second;++i;}#
    LR.push_back(cur); Pr.push_back(pr);#
  }#
  return List::create(Named("LR")=LR, Named("prob")=Pr);#
}#
')#
#
fb_lrind <- function(n, alpha) fb_lrind_fastcpp(n, alpha, 1e-15)#
#
## -------------  Log-likelihood ratio for a path  -------------#
my_compute_LRind <- function(X, alpha){#
  n <- length(X); if(n<2) return(0)#
  tab <- matrix(0,2,2)#
  for(i in 2:n) tab[X[i-1]+1, X[i]+1] <- tab[X[i-1]+1, X[i]+1] + 1#
  T00<-tab[1,1]; T01<-tab[1,2]; T10<-tab[2,1]; T11<-tab[2,2]#
  T0 <- T00+T10; T1 <- T01+T11#
  pHat <- if(n>1) T1/(n-1) else 0#
  num  <- T0*SAFE_LOG(1-pHat) + T1*SAFE_LOG(pHat)#
  pi01 <- if((T00+T01)>0) T01/(T00+T01) else 1#
  pi11 <- if((T10+T11)>0) T11/(T10+T11) else 1#
  den  <- T00*SAFE_LOG(1-pi01)+T01*SAFE_LOG(pi01)+#
          T10*SAFE_LOG(1-pi11)+T11*SAFE_LOG(pi11)#
  -2*(num-den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals < LRobs])#
#
## -------------  Markov generator with p = 1.4*alpha ----------#
gen_markov <- function(n, alpha, phi = 0.6, bias = 1.4){#
  p    <- min(bias*alpha, 0.999)            # 目标无条件命中率#
  p11  <- phi#
  p01  <- p*(1-phi)/(1-p)                   # 保证稳态 = p#
  X <- numeric(n)#
  X[1] <- rbinom(1,1,p)                     # 初始化用 p#
  for(i in 2:n){#
    pnext <- if(X[i-1]==1) p11 else p01#
    X[i]  <- rbinom(1,1,pnext)#
  }#
  X#
}#
#
## -------------  Simulation settings & loops  -----------------#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep       <- 2000#
results_size <- data.frame()#
results_power<- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist   <- fb_lrind(n_, alpha_)#
    LRgrid <- dist$LR; Pgrid <- dist$prob#
#
    ## --- size (H0 true: iid Bernoulli(alpha)) ---#
    rej_exact <- rej_chi <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X  <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRind(X, alpha_)#
      rej_exact[i] <- get_pval_exact(LRgrid,Pgrid,LR) < 0.05#
      rej_chi[i]   <- (1-pchisq(LR,1))               < 0.05#
    }#
    size_exact <- mean(rej_exact); se_exact <- sqrt(size_exact*(1-size_exact)/Nrep)#
    size_chi   <- mean(rej_chi);   se_chi   <- sqrt(size_chi*(1-size_chi)/Nrep)#
    results_size <- rbind(results_size,#
      data.frame(n=n_, alpha=alpha_,#
                 size_exact=size_exact, se_size_exact=se_exact,#
                 size_chi2_1=size_chi, se_size_chi2_1=se_chi))#
#
    ## --- power (alt: p = 1.4*alpha, φ = 0.6) ---#
    rej_exact <- rej_chi <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X  <- gen_markov(n_, alpha_, 0.6, 1.4)#
      LR <- my_compute_LRind(X, alpha_)#
      rej_exact[i] <- get_pval_exact(LRgrid,Pgrid,LR) < 0.05#
      rej_chi[i]   <- (1-pchisq(LR,1))               < 0.05#
    }#
    power_exact <- mean(rej_exact); se_pe <- sqrt(power_exact*(1-power_exact)/Nrep)#
    power_chi   <- mean(rej_chi);   se_pc <- sqrt(power_chi*(1-power_chi)/Nrep)#
    results_power <- rbind(results_power,#
      data.frame(n=n_, alpha=alpha_,#
                 power_exact=power_exact, se_power_exact=se_pe,#
                 power_chi2_1=power_chi, se_power_chi2_1=se_pc))#
  }#
}#
#
## -------------  Plotting  ------------------------------------#
size_df <- pivot_longer(results_size, cols=c(size_exact,size_chi2_1),#
                        names_to="method", values_to="value")#
size_df$method[size_df$method=="size_chi2_1"] <- "size_chi2(1)"#
#
power_df <- pivot_longer(results_power, cols=c(power_exact,power_chi2_1),#
                         names_to="method", values_to="value")#
power_df$method[power_df$method=="power_chi2_1"] <- "power_chi2(1)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill=method))+#
  geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1),#
                    ymax=value+1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+#
  geom_hline(yintercept=0.05, colour="red", linetype="dashed")+#
  labs(x="n", y="empirical size (significance level = 5%)")+#
  theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill=method))+#
  geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1),#
                    ymax=value+1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+#
  labs(x="n", y="empirical power (φ = 0.6, p = 1.4·α)")+#
  theme_minimal()#
#
print(p_power / p_size)
# 只跑 size，复现均值#
set.seed(123)#
sim_size <- replicate(2000, {#
  x <- rbinom(250, 1, 0.05)          # 例：n=250, α=5%#
  LR <- my_compute_LRind(x, 0.05)#
  get_pval_exact(LRgrid, Pgrid, LR) < 0.05#
})#
mean(sim_size)      # 正常应在 0.05 ± 0.015 内
## 重新生成精确分布，再自检#
n_test  <- 250#
alpha_t <- 0.05#
dist    <- fb_lrind(n_test, alpha_t)   # ★ 刷新#
LRgrid  <- dist$LR;  Pgrid <- dist$prob#
sum(Pgrid)            # 应 ≈ 1#
#
set.seed(123)#
sim_size <- replicate(2000, {#
  x  <- rbinom(n_test, 1, alpha_t)#
  LR <- my_compute_LRind(x, alpha_t)#
  get_pval_exact(LRgrid, Pgrid, LR) < 0.05#
})#
mean(sim_size)        # 应落在 0.05 ± ~0.015
#############################################################
##  Power study: LRcc — UC violation only (i.i.d. Bernoulli)#
#############################################################
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(tidyr)#
#
## ---------- helpers -------------------------------------------------#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <cmath>#
using namespace Rcpp;#
const double EPS = 1e-15;#
inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M,S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
// --------------------------------------------------------------------#
//  Exact distribution of LRcc (LR_uc + LR_ind), Bernoulli(alpha) null#
// --------------------------------------------------------------------#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[enc6(0,0,0,0,0,0,NMAX)] = {0,0,0,0,0,0,1.0-alpha};#
  cur[enc6(1,1,0,0,0,0,NMAX)] = {1,1,0,0,0,0,     alpha};#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      // next value = 0#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob += ns.prob;#
      }#
      // next value = 1#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la=1; ns.c1++; ns.prob=p*alpha;#
        nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob += ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int n=kv.second.c1 + kv.second.T00 + kv.second.T10 + kv.second.T01 + kv.second.T11 + 1;#
    int c1 = kv.second.c1;#
    // LR_uc#
    double p_ = std::min(std::max(alpha,EPS),1.0-EPS);#
    double phat = (c1==0)?0.0:(c1==n?1.0:(double)c1/n);#
    double ph_  = std::min(std::max(phat,EPS),1.0-EPS);#
    double lruc = -2.0*( c1*std::log(p_) + (n-c1)*std::log(1.0-p_)#
                       - c1*std::log(ph_) - (n-c1)*std::log(1.0-ph_) );#
    // LR_ind#
    double lrind = 0.0;#
    if(n>1){#
      int T00=kv.second.T00, T10=kv.second.T10, T01=kv.second.T01, T11=kv.second.T11;#
      int T0 = T00+T10, T1 = T01+T11;#
      double pHat = (double)T1/(n-1);#
      double num = T0*s_log(1.0-pHat)+T1*s_log(pHat);#
      int s01 = T00+T01, s11 = T10+T11;#
      double pi01 = s01? (double)T01/s01 : 1.0;#
      double pi11 = s11? (double)T11/s11 : 1.0;#
      double den = T00*s_log(1.0-pi01)+T01*s_log(pi01)#
                 + T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind = -2.0*(num-den);#
    }#
    dist[lruc+lrind] += p;#
  }#
  NumericVector LRout, Pout;#
  std::vector<std::pair<double,double>> v(dist.begin(),dist.end());#
  std::sort(v.begin(),v.end(),[](auto &a,auto &b){return a.first<b.first;});#
  for(size_t i=0;i<v.size();){#
    double LR=v[i].first, pp=0.0;#
    while(i<v.size() && fabs(v[i].first-LR)<1e-15){pp+=v[i].second; ++i;}#
    LRout.push_back(LR); Pout.push_back(pp);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
# --- R-side utility --------------------------------------------------#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals < LRobs])          # 右闭 P(LR ≥ LRobs)#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X)#
  x <- sum(X)#
  # LR_uc#
  p_   <- pmax(pmin(alpha,1-EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat,1-EPS), EPS)#
  lruc <- -2*(x*safe_log(p_)+(n-x)*safe_log(1-p_) - x*safe_log(ph_) - (n-x)*safe_log(1-ph_))#
  # LR_ind#
  if(n<=1) return(lruc)#
  counts <- matrix(0,2,2)#
  for(t in 2:n) counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1] + 1#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  T0 <- T00+T10; T1<-T01+T11#
  pHat <- T1/(n-1); num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  s01<-T00+T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11 <- if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+#
         T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  lrind <- -2*(num-den)#
  lruc + lrind#
}#
#
## ---------- simulation design --------------------------------------#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
k_list     <- c(5,7,10)           # extra exceptions#
Nrep       <- 2000#
#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)          # exact null distribution once per (n, α)#
    LRvals <- dist$LR; Pvals <- dist$prob#
    for(k in k_list){#
      alpha_star <- alpha_ + k / n_      # UC violation only#
      alpha_star <- max(min(alpha_star, 1-1e-6), 1e-6)   # safety#
      rej_ex <- rej_ch <- numeric(Nrep)#
      for(i in 1:Nrep){#
        X  <- rbinom(n_, 1, alpha_star)  # i.i.d. Bernoulli(α*)#
        LR <- my_compute_LRcc(X, alpha_)#
        rej_ex[i] <- get_pval_exact(LRvals, Pvals, LR) < 0.05#
        rej_ch[i] <- (1 - pchisq(LR, 2)) < 0.05#
      }#
      p_ex  <- mean(rej_ex);  se_ex <- sqrt(p_ex*(1-p_ex)/Nrep)#
      p_ch  <- mean(rej_ch);  se_ch <- sqrt(p_ch*(1-p_ch)/Nrep)#
      results_power <- rbind(results_power,#
        data.frame(n = n_, alpha = alpha_, k_extra = k,#
                   alpha_star = alpha_star,#
                   power_exact = p_ex,  se_exact = se_ex,#
                   power_chi2  = p_ch, se_chi2 = se_ch))#
    }#
  }#
}#
#
## ---------- 可视化（可选） ----------------------------------------#
long_pow <- pivot_longer(results_power,#
            cols = c(power_exact, power_chi2),#
            names_to = "method", values_to = "power")#
long_pow$method[long_pow$method=="power_chi2"] <- "chi2(2)"#
long_pow$method[long_pow$method=="power_exact"] <- "exact"#
#
ggplot(long_pow,#
       aes(factor(n), power, fill = method))+#
  geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin = power - 1.96*ifelse(method=="exact", se_exact, se_chi2),#
                    ymax = power + 1.96*ifelse(method=="exact", se_exact, se_chi2)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_grid(alpha ~ k_extra,#
             labeller = labeller(#
               alpha = label_both,#
               k_extra = function(x) paste0("k = ", x," extra"))) +#
  labs(x = "n", y = "empirical power (UC-violation only)",#
       title = "LRcc: exact vs χ²(2) — Bernoulli(α*)")+#
  theme_minimal()
#############################################################
##  LRcc  power study  ——  UC violation only (i.i.d. Bernoulli)#
#############################################################
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(tidyr)#
#
## ---------- 1.  C++ exact distribution -------------------#
EPS <- 1e-15#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <algorithm>#
#include <cmath>#
#
using namespace Rcpp;#
const double EPS = 1e-15;#
inline double s_log(double x){ return std::log(x>EPS?x:EPS); }#
#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{ size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL;#
  long long S2=M, S3=S2*M, S4=S3*M, S5=S4*M, S6=S5*M;#
  return la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune=1e-15){#
  if(n < 1)#
    return List::create(Named("LR")   = NumericVector(0),#
                        Named("prob") = NumericVector(0));#
#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[ enc6(0,0,0,0,0,0,NMAX) ] = {0,0,0,0,0,0, 1.0-alpha};#
  cur[ enc6(1,1,0,0,0,0,NMAX) ] = {1,1,0,0,0,0,      alpha};#
#
  for(int k=1; k<n; ++k){#
    std::unordered_map<long long,State,LLHash> nxt;  nxt.reserve(cur.size()*2);#
#
    for(auto &kv : cur){#
      double p = kv.second.prob;#
      if(p < prune) continue;#
      int la = kv.second.la;#
#
      /* next value = 0 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T00 : ns.T10)++;#
        ns.la  = 0;#
        ns.prob = p * (1.0 - alpha);#
        nxt[ enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX) ].prob += ns.prob;#
      }#
      /* next value = 1 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T01 : ns.T11)++;#
        ns.la  = 1;#
        ns.c1++;#
        ns.prob = p * alpha;#
        nxt[ enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX) ].prob += ns.prob;#
      }#
    }#
    cur.swap(nxt);#
  }#
#
  std::unordered_map<double,double> dist;#
  for(auto &kv : cur){#
    double p  = kv.second.prob;#
    if(p <= 0) continue;#
#
    /* length & ones */#
    int len = kv.second.c1 + kv.second.T00 + kv.second.T10 +#
              kv.second.T01 + kv.second.T11 + 1;#
    int c1  = kv.second.c1;#
#
    /* LR_uc */#
    double p_   = std::min(std::max(alpha,EPS), 1.0-EPS);#
    double phat = (c1==0)?0.0 : (c1==len?1.0 : double(c1)/len);#
    double ph_  = std::min(std::max(phat,EPS), 1.0-EPS);#
    double lruc = -2.0*(  c1 * std::log(p_)         + (len-c1)*std::log(1.0-p_)#
                        - c1 * std::log(ph_)        - (len-c1)*std::log(1.0-ph_) );#
#
    /* LR_ind */#
    double lrind = 0.0;#
    if(len > 1){#
      int T00 = kv.second.T00, T10 = kv.second.T10,#
          T01 = kv.second.T01, T11 = kv.second.T11;#
      int T0 = T00 + T10,  T1 = T01 + T11;#
#
      double pHat = double(T1) / (len-1);#
      double num  = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01? double(T01)/s01 : 1.0;#
      double pi11 = s11? double(T11)/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01) +#
                    T10*s_log(1.0-pi11) + T11*s_log(pi11);#
#
      lrind = -2.0*(num - den);#
    }#
    dist[ lruc + lrind ] += p;#
  }#
#
  std::vector<std::pair<double,double>> vec(dist.begin(), dist.end());#
  std::sort(vec.begin(), vec.end(),#
            [](const auto &a, const auto &b){ return a.first < b.first; });#
#
  NumericVector LR, Prob;#
  for(size_t i=0; i<vec.size(); ){#
    double curLR = vec[i].first, pp = 0.0;#
    while(i<vec.size() && fabs(vec[i].first-curLR) < 1e-15){#
      pp += vec[i].second; ++i;#
    }#
    LR.push_back(curLR); Prob.push_back(pp);#
  }#
  return List::create(_["LR"]=LR, _["prob"]=Prob);#
}#
')#
#
## ---------- 2.  R-side helpers --------------------------------------#
safe_log <- function(x) log(pmax(x, EPS))#
fb_lrcc <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals < LRobs])        # P(LR ≥ LRobs)#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); x <- sum(X)#
  ## LR_uc#
  p_   <- pmax(pmin(alpha, 1-EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat, 1-EPS), EPS)#
  lruc <- -2*( x*safe_log(p_) + (n-x)*safe_log(1-p_) -#
               x*safe_log(ph_) - (n-x)*safe_log(1-ph_) )#
#
  if(n <= 1) return(lruc)#
#
  ## LR_ind#
  counts <- matrix(0, 2, 2)#
  for(t in 2:n) counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1] + 1#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  T0 <- T00+T10; T1 <- T01+T11#
  pHat <- T1/(n-1)#
  num  <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
  s01 <- T00+T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10+T11; pi11 <- if(s11>0) T11/s11 else 1#
  den  <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
          T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  lrind <- -2*(num - den)#
  lruc + lrind#
}#
#
## ---------- 3.  simulation design ----------------------------------#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
k_list     <- c(5,7,10)          # Basel-style extra exceptions#
Nrep       <- 2000#
#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)    # exact null once per grid-point#
    LRv  <- dist$LR; Pv <- dist$prob#
#
    for(k in k_list){#
      alpha_star <- alpha_ + k / n_       # UC-violation only#
      alpha_star <- max(min(alpha_star, 1-1e-6), 1e-6)#
#
      rej_ex <- rej_ch <- numeric(Nrep)#
      for(i in seq_len(Nrep)){#
        X  <- rbinom(n_, 1, alpha_star)   # i.i.d. Bernoulli(α*)#
        LR <- my_compute_LRcc(X, alpha_)#
#
        rej_ex[i] <- get_pval_exact(LRv, Pv, LR) < 0.05#
        rej_ch[i] <- (1 - pchisq(LR, 2)) < 0.05#
      }#
      p_ex <- mean(rej_ex); se_ex <- sqrt(p_ex*(1-p_ex)/Nrep)#
      p_ch <- mean(rej_ch); se_ch <- sqrt(p_ch*(1-p_ch)/Nrep)#
#
      results_power <- rbind(results_power,#
        data.frame(n = n_, alpha = alpha_, k_extra = k,#
                   alpha_star = alpha_star,#
                   power_exact = p_ex,  se_exact = se_ex,#
                   power_chi2  = p_ch,  se_chi2  = se_ch))#
    }#
  }#
}#
#
## ---------- 4.  (optional) plot ------------------------------------#
long_pow <- pivot_longer(results_power,#
                         cols = c(power_exact, power_chi2),#
                         names_to = "method", values_to = "power")#
long_pow$method[long_pow$method=="power_exact"] <- "exact"#
long_pow$method[long_pow$method=="power_chi2"]  <- "chi2(2)"#
#
ggplot(long_pow,#
       aes(factor(n), power, fill = method)) +#
  geom_bar(stat = "identity", position = "dodge") +#
  geom_errorbar(aes(#
        ymin = power - 1.96*ifelse(method=="exact", se_exact, se_chi2),#
        ymax = power + 1.96*ifelse(method=="exact", se_exact, se_chi2)),#
        position = position_dodge(0.9), width = 0.25) +#
  facet_grid(alpha ~ k_extra,#
             labeller = labeller(#
               alpha   = label_both,#
               k_extra = function(x) paste0("k = ", x, " extra"))) +#
  labs(x = "n", y = "empirical power (UC-violation only)",#
       title = "LRcc  —  exact vs. χ²(2)") +#
  theme_minimal()#
#
## 结果数据框在  results_power
#############################################################
##  LRcc  power study  ——  UC-violation only (i.i.d. Bernoulli)#
##  修正版：精确分布长度计算已更正#
#############################################################
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(tidyr)#
#
## ---------- 1.  C++ exact distribution -------------------#
EPS <- 1e-15#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <algorithm>#
#include <cmath>#
#
using namespace Rcpp;#
const double EPS = 1e-15;#
inline double s_log(double x){ return std::log(x>EPS?x:EPS); }#
#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{ size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL;#
  long long S2=M, S3=S2*M, S4=S3*M, S5=S4*M, S6=S5*M;#
  return la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune=1e-15){#
  if(n < 1)#
    return List::create(Named("LR")   = NumericVector(0),#
                        Named("prob") = NumericVector(0));#
#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[ enc6(0,0,0,0,0,0,NMAX) ] = {0,0,0,0,0,0, 1.0-alpha};#
  cur[ enc6(1,1,0,0,0,0,NMAX) ] = {1,1,0,0,0,0,      alpha};#
#
  for(int k=1; k<n; ++k){#
    std::unordered_map<long long,State,LLHash> nxt;  nxt.reserve(cur.size()*2);#
#
    for(auto &kv : cur){#
      double p = kv.second.prob;#
      if(p < prune) continue;#
      int la = kv.second.la;#
#
      /* next value = 0 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T00 : ns.T10)++;#
        ns.la  = 0;#
        ns.prob = p * (1.0 - alpha);#
        nxt[ enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX) ].prob += ns.prob;#
      }#
      /* next value = 1 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T01 : ns.T11)++;#
        ns.la  = 1;#
        ns.c1++;#
        ns.prob = p * alpha;#
        nxt[ enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX) ].prob += ns.prob;#
      }#
    }#
    cur.swap(nxt);#
  }#
#
  std::unordered_map<double,double> dist;#
  for(auto &kv : cur){#
    double p  = kv.second.prob;#
    if(p <= 0) continue;#
#
    /* 正确的样本长度 n */#
    int T00 = kv.second.T00, T10 = kv.second.T10,#
        T01 = kv.second.T01, T11 = kv.second.T11;#
    int len = T00 + T10 + T01 + T11 + 1;#
    int c1  = kv.second.c1;#
#
    /* LR_uc */#
    double p_   = std::min(std::max(alpha,EPS), 1.0-EPS);#
    double phat = (c1==0)?0.0 : (c1==len?1.0 : double(c1)/len);#
    double ph_  = std::min(std::max(phat,EPS), 1.0-EPS);#
    double lruc = -2.0*(  c1 * std::log(p_)         + (len-c1)*std::log(1.0-p_)#
                        - c1 * std::log(ph_)        - (len-c1)*std::log(1.0-ph_) );#
#
    /* LR_ind */#
    double lrind = 0.0;#
    if(len > 1){#
      int T0 = T00 + T10,  T1 = T01 + T11;#
      double pHat = double(T1) / (len-1);#
      double num  = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01? double(T01)/s01 : 1.0;#
      double pi11 = s11? double(T11)/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01) +#
                    T10*s_log(1.0-pi11) + T11*s_log(pi11);#
#
      lrind = -2.0*(num - den);#
    }#
    dist[ lruc + lrind ] += p;#
  }#
#
  std::vector<std::pair<double,double>> vec(dist.begin(), dist.end());#
  std::sort(vec.begin(), vec.end(),#
            [](const auto &a, const auto &b){ return a.first < b.first; });#
#
  NumericVector LR, Prob;#
  for(size_t i=0; i<vec.size(); ){#
    double curLR = vec[i].first, pp = 0.0;#
    while(i<vec.size() && fabs(vec[i].first-curLR) < 1e-15){#
      pp += vec[i].second; ++i;#
    }#
    LR.push_back(curLR); Prob.push_back(pp);#
  }#
  return List::create(_["LR"]=LR, _["prob"]=Prob);#
}#
')#
#
## ---------- 2.  R helpers ------------------------------------------#
safe_log <- function(x) log(pmax(x, EPS))#
fb_lrcc  <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals < LRobs])        # P(LR ≥ LRobs)#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); x <- sum(X)#
  ## LR_uc#
  p_   <- pmax(pmin(alpha, 1-EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat, 1-EPS), EPS)#
  lruc <- -2*( x*safe_log(p_) + (n-x)*safe_log(1-p_) -#
               x*safe_log(ph_) - (n-x)*safe_log(1-ph_) )#
#
  if(n <= 1) return(lruc)#
#
  ## LR_ind#
  counts <- matrix(0, 2, 2)#
  for(t in 2:n) counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1] + 1#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  T0 <- T00+T10; T1 <- T01+T11#
  pHat <- T1/(n-1)#
  num  <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
  s01 <- T00+T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10+T11; pi11 <- if(s11>0) T11/s11 else 1#
  den  <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
          T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  lrind <- -2*(num - den)#
  lruc + lrind#
}#
#
## ---------- 3.  simulation -----------------------------------------#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
k_list     <- c(5,7,10)          # Basel-style extra exceptions#
Nrep       <- 2000#
#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)              # exact null once per (n, α)#
    LRv  <- dist$LR; Pv <- dist$prob#
#
    for(k in k_list){#
      alpha_star <- alpha_ + k / n_          # UC-violation only#
      alpha_star <- max(min(alpha_star, 1-1e-6), 1e-6)#
#
      rej_ex <- rej_ch <- numeric(Nrep)#
      for(i in seq_len(Nrep)){#
        X  <- rbinom(n_, 1, alpha_star)#
        LR <- my_compute_LRcc(X, alpha_)#
        rej_ex[i] <- get_pval_exact(LRv, Pv, LR) < 0.05#
        rej_ch[i] <- (1 - pchisq(LR, 2))    < 0.05#
      }#
      p_ex <- mean(rej_ex); se_ex <- sqrt(p_ex*(1-p_ex)/Nrep)#
      p_ch <- mean(rej_ch); se_ch <- sqrt(p_ch*(1-p_ch)/Nrep)#
#
      results_power <- rbind(results_power,#
        data.frame(n = n_, alpha = alpha_, k_extra = k,#
                   alpha_star = alpha_star,#
                   power_exact = p_ex,  se_exact = se_ex,#
                   power_chi2  = p_ch,  se_chi2  = se_ch))#
    }#
  }#
}#
#
## ---------- 4.  可视化（如需） -------------------------------------#
long_pow <- pivot_longer(results_power,#
                         cols = c(power_exact, power_chi2),#
                         names_to = "method", values_to = "power")#
long_pow$method[long_pow$method=="power_exact"] <- "exact"#
long_pow$method[long_pow$method=="power_chi2"]  <- "chi2(2)"#
#
ggplot(long_pow,#
       aes(factor(n), power, fill = method)) +#
  geom_bar(stat = "identity", position = "dodge") +#
  geom_errorbar(aes(#
        ymin = power - 1.96*ifelse(method=="exact", se_exact, se_chi2),#
        ymax = power + 1.96*ifelse(method=="exact", se_exact, se_chi2)),#
        position = position_dodge(0.9), width = 0.25) +#
  facet_grid(alpha ~ k_extra,#
             labeller = labeller(#
               alpha   = label_both,#
               k_extra = function(x) paste0("k = ", x, " extra"))) +#
  labs(x = "n", y = "empirical power (UC-violation only)",#
       title = "LRcc — exact vs χ²(2)") +#
  theme_minimal()#
#
## 结果数据框存于  results_power
#############################################################
##  LRcc  power study  ——  UC-violation only (i.i.d. Bernoulli)#
##  修正版：精确分布长度计算已更正#
#############################################################
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(tidyr)#
#
## ---------- 1.  C++ exact distribution -------------------#
EPS <- 1e-15#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <algorithm>#
#include <cmath>#
#
using namespace Rcpp;#
const double EPS = 1e-15;#
inline double s_log(double x){ return std::log(x>EPS?x:EPS); }#
#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{ size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL;#
  long long S2=M, S3=S2*M, S4=S3*M, S5=S4*M, S6=S5*M;#
  return la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune=1e-15){#
  if(n < 1)#
    return List::create(Named("LR")   = NumericVector(0),#
                        Named("prob") = NumericVector(0));#
#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[ enc6(0,0,0,0,0,0,NMAX) ] = {0,0,0,0,0,0, 1.0-alpha};#
  cur[ enc6(1,1,0,0,0,0,NMAX) ] = {1,1,0,0,0,0,      alpha};#
#
  for(int k=1; k<n; ++k){#
    std::unordered_map<long long,State,LLHash> nxt;  nxt.reserve(cur.size()*2);#
#
    for(auto &kv : cur){#
      double p = kv.second.prob;#
      if(p < prune) continue;#
      int la = kv.second.la;#
#
      /* next value = 0 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T00 : ns.T10)++;#
        ns.la  = 0;#
        ns.prob = p * (1.0 - alpha);#
        nxt[ enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX) ].prob += ns.prob;#
      }#
      /* next value = 1 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T01 : ns.T11)++;#
        ns.la  = 1;#
        ns.c1++;#
        ns.prob = p * alpha;#
        nxt[ enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX) ].prob += ns.prob;#
      }#
    }#
    cur.swap(nxt);#
  }#
#
  std::unordered_map<double,double> dist;#
  for(auto &kv : cur){#
    double p  = kv.second.prob;#
    if(p <= 0) continue;#
#
    /* 正确的样本长度 n */#
    int T00 = kv.second.T00, T10 = kv.second.T10,#
        T01 = kv.second.T01, T11 = kv.second.T11;#
    int len = T00 + T10 + T01 + T11 + 1;#
    int c1  = kv.second.c1;#
#
    /* LR_uc */#
    double p_   = std::min(std::max(alpha,EPS), 1.0-EPS);#
    double phat = (c1==0)?0.0 : (c1==len?1.0 : double(c1)/len);#
    double ph_  = std::min(std::max(phat,EPS), 1.0-EPS);#
    double lruc = -2.0*(  c1 * std::log(p_)         + (len-c1)*std::log(1.0-p_)#
                        - c1 * std::log(ph_)        - (len-c1)*std::log(1.0-ph_) );#
#
    /* LR_ind */#
    double lrind = 0.0;#
    if(len > 1){#
      int T0 = T00 + T10,  T1 = T01 + T11;#
      double pHat = double(T1) / (len-1);#
      double num  = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01? double(T01)/s01 : 1.0;#
      double pi11 = s11? double(T11)/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01) +#
                    T10*s_log(1.0-pi11) + T11*s_log(pi11);#
#
      lrind = -2.0*(num - den);#
    }#
    dist[ lruc + lrind ] += p;#
  }#
#
  std::vector<std::pair<double,double>> vec(dist.begin(), dist.end());#
  std::sort(vec.begin(), vec.end(),#
            [](const auto &a, const auto &b){ return a.first < b.first; });#
#
  NumericVector LR, Prob;#
  for(size_t i=0; i<vec.size(); ){#
    double curLR = vec[i].first, pp = 0.0;#
    while(i<vec.size() && fabs(vec[i].first-curLR) < 1e-15){#
      pp += vec[i].second; ++i;#
    }#
    LR.push_back(curLR); Prob.push_back(pp);#
  }#
  return List::create(_["LR"]=LR, _["prob"]=Prob);#
}#
')#
#
## ---------- 2.  R helpers ------------------------------------------#
safe_log <- function(x) log(pmax(x, EPS))#
fb_lrcc  <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals < LRobs])        # P(LR ≥ LRobs)#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); x <- sum(X)#
  ## LR_uc#
  p_   <- pmax(pmin(alpha, 1-EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat, 1-EPS), EPS)#
  lruc <- -2*( x*safe_log(p_) + (n-x)*safe_log(1-p_) -#
               x*safe_log(ph_) - (n-x)*safe_log(1-ph_) )#
#
  if(n <= 1) return(lruc)#
#
  ## LR_ind#
  counts <- matrix(0, 2, 2)#
  for(t in 2:n) counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1] + 1#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  T0 <- T00+T10; T1 <- T01+T11#
  pHat <- T1/(n-1)#
  num  <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
  s01 <- T00+T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10+T11; pi11 <- if(s11>0) T11/s11 else 1#
  den  <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
          T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  lrind <- -2*(num - den)#
  lruc + lrind#
}#
#
## ---------- 3.  simulation -----------------------------------------#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
k_list     <- c(5,7,10)          # Basel-style extra exceptions#
Nrep       <- 2000#
#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)              # exact null once per (n, α)#
    LRv  <- dist$LR; Pv <- dist$prob#
#
    for(k in k_list){#
      alpha_star <- alpha_ + k / n_          # UC-violation only#
      alpha_star <- max(min(alpha_star, 1-1e-6), 1e-6)#
#
      rej_ex <- rej_ch <- numeric(Nrep)#
      for(i in seq_len(Nrep)){#
        X  <- rbinom(n_, 1, alpha_star)#
        LR <- my_compute_LRcc(X, alpha_)#
        rej_ex[i] <- get_pval_exact(LRv, Pv, LR) < 0.05#
        rej_ch[i] <- (1 - pchisq(LR, 2))    < 0.05#
      }#
      p_ex <- mean(rej_ex); se_ex <- sqrt(p_ex*(1-p_ex)/Nrep)#
      p_ch <- mean(rej_ch); se_ch <- sqrt(p_ch*(1-p_ch)/Nrep)#
#
      results_power <- rbind(results_power,#
        data.frame(n = n_, alpha = alpha_, k_extra = k,#
                   alpha_star = alpha_star,#
                   power_exact = p_ex,  se_exact = se_ex,#
                   power_chi2  = p_ch,  se_chi2  = se_ch))#
    }#
  }#
}#
#
## ---------- 4.  可视化（如需） -------------------------------------#
long_pow <- pivot_longer(results_power,#
                         cols = c(power_exact, power_chi2),#
                         names_to = "method", values_to = "power")#
long_pow$method[long_pow$method=="power_exact"] <- "exact"#
long_pow$method[long_pow$method=="power_chi2"]  <- "chi2(2)"#
#
ggplot(long_pow,#
       aes(factor(n), power, fill = method)) +#
  geom_bar(stat = "identity", position = "dodge") +#
  geom_errorbar(aes(#
        ymin = power - 1.96*ifelse(method=="exact", se_exact, se_chi2),#
        ymax = power + 1.96*ifelse(method=="exact", se_exact, se_chi2)),#
        position = position_dodge(0.9), width = 0.25) +#
  facet_grid(alpha ~ k_extra,#
             labeller = labeller(#
               alpha   = label_both,#
               k_extra = function(x) paste0("k = ", x, " extra"))) +#
  labs(x = "n", y = "empirical power (UC-violation only)",#
       title = "LRcc — exact vs χ²(2)") +#
  theme_minimal()#
#
## 结果数据框存于  results_power#
#############################################################
##  LRcc  power study  ——  UC-violation only (i.i.d. Bernoulli)#
##  修正版：精确分布长度计算已更正#
#############################################################
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(tidyr)#
#
## ---------- 1.  C++ exact distribution -------------------#
EPS <- 1e-15#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <algorithm>#
#include <cmath>#
#
using namespace Rcpp;#
const double EPS = 1e-15;#
inline double s_log(double x){ return std::log(x>EPS?x:EPS); }#
#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{ size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL;#
  long long S2=M, S3=S2*M, S4=S3*M, S5=S4*M, S6=S5*M;#
  return la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune=1e-15){#
  if(n < 1)#
    return List::create(Named("LR")   = NumericVector(0),#
                        Named("prob") = NumericVector(0));#
#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[ enc6(0,0,0,0,0,0,NMAX) ] = {0,0,0,0,0,0, 1.0-alpha};#
  cur[ enc6(1,1,0,0,0,0,NMAX) ] = {1,1,0,0,0,0,      alpha};#
#
  for(int k=1; k<n; ++k){#
    std::unordered_map<long long,State,LLHash> nxt;  nxt.reserve(cur.size()*2);#
#
    for(auto &kv : cur){#
      double p = kv.second.prob;#
      if(p < prune) continue;#
      int la = kv.second.la;#
#
      /* next value = 0 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T00 : ns.T10)++;#
        ns.la  = 0;#
        ns.prob = p * (1.0 - alpha);#
        nxt[ enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX) ].prob += ns.prob;#
      }#
      /* next value = 1 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T01 : ns.T11)++;#
        ns.la  = 1;#
        ns.c1++;#
        ns.prob = p * alpha;#
        nxt[ enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX) ].prob += ns.prob;#
      }#
    }#
    cur.swap(nxt);#
  }#
#
  std::unordered_map<double,double> dist;#
  for(auto &kv : cur){#
    double p  = kv.second.prob;#
    if(p <= 0) continue;#
#
    /* 正确的样本长度 n */#
    int T00 = kv.second.T00, T10 = kv.second.T10,#
        T01 = kv.second.T01, T11 = kv.second.T11;#
    int len = T00 + T10 + T01 + T11 + 1;#
    int c1  = kv.second.c1;#
#
    /* LR_uc */#
    double p_   = std::min(std::max(alpha,EPS), 1.0-EPS);#
    double phat = (c1==0)?0.0 : (c1==len?1.0 : double(c1)/len);#
    double ph_  = std::min(std::max(phat,EPS), 1.0-EPS);#
    double lruc = -2.0*(  c1 * std::log(p_)         + (len-c1)*std::log(1.0-p_)#
                        - c1 * std::log(ph_)        - (len-c1)*std::log(1.0-ph_) );#
#
    /* LR_ind */#
    double lrind = 0.0;#
    if(len > 1){#
      int T0 = T00 + T10,  T1 = T01 + T11;#
      double pHat = double(T1) / (len-1);#
      double num  = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01? double(T01)/s01 : 1.0;#
      double pi11 = s11? double(T11)/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01) +#
                    T10*s_log(1.0-pi11) + T11*s_log(pi11);#
#
      lrind = -2.0*(num - den);#
    }#
    dist[ lruc + lrind ] += p;#
  }#
#
  std::vector<std::pair<double,double>> vec(dist.begin(), dist.end());#
  std::sort(vec.begin(), vec.end(),#
            [](const auto &a, const auto &b){ return a.first < b.first; });#
#
  NumericVector LR, Prob;#
  for(size_t i=0; i<vec.size(); ){#
    double curLR = vec[i].first, pp = 0.0;#
    while(i<vec.size() && fabs(vec[i].first-curLR) < 1e-15){#
      pp += vec[i].second; ++i;#
    }#
    LR.push_back(curLR); Prob.push_back(pp);#
  }#
  return List::create(_["LR"]=LR, _["prob"]=Prob);#
}#
')#
#
## ---------- 2.  R helpers ------------------------------------------#
safe_log <- function(x) log(pmax(x, EPS))#
fb_lrcc  <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals < LRobs])        # P(LR ≥ LRobs)#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); x <- sum(X)#
  ## LR_uc#
  p_   <- pmax(pmin(alpha, 1-EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat, 1-EPS), EPS)#
  lruc <- -2*( x*safe_log(p_) + (n-x)*safe_log(1-p_) -#
               x*safe_log(ph_) - (n-x)*safe_log(1-ph_) )#
#
  if(n <= 1) return(lruc)#
#
  ## LR_ind#
  counts <- matrix(0, 2, 2)#
  for(t in 2:n) counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1] + 1#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  T0 <- T00+T10; T1 <- T01+T11#
  pHat <- T1/(n-1)#
  num  <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
  s01 <- T00+T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10+T11; pi11 <- if(s11>0) T11/s11 else 1#
  den  <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
          T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  lrind <- -2*(num - den)#
  lruc + lrind#
}#
#
## ---------- 3.  simulation -----------------------------------------#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
k_list     <- c(1,2,3)          # Basel-style extra exceptions#
Nrep       <- 2000#
#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)              # exact null once per (n, α)#
    LRv  <- dist$LR; Pv <- dist$prob#
#
    for(k in k_list){#
      alpha_star <- alpha_ + k / n_          # UC-violation only#
      alpha_star <- max(min(alpha_star, 1-1e-6), 1e-6)#
#
      rej_ex <- rej_ch <- numeric(Nrep)#
      for(i in seq_len(Nrep)){#
        X  <- rbinom(n_, 1, alpha_star)#
        LR <- my_compute_LRcc(X, alpha_)#
        rej_ex[i] <- get_pval_exact(LRv, Pv, LR) < 0.05#
        rej_ch[i] <- (1 - pchisq(LR, 2))    < 0.05#
      }#
      p_ex <- mean(rej_ex); se_ex <- sqrt(p_ex*(1-p_ex)/Nrep)#
      p_ch <- mean(rej_ch); se_ch <- sqrt(p_ch*(1-p_ch)/Nrep)#
#
      results_power <- rbind(results_power,#
        data.frame(n = n_, alpha = alpha_, k_extra = k,#
                   alpha_star = alpha_star,#
                   power_exact = p_ex,  se_exact = se_ex,#
                   power_chi2  = p_ch,  se_chi2  = se_ch))#
    }#
  }#
}#
#
## ---------- 4.  可视化（如需） -------------------------------------#
long_pow <- pivot_longer(results_power,#
                         cols = c(power_exact, power_chi2),#
                         names_to = "method", values_to = "power")#
long_pow$method[long_pow$method=="power_exact"] <- "exact"#
long_pow$method[long_pow$method=="power_chi2"]  <- "chi2(2)"#
#
ggplot(long_pow,#
       aes(factor(n), power, fill = method)) +#
  geom_bar(stat = "identity", position = "dodge") +#
  geom_errorbar(aes(#
        ymin = power - 1.96*ifelse(method=="exact", se_exact, se_chi2),#
        ymax = power + 1.96*ifelse(method=="exact", se_exact, se_chi2)),#
        position = position_dodge(0.9), width = 0.25) +#
  facet_grid(alpha ~ k_extra,#
             labeller = labeller(#
               alpha   = label_both,#
               k_extra = function(x) paste0("k = ", x, " extra"))) +#
  labs(x = "n", y = "empirical power (UC-violation only)",#
       title = "LRcc — exact vs χ²(2)") +#
  theme_minimal()#
#
## 结果数据框存于  results_power
#############################################################
##  LRcc  power study  ——  UC-violation only (i.i.d. Bernoulli)#
##  修正版：精确分布长度计算已更正#
#############################################################
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(tidyr)#
#
## ---------- 1.  C++ exact distribution -------------------#
EPS <- 1e-15#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <algorithm>#
#include <cmath>#
#
using namespace Rcpp;#
const double EPS = 1e-15;#
inline double s_log(double x){ return std::log(x>EPS?x:EPS); }#
#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{ size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL;#
  long long S2=M, S3=S2*M, S4=S3*M, S5=S4*M, S6=S5*M;#
  return la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune=1e-15){#
  if(n < 1)#
    return List::create(Named("LR")   = NumericVector(0),#
                        Named("prob") = NumericVector(0));#
#
  int NMAX = n + 5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[ enc6(0,0,0,0,0,0,NMAX) ] = {0,0,0,0,0,0, 1.0-alpha};#
  cur[ enc6(1,1,0,0,0,0,NMAX) ] = {1,1,0,0,0,0,      alpha};#
#
  for(int k=1; k<n; ++k){#
    std::unordered_map<long long,State,LLHash> nxt;  nxt.reserve(cur.size()*2);#
#
    for(auto &kv : cur){#
      double p = kv.second.prob;#
      if(p < prune) continue;#
      int la = kv.second.la;#
#
      /* next value = 0 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T00 : ns.T10)++;#
        ns.la  = 0;#
        ns.prob = p * (1.0 - alpha);#
        nxt[ enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX) ].prob += ns.prob;#
      }#
      /* next value = 1 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T01 : ns.T11)++;#
        ns.la  = 1;#
        ns.c1++;#
        ns.prob = p * alpha;#
        nxt[ enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX) ].prob += ns.prob;#
      }#
    }#
    cur.swap(nxt);#
  }#
#
  std::unordered_map<double,double> dist;#
  for(auto &kv : cur){#
    double p  = kv.second.prob;#
    if(p <= 0) continue;#
#
    /* 正确的样本长度 n */#
    int T00 = kv.second.T00, T10 = kv.second.T10,#
        T01 = kv.second.T01, T11 = kv.second.T11;#
    int len = T00 + T10 + T01 + T11 + 1;#
    int c1  = kv.second.c1;#
#
    /* LR_uc */#
    double p_   = std::min(std::max(alpha,EPS), 1.0-EPS);#
    double phat = (c1==0)?0.0 : (c1==len?1.0 : double(c1)/len);#
    double ph_  = std::min(std::max(phat,EPS), 1.0-EPS);#
    double lruc = -2.0*(  c1 * std::log(p_)         + (len-c1)*std::log(1.0-p_)#
                        - c1 * std::log(ph_)        - (len-c1)*std::log(1.0-ph_) );#
#
    /* LR_ind */#
    double lrind = 0.0;#
    if(len > 1){#
      int T0 = T00 + T10,  T1 = T01 + T11;#
      double pHat = double(T1) / (len-1);#
      double num  = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
#
      int s01 = T00 + T01, s11 = T10 + T11;#
      double pi01 = s01? double(T01)/s01 : 1.0;#
      double pi11 = s11? double(T11)/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01) + T01*s_log(pi01) +#
                    T10*s_log(1.0-pi11) + T11*s_log(pi11);#
#
      lrind = -2.0*(num - den);#
    }#
    dist[ lruc + lrind ] += p;#
  }#
#
  std::vector<std::pair<double,double>> vec(dist.begin(), dist.end());#
  std::sort(vec.begin(), vec.end(),#
            [](const auto &a, const auto &b){ return a.first < b.first; });#
#
  NumericVector LR, Prob;#
  for(size_t i=0; i<vec.size(); ){#
    double curLR = vec[i].first, pp = 0.0;#
    while(i<vec.size() && fabs(vec[i].first-curLR) < 1e-15){#
      pp += vec[i].second; ++i;#
    }#
    LR.push_back(curLR); Prob.push_back(pp);#
  }#
  return List::create(_["LR"]=LR, _["prob"]=Prob);#
}#
')#
#
## ---------- 2.  R helpers ------------------------------------------#
safe_log <- function(x) log(pmax(x, EPS))#
fb_lrcc  <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals < LRobs])        # P(LR ≥ LRobs)#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); x <- sum(X)#
  ## LR_uc#
  p_   <- pmax(pmin(alpha, 1-EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat, 1-EPS), EPS)#
  lruc <- -2*( x*safe_log(p_) + (n-x)*safe_log(1-p_) -#
               x*safe_log(ph_) - (n-x)*safe_log(1-ph_) )#
#
  if(n <= 1) return(lruc)#
#
  ## LR_ind#
  counts <- matrix(0, 2, 2)#
  for(t in 2:n) counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1] + 1#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  T0 <- T00+T10; T1 <- T01+T11#
  pHat <- T1/(n-1)#
  num  <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
  s01 <- T00+T01; pi01 <- if(s01>0) T01/s01 else 1#
  s11 <- T10+T11; pi11 <- if(s11>0) T11/s11 else 1#
  den  <- T00*safe_log(1-pi01) + T01*safe_log(pi01) +#
          T10*safe_log(1-pi11) + T11*safe_log(pi11)#
  lrind <- -2*(num - den)#
  lruc + lrind#
}#
#
## ---------- 3.  simulation -----------------------------------------#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
k_list     <- c(5,2,3)          # Basel-style extra exceptions#
Nrep       <- 2000#
#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)              # exact null once per (n, α)#
    LRv  <- dist$LR; Pv <- dist$prob#
#
    for(k in k_list){#
      alpha_star <- alpha_ + k / n_          # UC-violation only#
      alpha_star <- max(min(alpha_star, 1-1e-6), 1e-6)#
#
      rej_ex <- rej_ch <- numeric(Nrep)#
      for(i in seq_len(Nrep)){#
        X  <- rbinom(n_, 1, alpha_star)#
        LR <- my_compute_LRcc(X, alpha_)#
        rej_ex[i] <- get_pval_exact(LRv, Pv, LR) < 0.05#
        rej_ch[i] <- (1 - pchisq(LR, 2))    < 0.05#
      }#
      p_ex <- mean(rej_ex); se_ex <- sqrt(p_ex*(1-p_ex)/Nrep)#
      p_ch <- mean(rej_ch); se_ch <- sqrt(p_ch*(1-p_ch)/Nrep)#
#
      results_power <- rbind(results_power,#
        data.frame(n = n_, alpha = alpha_, k_extra = k,#
                   alpha_star = alpha_star,#
                   power_exact = p_ex,  se_exact = se_ex,#
                   power_chi2  = p_ch,  se_chi2  = se_ch))#
    }#
  }#
}#
#
## ---------- 4.  可视化（如需） -------------------------------------#
long_pow <- pivot_longer(results_power,#
                         cols = c(power_exact, power_chi2),#
                         names_to = "method", values_to = "power")#
long_pow$method[long_pow$method=="power_exact"] <- "exact"#
long_pow$method[long_pow$method=="power_chi2"]  <- "chi2(2)"#
#
ggplot(long_pow,#
       aes(factor(n), power, fill = method)) +#
  geom_bar(stat = "identity", position = "dodge") +#
  geom_errorbar(aes(#
        ymin = power - 1.96*ifelse(method=="exact", se_exact, se_chi2),#
        ymax = power + 1.96*ifelse(method=="exact", se_exact, se_chi2)),#
        position = position_dodge(0.9), width = 0.25) +#
  facet_grid(alpha ~ k_extra,#
             labeller = labeller(#
               alpha   = label_both,#
               k_extra = function(x) paste0("k = ", x, " extra"))) +#
  labs(x = "n", y = "empirical power (UC-violation only)",#
       title = "LRcc — exact vs χ²(2)") +#
  theme_minimal()#
#
## 结果数据框存于  results_power
#############################################################
##  LRcc  power study  ——  UC + IND violation (Markov chain)#
#############################################################
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(tidyr)#
#
## ---------- 1  C++  exact distribution  (同前，已修正长度) --------#
EPS <- 1e-15#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <cmath>#
#include <vector>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
inline double s_log(double x){ return std::log(x>EPS?x:EPS); }#
#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{ size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL, S2=M, S3=S2*M, S4=S3*M, S5=S4*M, S6=S5*M;#
  return la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[enc6(0,0,0,0,0,0,NMAX)] = {0,0,0,0,0,0,1.0-alpha};#
  cur[enc6(1,1,0,0,0,0,NMAX)] = {1,1,0,0,0,0,     alpha};#
#
  for(int k=1;k<n;++k){#
    std::unordered_map<long long,State,LLHash> nxt; nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p = kv.second.prob; if(p<prune) continue;#
      int la   = kv.second.la;#
      /* next=0 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T00 : ns.T10)++;#
        ns.la   = 0; ns.prob = p*(1.0-alpha);#
        nxt[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob += ns.prob;#
      }#
      /* next=1 */#
      {#
        State ns = kv.second;#
        (la==0? ns.T01 : ns.T11)++;#
        ns.la   = 1; ns.c1++; ns.prob = p*alpha;#
        nxt[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob += ns.prob;#
      }#
    }#
    cur.swap(nxt);#
  }#
#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p = kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    int len = T00+T10+T01+T11 + 1;#
    int c1  = kv.second.c1;#
#
    /* LR_uc */#
    double p_   = std::min(std::max(alpha,EPS),1.0-EPS);#
    double phat = (c1==0)?0.0:(c1==len?1.0:double(c1)/len);#
    double ph_  = std::min(std::max(phat,EPS),1.0-EPS);#
    double lruc = -2.0*( c1*std::log(p_) + (len-c1)*std::log(1.0-p_)#
                       - c1*std::log(ph_) - (len-c1)*std::log(1.0-ph_) );#
#
    /* LR_ind */#
    double lrind = 0.0;#
    if(len>1){#
      int T0 = T00+T10, T1 = T01+T11;#
      double pHat = double(T1)/(len-1);#
      double num  = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
#
      int s01=T00+T01, s11=T10+T11;#
      double pi01 = s01? double(T01)/s01 : 1.0;#
      double pi11 = s11? double(T11)/s11 : 1.0;#
      double den  = T00*s_log(1.0-pi01)+T01*s_log(pi01)+#
                    T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind = -2.0*(num-den);#
    }#
    dist[lruc+lrind] += p;#
  }#
#
  NumericVector LR,Prob;#
  std::vector<std::pair<double,double>> v(dist.begin(),dist.end());#
  std::sort(v.begin(),v.end(),[](auto &a,auto &b){return a.first<b.first;});#
  for(size_t i=0;i<v.size();){#
    double LRnow=v[i].first, pp=0.0;#
    while(i<v.size() && fabs(v[i].first-LRnow)<1e-15){pp+=v[i].second;++i;}#
    LR.push_back(LRnow); Prob.push_back(pp);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Prob);#
}#
')#
#
## ---------- 2  R-side helpers --------------------------------------#
safe_log <- function(x) log(pmax(x, EPS))#
fb_lrcc  <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
get_pval_exact <- function(LRvals, probvals, LRobs)#
  1 - sum(probvals[LRvals < LRobs])#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); x <- sum(X)#
  ## LR_uc#
  p_   <- pmax(pmin(alpha,1-EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat,1-EPS), EPS)#
  lruc <- -2*( x*safe_log(p_) + (n-x)*safe_log(1-p_) -#
               x*safe_log(ph_) - (n-x)*safe_log(1-ph_) )#
  if(n<=1) return(lruc)#
#
  ## LR_ind#
  counts <- matrix(0,2,2)#
  for(t in 2:n) counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1] + 1#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  T0 <- T00+T10; T1 <- T01+T11#
  pHat <- T1/(n-1)#
  num  <- T0*safe_log(1-pHat) + T1*safe_log(pHat)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den  <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+#
          T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  lrind <- -2*(num - den)#
  lruc + lrind#
}#
#
## 马尔可夫生成器：stationary = alpha*, autocorr = phi -----------#
gen_markov <- function(n, alpha_star, phi = 0.6){#
  stopifnot(alpha_star > 0, alpha_star < 1, phi >= 0, phi <= 1)#
  p11 <- phi#
  p01 <- alpha_star*(1-phi)/(1-alpha_star)  # from stationary constraint#
  stopifnot(p01 >= 0, p01 <= 1)             # sanity#
  X <- numeric(n); X[1] <- rbinom(1,1,alpha_star)#
  for(i in 2:n)#
    X[i] <- rbinom(1,1, ifelse(X[i-1]==1, p11, p01))#
  X#
}#
#
## ---------- 3  simulation design -----------------------------------#
set.seed(123)#
n_list     <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
k_list     <- c(5,7,10)      # Basel extra exceptions#
phi_val    <- 0.6#
Nrep       <- 2000#
#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)          # null exact dist once#
    LRv  <- dist$LR; Pv <- dist$prob#
    for(k in k_list){#
      alpha_star <- alpha_ + k / n_#
      alpha_star <- max(min(alpha_star, 1-1e-6), 1e-6)#
#
      rej_ex <- rej_ch <- numeric(Nrep)#
      for(i in seq_len(Nrep)){#
        X  <- gen_markov(n_, alpha_star, phi_val)  # 同时破坏 UC + IND#
        LR <- my_compute_LRcc(X, alpha_)#
        rej_ex[i] <- get_pval_exact(LRv, Pv, LR) < 0.05#
        rej_ch[i] <- (1 - pchisq(LR, 2)) < 0.05#
      }#
      p_ex <- mean(rej_ex); se_ex <- sqrt(p_ex*(1-p_ex)/Nrep)#
      p_ch <- mean(rej_ch); se_ch <- sqrt(p_ch*(1-p_ch)/Nrep)#
#
      results_power <- rbind(results_power,#
        data.frame(n = n_, alpha = alpha_, k_extra = k,#
                   alpha_star = alpha_star, phi = phi_val,#
                   power_exact = p_ex,  se_exact = se_ex,#
                   power_chi2  = p_ch,  se_chi2  = se_ch))#
    }#
  }#
}#
#
## ---------- 4  可视化 ---------------------------------------------#
long_pow <- pivot_longer(results_power,#
                         cols = c(power_exact, power_chi2),#
                         names_to = "method", values_to = "power")#
long_pow$method[long_pow$method=="power_exact"] <- "exact"#
long_pow$method[long_pow$method=="power_chi2"]  <- "chi2(2)"#
#
ggplot(long_pow,#
       aes(factor(n), power, fill = method)) +#
  geom_bar(stat = "identity", position = "dodge") +#
  geom_errorbar(aes(#
        ymin = power - 1.96*ifelse(method=="exact", se_exact, se_chi2),#
        ymax = power + 1.96*ifelse(method=="exact", se_exact, se_chi2)),#
        position = position_dodge(0.9), width = 0.25) +#
  facet_grid(alpha ~ k_extra,#
             labeller = labeller(#
               alpha   = label_both,#
               k_extra = function(x) paste0("k = ", x, " extra"))) +#
  labs(x = "n", y = "empirical power (UC + IND violated)",#
       title = "LRcc — exact vs χ²(2)  (Markov, φ = 0.6)") +#
  theme_minimal()#
#
## 结果数据框：results_power
results_power
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(tidyr)#
#
EPS <- 1e-15#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <algorithm>#
#include <cmath>#
using namespace Rcpp;#
const double EPS = 1e-15;#
inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,c1,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL,S2=M,S3=S2*M,S4=S3*M,S5=S4*M,S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[enc6(0,0,0,0,0,0,NMAX)]={0,0,0,0,0,0,1.0-alpha};#
  cur[enc6(1,1,0,0,0,0,NMAX)]={1,1,0,0,0,0,alpha};#
  for(int k=1;k<n;++k){#
    std::unordered_map<long long,State,LLHash> nxt; nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      {#
        State ns=kv.second;#
        (la==0?ns.T00:ns.T10)++; ns.la=0; ns.prob=p*(1-alpha);#
        nxt[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        (la==0?ns.T01:ns.T11)++; ns.la=1; ns.c1++; ns.prob=p*alpha;#
        nxt[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob+=ns.prob;#
      }#
    }#
    cur.swap(nxt);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    int len=T00+T10+T01+T11+1, c1=kv.second.c1;#
    double p_=std::min(std::max(alpha,EPS),1.0-EPS);#
    double phat=(c1==0)?0:(c1==len?1.0:(double)c1/len);#
    double ph_=std::min(std::max(phat,EPS),1.0-EPS);#
    double lruc=-2.0*(c1*std::log(p_)+(len-c1)*std::log(1-p_)-c1*std::log(ph_)-(len-c1)*std::log(1-ph_));#
    double lrind=0.0;#
    if(len>1){#
      int T0=T00+T10,T1=T01+T11;#
      double pHat=(double)T1/(len-1);#
      double num=T0*s_log(1-pHat)+T1*s_log(pHat);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01? (double)T01/s01:1.0;#
      double pi11=s11? (double)T11/s11:1.0;#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)+T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2.0*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> v(dist.begin(),dist.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Prob;#
  for(size_t i=0;i<v.size();){#
    double L=v[i].first,pp=0.0;#
    while(i<v.size()&&fabs(v[i].first-L)<1e-15){pp+=v[i].second;++i;}#
    LR.push_back(L); Prob.push_back(pp);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Prob);#
}#
')#
#
safe_log <- function(x) log(pmax(x, EPS))#
fb_lrcc  <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); x <- sum(X)#
  p_ <- pmax(pmin(alpha,1-EPS),EPS)#
  phat <- if(x==0)0 else if(x==n)1 else x/n#
  ph_ <- pmax(pmin(phat,1-EPS),EPS)#
  lruc <- -2*(x*safe_log(p_)+(n-x)*safe_log(1-p_)-x*safe_log(ph_)-(n-x)*safe_log(1-ph_))#
  if(n<=1) return(lruc)#
  counts <- matrix(0,2,2)#
  for(t in 2:n) counts[X[t-1]+1,X[t]+1] <- counts[X[t-1]+1,X[t]+1]+1#
  T00<-counts[1,1];T01<-counts[1,2];T10<-counts[2,1];T11<-counts[2,2]#
  T0<-T00+T10;T1<-T01+T11#
  pHat<-T1/(n-1)#
  num<-T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  s01<-T00+T01;pi01<-if(s01>0)T01/s01 else 1#
  s11<-T10+T11;pi11<-if(s11>0)T11/s11 else 1#
  den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  lrind <- -2*(num-den)#
  lruc+lrind#
}#
#
gen_markov <- function(n, alpha_star, phi=0.6){#
  p11 <- phi#
  p01 <- alpha_star*(1-phi)/(1-alpha_star)#
  X <- numeric(n); X[1] <- rbinom(1,1,alpha_star)#
  for(i in 2:n) X[i] <- rbinom(1,1,ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
k_list <- c(1,2,3)#
phi_val <- 0.6#
Nrep <- 2000#
#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)#
    LRv <- dist$LR; Pv <- dist$prob#
    for(k in k_list){#
      alpha_star <- max(min(alpha_ + k / n_,1-1e-6),1e-6)#
      rej_ex <- rej_ch <- numeric(Nrep)#
      for(i in seq_len(Nrep)){#
        X <- gen_markov(n_, alpha_star, phi_val)#
        LR <- my_compute_LRcc(X, alpha_)#
        rej_ex[i] <- get_pval_exact(LRv, Pv, LR) < 0.05#
        rej_ch[i] <- (1 - pchisq(LR, 2)) < 0.05#
      }#
      p_ex <- mean(rej_ex); se_ex <- sqrt(p_ex*(1-p_ex)/Nrep)#
      p_ch <- mean(rej_ch); se_ch <- sqrt(p_ch*(1-p_ch)/Nrep)#
      results_power <- rbind(results_power,#
        data.frame(n=n_,alpha=alpha_,k_extra=k,alpha_star=alpha_star,phi=phi_val,#
                   power_exact=p_ex,se_exact=se_ex,#
                   power_chi2=p_ch,se_chi2=se_ch))#
    }#
  }#
}#
#
long_pow <- pivot_longer(results_power,#
                         cols=c(power_exact,power_chi2),#
                         names_to="method",values_to="power")#
long_pow$method[long_pow$method=="power_exact"] <- "exact"#
long_pow$method[long_pow$method=="power_chi2"]  <- "chi2(2)"#
#
ggplot(long_pow,aes(factor(n),power,fill=method))+#
  geom_bar(stat="identity",position="dodge")+#
  geom_errorbar(aes(ymin=power-1.96*ifelse(method=="exact",se_exact,se_chi2),#
                    ymax=power+1.96*ifelse(method=="exact",se_exact,se_chi2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_grid(alpha~k_extra,#
             labeller=labeller(alpha=label_both,#
                               k_extra=function(x)paste0("k = ",x," extra")))+#
  labs(x="n",y="empirical power (UC + IND violated)",#
       title="LRcc — exact vs χ²(2)  (Markov, φ = 0.6)")+#
  theme_minimal()
#############################################################
##  LRcc power study —— UC + IND violation#
##  (α* = 1.2 · α, Markov φ = 0.6)#
#############################################################
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(tidyr)#
#
EPS <- 1e-15#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <algorithm>#
#include <cmath>#
using namespace Rcpp;#
const double EPS = 1e-15;#
inline double s_log(double x){ return std::log(x>EPS?x:EPS); }#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{ size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL,S2=M,S3=S2*M,S4=S3*M,S5=S4*M,S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(_["LR"]=NumericVector(0),_["prob"]=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[enc6(0,0,0,0,0,0,NMAX)]={0,0,0,0,0,0,1-alpha};#
  cur[enc6(1,1,0,0,0,0,NMAX)]={1,1,0,0,0,0,alpha};#
  for(int k=1;k<n;++k){#
    std::unordered_map<long long,State,LLHash> nxt; nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      { State ns=kv.second; (la?ns.T10:ns.T00)++; ns.la=0; ns.prob=p*(1-alpha);#
        nxt[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob+=ns.prob; }#
      { State ns=kv.second; (la?ns.T11:ns.T01)++; ns.la=1; ns.c1++; ns.prob=p*alpha;#
        nxt[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob+=ns.prob; }#
    }#
    cur.swap(nxt);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    int len=T00+T10+T01+T11+1, c1=kv.second.c1;#
    double p_=std::min(std::max(alpha,EPS),1.0-EPS);#
    double phat=(c1==0)?0:(c1==len?1.0:(double)c1/len);#
    double ph_=std::min(std::max(phat,EPS),1.0-EPS);#
    double lruc=-2.0*(c1*std::log(p_)+(len-c1)*std::log(1-p_)-c1*std::log(ph_)-(len-c1)*std::log(1-ph_));#
    double lrind=0.0;#
    if(len>1){#
      int T0=T00+T10,T1=T01+T11;#
      double pHat=(double)T1/(len-1);#
      double num=T0*s_log(1-pHat)+T1*s_log(pHat);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01? (double)T01/s01:1.0;#
      double pi11=s11? (double)T11/s11:1.0;#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)+T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2.0*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> v(dist.begin(),dist.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Prob;#
  for(size_t i=0;i<v.size();){#
    double L=v[i].first,pp=0.0;#
    while(i<v.size()&&fabs(v[i].first-L)<1e-15){pp+=v[i].second;++i;}#
    LR.push_back(L); Prob.push_back(pp);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Prob);#
}#
')#
#
safe_log <- function(x) log(pmax(x, EPS))#
fb_lrcc <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); x <- sum(X)#
  p_ <- pmax(pmin(alpha,1-EPS),EPS)#
  phat <- if(x==0)0 else if(x==n)1 else x/n#
  ph_ <- pmax(pmin(phat,1-EPS),EPS)#
  lruc <- -2*(x*safe_log(p_)+(n-x)*safe_log(1-p_)-x*safe_log(ph_)-(n-x)*safe_log(1-ph_))#
  if(n<=1) return(lruc)#
  counts <- matrix(0,2,2)#
  for(t in 2:n) counts[X[t-1]+1,X[t]+1] <- counts[X[t-1]+1,X[t]+1]+1#
  T00<-counts[1,1];T01<-counts[1,2];T10<-counts[2,1];T11<-counts[2,2]#
  T0<-T00+T10;T1<-T01+T11#
  pHat<-T1/(n-1)#
  num<-T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  s01<-T00+T01;pi01<-if(s01>0)T01/s01 else 1#
  s11<-T10+T11;pi11<-if(s11>0)T11/s11 else 1#
  den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  lrind <- -2*(num-den)#
  lruc+lrind#
}#
#
gen_markov <- function(n, alpha_star, phi=0.6){#
  p11 <- phi#
  p01 <- alpha_star*(1-phi)/(1-alpha_star)#
  X <- numeric(n); X[1] <- rbinom(1,1,alpha_star)#
  for(i in 2:n) X[i] <- rbinom(1,1,ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
ratio <- 1.2               # α* = 1.2 α#
phi_val <- 0.6#
Nrep <- 2000#
#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)#
    LRv <- dist$LR; Pv <- dist$prob#
    alpha_star <- max(min(alpha_*ratio,1-1e-6),1e-6)#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- gen_markov(n_, alpha_star, phi_val)#
      LR <- my_compute_LRcc(X, alpha_)#
      rej_ex[i] <- get_pval_exact(LRv, Pv, LR) < 0.05#
      rej_ch[i] <- (1 - pchisq(LR, 2)) < 0.05#
    }#
    p_ex <- mean(rej_ex); se_ex <- sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch <- mean(rej_ch); se_ch <- sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power <- rbind(results_power,#
      data.frame(n=n_,alpha=alpha_,alpha_star=alpha_star,phi=phi_val,#
                 power_exact=p_ex,se_exact=se_ex,#
                 power_chi2=p_ch,se_chi2=se_ch))#
  }#
}#
#
long_pow <- pivot_longer(results_power,#
                         cols=c(power_exact,power_chi2),#
                         names_to="method",values_to="power")#
long_pow$method[long_pow$method=="power_exact"] <- "exact"#
long_pow$method[long_pow$method=="power_chi2"]  <- "chi2(2)"#
#
ggplot(long_pow,aes(factor(n),power,fill=method))+#
  geom_bar(stat="identity",position="dodge")+#
  geom_errorbar(aes(ymin=power-1.96*ifelse(method=="exact",se_exact,se_chi2),#
                    ymax=power+1.96*ifelse(method=="exact",se_exact,se_chi2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~alpha,labeller=label_both)+#
  labs(x="n",y="empirical power (α* = 1.2 α, φ = 0.6)",#
       title="LRcc — exact vs χ²(2)")+#
  theme_minimal()
#############################################################
##  LRcc power study —— UC + IND violation#
##  (α* = 1.2 · α, Markov φ = 0.6)#
#############################################################
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(tidyr)#
#
EPS <- 1e-15#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <algorithm>#
#include <cmath>#
using namespace Rcpp;#
const double EPS = 1e-15;#
inline double s_log(double x){ return std::log(x>EPS?x:EPS); }#
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{ size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL,S2=M,S3=S2*M,S4=S3*M,S5=S4*M,S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(_["LR"]=NumericVector(0),_["prob"]=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  cur[enc6(0,0,0,0,0,0,NMAX)]={0,0,0,0,0,0,1-alpha};#
  cur[enc6(1,1,0,0,0,0,NMAX)]={1,1,0,0,0,0,alpha};#
  for(int k=1;k<n;++k){#
    std::unordered_map<long long,State,LLHash> nxt; nxt.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      { State ns=kv.second; (la?ns.T10:ns.T00)++; ns.la=0; ns.prob=p*(1-alpha);#
        nxt[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob+=ns.prob; }#
      { State ns=kv.second; (la?ns.T11:ns.T01)++; ns.la=1; ns.c1++; ns.prob=p*alpha;#
        nxt[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)].prob+=ns.prob; }#
    }#
    cur.swap(nxt);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    int len=T00+T10+T01+T11+1, c1=kv.second.c1;#
    double p_=std::min(std::max(alpha,EPS),1.0-EPS);#
    double phat=(c1==0)?0:(c1==len?1.0:(double)c1/len);#
    double ph_=std::min(std::max(phat,EPS),1.0-EPS);#
    double lruc=-2.0*(c1*std::log(p_)+(len-c1)*std::log(1-p_)-c1*std::log(ph_)-(len-c1)*std::log(1-ph_));#
    double lrind=0.0;#
    if(len>1){#
      int T0=T00+T10,T1=T01+T11;#
      double pHat=(double)T1/(len-1);#
      double num=T0*s_log(1-pHat)+T1*s_log(pHat);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01? (double)T01/s01:1.0;#
      double pi11=s11? (double)T11/s11:1.0;#
      double den=T00*s_log(1-pi01)+T01*s_log(pi01)+T10*s_log(1-pi11)+T11*s_log(pi11);#
      lrind=-2.0*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> v(dist.begin(),dist.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Prob;#
  for(size_t i=0;i<v.size();){#
    double L=v[i].first,pp=0.0;#
    while(i<v.size()&&fabs(v[i].first-L)<1e-15){pp+=v[i].second;++i;}#
    LR.push_back(L); Prob.push_back(pp);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Prob);#
}#
')#
#
safe_log <- function(x) log(pmax(x, EPS))#
fb_lrcc <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); x <- sum(X)#
  p_ <- pmax(pmin(alpha,1-EPS),EPS)#
  phat <- if(x==0)0 else if(x==n)1 else x/n#
  ph_ <- pmax(pmin(phat,1-EPS),EPS)#
  lruc <- -2*(x*safe_log(p_)+(n-x)*safe_log(1-p_)-x*safe_log(ph_)-(n-x)*safe_log(1-ph_))#
  if(n<=1) return(lruc)#
  counts <- matrix(0,2,2)#
  for(t in 2:n) counts[X[t-1]+1,X[t]+1] <- counts[X[t-1]+1,X[t]+1]+1#
  T00<-counts[1,1];T01<-counts[1,2];T10<-counts[2,1];T11<-counts[2,2]#
  T0<-T00+T10;T1<-T01+T11#
  pHat<-T1/(n-1)#
  num<-T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  s01<-T00+T01;pi01<-if(s01>0)T01/s01 else 1#
  s11<-T10+T11;pi11<-if(s11>0)T11/s11 else 1#
  den<-T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  lrind <- -2*(num-den)#
  lruc+lrind#
}#
#
gen_markov <- function(n, alpha_star, phi=0.6){#
  p11 <- phi#
  p01 <- alpha_star*(1-phi)/(1-alpha_star)#
  X <- numeric(n); X[1] <- rbinom(1,1,alpha_star)#
  for(i in 2:n) X[i] <- rbinom(1,1,ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
ratio <- 1.1               # α* = 1.1 α#
phi_val <- 0.3#
Nrep <- 2000#
#
results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)#
    LRv <- dist$LR; Pv <- dist$prob#
    alpha_star <- max(min(alpha_*ratio,1-1e-6),1e-6)#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in seq_len(Nrep)){#
      X <- gen_markov(n_, alpha_star, phi_val)#
      LR <- my_compute_LRcc(X, alpha_)#
      rej_ex[i] <- get_pval_exact(LRv, Pv, LR) < 0.05#
      rej_ch[i] <- (1 - pchisq(LR, 2)) < 0.05#
    }#
    p_ex <- mean(rej_ex); se_ex <- sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch <- mean(rej_ch); se_ch <- sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power <- rbind(results_power,#
      data.frame(n=n_,alpha=alpha_,alpha_star=alpha_star,phi=phi_val,#
                 power_exact=p_ex,se_exact=se_ex,#
                 power_chi2=p_ch,se_chi2=se_ch))#
  }#
}#
#
long_pow <- pivot_longer(results_power,#
                         cols=c(power_exact,power_chi2),#
                         names_to="method",values_to="power")#
long_pow$method[long_pow$method=="power_exact"] <- "exact"#
long_pow$method[long_pow$method=="power_chi2"]  <- "chi2(2)"#
#
ggplot(long_pow,aes(factor(n),power,fill=method))+#
  geom_bar(stat="identity",position="dodge")+#
  geom_errorbar(aes(ymin=power-1.96*ifelse(method=="exact",se_exact,se_chi2),#
                    ymax=power+1.96*ifelse(method=="exact",se_exact,se_chi2)),#
                position=position_dodge(0.9),width=0.25)+#
  facet_wrap(~alpha,labeller=label_both)+#
  labs(x="n",y="empirical power (α* = 1.2 α, φ = 0.6)",#
       title="LRcc — exact vs χ²(2)")+#
  theme_minimal()
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
fb_lrind <- function(n, alpha = 0.05, prune_threshold = 1e-15) {#
  combine_states <- function(mat) {#
    if (!nrow(mat)) return(mat)#
    o <- do.call(order, lapply(seq_len(5), function(i) mat[, i]))#
    mat <- mat[o, , drop = FALSE]#
    d  <- abs(diff(mat[, 1])) + abs(diff(mat[, 2])) + abs(diff(mat[, 3])) +#
          abs(diff(mat[, 4])) + abs(diff(mat[, 5]))#
    idx <- c(which(d > 0), nrow(mat))#
    out <- mat[idx, , drop = FALSE]#
    start <- 1#
    for (i in seq_along(idx)) {#
      s <- start; e <- idx[i]#
      if (s < e) out[i, 6] <- sum(mat[s:e, 6])#
      start <- e + 1#
    }#
    out#
  }#
#
  S <- matrix(c(0, 0, 0, 0, 0, 1 - alpha,#
                1, 0, 0, 0, 0, alpha),#
              nrow = 2, ncol = 6, byrow = TRUE)#
#
  for (k in seq_len(n - 1)) {#
    S <- S[S[, 6] >= prune_threshold, , drop = FALSE]#
    if (!nrow(S)) break#
#
    tmp0 <- S; tmp1 <- S#
    tmp0[, 2] <- tmp0[, 2] + ifelse(tmp0[, 1] == 0, 1, 0)#
    tmp0[, 3] <- tmp0[, 3] + ifelse(tmp0[, 1] == 1, 1, 0)#
    tmp0[, 1] <- 0#
    tmp0[, 6] <- tmp0[, 6] * (1 - alpha)#
#
    tmp1[, 4] <- tmp1[, 4] + ifelse(tmp1[, 1] == 0, 1, 0)#
    tmp1[, 5] <- tmp1[, 5] + ifelse(tmp1[, 1] == 1, 1, 0)#
    tmp1[, 1] <- 1#
    tmp1[, 6] <- tmp1[, 6] * alpha#
#
    S <- rbind(tmp0, tmp1)#
    S <- combine_states(S)#
  }#
#
  S <- S[S[, 6] > 0, , drop = FALSE]#
  if (!nrow(S)) return(list(LR = numeric(0), prob = numeric(0)))#
#
  T0 <- S[, 2] + S[, 3]#
  T1 <- S[, 4] + S[, 5]#
  pHat <- if (n > 1) T1 / (n - 1) else 0#
  num <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
#
  pi01 <- ifelse((S[, 2] + S[, 4]) > 0, S[, 4] / (S[, 2] + S[, 4]), 1)#
  pi11 <- ifelse((S[, 3] + S[, 5]) > 0, S[, 5] / (S[, 3] + S[, 5]), 1)#
  den <- S[, 2] * safe_log(1 - pi01) + S[, 4] * safe_log(pi01) +#
         S[, 3] * safe_log(1 - pi11) + S[, 5] * safe_log(pi11)#
#
  LR <- -2 * (num - den)#
  out <- cbind(LR, S[, 6])#
  o <- order(out[, 1]); out <- out[o, , drop = FALSE]#
#
  d <- c(diff(out[, 1]), 1)#
  idx <- c(which(d != 0), nrow(out))#
  final <- out[idx, , drop = FALSE]#
#
  start <- 1#
  for (i in seq_along(idx)) {#
    s <- start; e <- idx[i]#
    if (s < e) final[i, 2] <- sum(out[s:e, 2])#
    start <- e + 1#
  }#
#
  list(LR = final[, 1], prob = final[, 2])#
}#
#
main <- function() {#
  alpha_test <- 0.05#
  for (n_ in c(15, 100, 500, 1000, 2000)) {#
    cat(sprintf("\n=== n= %d, alpha= %g ===\n", n_, alpha_test))#
    t1 <- proc.time()#
    fb_res <- fb_lrind(n_, alpha_test, 1e-15)#
    tfb <- proc.time() - t1#
    cat(sprintf("FB time= %.3fs, #distinct LR= %d, sum(prob)= %.6f\n",#
                tfb["elapsed"], length(fb_res$LR), sum(fb_res$prob)))#
  }#
}#
main()
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x) {#
  return std::log( x > EPS ? x : EPS );#
}#
#
struct State {#
  long long code;#
  int last;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_state(int last, int s00, int s10, int s01, int s11,#
                                     long long SHIFT2, long long SHIFT3,#
                                     long long SHIFT4, long long SHIFT5) {#
  return (long long)last#
         + SHIFT2*(long long)s00#
         + SHIFT3*(long long)s10#
         + SHIFT4*(long long)s01#
         + SHIFT5*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n < 1) {#
    return List::create(Named("LR")=NumericVector(0), Named("prob")=NumericVector(0));#
  }#
  long long SHIFT2 = 2LL;#
  long long SHIFT3 = SHIFT2 * (n+1);#
  long long SHIFT4 = SHIFT3 * (n+1);#
  long long SHIFT5 = SHIFT4 * (n+1);#
#
  std::vector<State> states;#
  states.reserve(2);#
#
  {#
    State s0;#
    s0.last=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0 - alpha;#
    s0.code = encode_state(s0.last, s0.s00, s0.s10, s0.s01, s0.s11, SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
    states.push_back(s0);#
    State s1;#
    s1.last=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
    s1.code = encode_state(s1.last, s1.s00, s1.s10, s1.s01, s1.s11, SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
    states.push_back(s1);#
  }#
#
  for(int k=1; k<n; k++) {#
    {#
      int idx=0;#
      for(int i=0; i<(int)states.size(); i++){#
        if(states[i].prob >= prune_threshold) {#
          states[idx++] = states[i];#
        }#
      }#
      states.resize(idx);#
    }#
    if(states.empty()) break;#
#
    std::unordered_map<long long, State, LLHash> newMap;#
    newMap.reserve(states.size()*2);#
#
    for(std::size_t i=0; i<states.size(); i++){#
      const State &st = states[i];#
      double p = st.prob;#
      if(p <= 0) continue;#
#
      {#
        State ns = st;#
        int inc00 = (ns.last==0)?1:0;#
        int inc10 = (ns.last==1)?1:0;#
        ns.s00 += inc00;#
        ns.s10 += inc10;#
        ns.last = 0;#
        ns.prob = p*(1.0 - alpha);#
        ns.code = encode_state(ns.last, ns.s00, ns.s10, ns.s01, ns.s11,#
                               SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
        auto it = newMap.find(ns.code);#
        if(it == newMap.end()){#
          newMap[ns.code] = ns;#
        } else {#
          it->second.prob += ns.prob;#
        }#
      }#
#
      {#
        State ns = st;#
        int inc01 = (ns.last==0)?1:0;#
        int inc11 = (ns.last==1)?1:0;#
        ns.s01 += inc01;#
        ns.s11 += inc11;#
        ns.last = 1;#
        ns.prob = p*alpha;#
        ns.code = encode_state(ns.last, ns.s00, ns.s10, ns.s01, ns.s11,#
                               SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
        auto it = newMap.find(ns.code);#
        if(it == newMap.end()){#
          newMap[ns.code] = ns;#
        } else {#
          it->second.prob += ns.prob;#
        }#
      }#
    }#
#
    states.clear();#
    states.reserve(newMap.size());#
    for(auto &kv : newMap) {#
      if(kv.second.prob>0) {#
        states.push_back(kv.second);#
      }#
    }#
  }#
#
  {#
    int idx=0;#
    for(int i=0; i<(int)states.size(); i++){#
      if(states[i].prob >= prune_threshold) {#
        states[idx++] = states[i];#
      }#
    }#
    states.resize(idx);#
  }#
  if(states.empty()) {#
    return List::create(Named("LR")=NumericVector(0), Named("prob")=NumericVector(0));#
  }#
#
  std::vector<double> LR; LR.reserve(states.size());#
  std::vector<double> PR; PR.reserve(states.size());#
  for(std::size_t i=0; i<states.size(); i++){#
    State &st = states[i];#
    int T0 = st.s00 + st.s10;#
    int T1 = st.s01 + st.s11;#
    double pHat = (n>1)? ( (double)T1 / (double)(n-1) ) : 0.0;#
    double num = T0*safe_log(1 - pHat) + T1*safe_log(pHat);#
    double denom=0.0;#
    int sum01 = st.s00 + st.s01;#
    double pi01 = (sum01>0)? ((double)st.s01/(double)sum01):1.0;#
    int sum11 = st.s10 + st.s11;#
    double pi11 = (sum11>0)? ((double)st.s11/(double)sum11):1.0;#
    denom += st.s00*safe_log(1 - pi01) + st.s01*safe_log(pi01);#
    denom += st.s10*safe_log(1 - pi11) + st.s11*safe_log(pi11);#
    double lrval = -2.0*(num - denom);#
    LR.push_back(lrval);#
    PR.push_back(st.prob);#
  }#
#
  std::vector<int> idx(states.size());#
  for(int i=0; i<(int)idx.size(); i++) idx[i]=i;#
  std::sort(idx.begin(), idx.end(), [&](int a, int b){ return LR[a] < LR[b]; });#
#
  std::vector<double> sortedLR; sortedLR.reserve(idx.size());#
  std::vector<double> sortedPR; sortedPR.reserve(idx.size());#
  for(auto i : idx){ sortedLR.push_back(LR[i]); sortedPR.push_back(PR[i]); }#
#
  NumericVector outLR, outProb;#
  if(!sortedLR.empty()){#
    double curLR = sortedLR[0];#
    double curP  = sortedPR[0];#
    for(int i=1; i<(int)sortedLR.size(); i++){#
      if(std::fabs(sortedLR[i] - curLR) < 1e-15) {#
        curP += sortedPR[i];#
      } else {#
        outLR.push_back(curLR);#
        outProb.push_back(curP);#
        curLR = sortedLR[i];#
        curP  = sortedPR[i];#
      }#
    }#
    outLR.push_back(curLR);#
    outProb.push_back(curP);#
  }#
  return List::create(Named("LR")=outLR, Named("prob")=outProb);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
}#
#
main <- function() {#
  alpha_test <- 0.05#
  for(n_ in c(15,100,500,1000,2000)) {#
    cat(sprintf("\n=== n= %d, alpha= %g ===\n", n_, alpha_test))#
    t1 <- proc.time()#
    fb_res <- fb_lrind(n_, alpha_test, 1e-15)#
    tfb <- proc.time() - t1#
    cat(sprintf("FB time= %.3fs, #distinct LR= %d, sum(prob)= %.6f\n",#
                tfb["elapsed"], length(fb_res$LR), sum(fb_res$prob)))#
  }#
}#
main()
safe_log <- function(x) {#
  eps <- 1e-15#
  log(pmax(x, eps))#
}#
#
fb_lrind <- function(n, alpha = 0.05, prune_threshold = 1e-15) {#
  ##--- helper: aggregate states having identical 5-tuple --------------------#
  combine_states <- function(mat) {#
    if (!nrow(mat)) return(mat)#
    o <- do.call(order, lapply(seq_len(5), function(i) mat[, i]))#
    mat <- mat[o, , drop = FALSE]#
#
    d  <- abs(diff(mat[, 1])) + abs(diff(mat[, 2])) +#
          abs(diff(mat[, 3])) + abs(diff(mat[, 4])) +#
          abs(diff(mat[, 5]))#
    idx <- c(which(d > 0), nrow(mat))#
#
    out <- mat[idx, , drop = FALSE]#
    start <- 1#
    for (i in seq_along(idx)) {#
      s <- start; e <- idx[i]#
      if (s < e) out[i, 6] <- sum(mat[s:e, 6])#
      start <- e + 1#
    }#
    out#
  }#
#
  ##--- initial two states ---------------------------------------------------#
  S <- matrix(c(0, 0, 0, 0, 0, 1 - alpha,#
                1, 0, 0, 0, 0, alpha),#
              nrow = 2, ncol = 6, byrow = TRUE)#
#
  ##--- forward recursion ----------------------------------------------------#
  for (k in seq_len(n - 1)) {#
    S <- S[S[, 6] >= prune_threshold, , drop = FALSE]#
    if (!nrow(S)) break#
#
    tmp0 <- S; tmp1 <- S#
#
    ## 0-step#
    tmp0[, 2] <- tmp0[, 2] + ifelse(tmp0[, 1] == 0, 1, 0)#
    tmp0[, 3] <- tmp0[, 3] + ifelse(tmp0[, 1] == 1, 1, 0)#
    tmp0[, 1] <- 0#
    tmp0[, 6] <- tmp0[, 6] * (1 - alpha)#
#
    ## 1-step#
    tmp1[, 4] <- tmp1[, 4] + ifelse(tmp1[, 1] == 0, 1, 0)#
    tmp1[, 5] <- tmp1[, 5] + ifelse(tmp1[, 1] == 1, 1, 0)#
    tmp1[, 1] <- 1#
    tmp1[, 6] <- tmp1[, 6] * alpha#
#
    S <- rbind(tmp0, tmp1)#
    S <- combine_states(S)#
  }#
#
  ##--- terminate: compute LR and aggregate ----------------------------------#
  S <- S[S[, 6] > 0, , drop = FALSE]#
  if (!nrow(S))#
    return(list(LR = numeric(0), prob = numeric(0)))#
#
  T0   <- S[, 2] + S[, 3]#
  T1   <- S[, 4] + S[, 5]#
  pHat <- if (n > 1) T1 / (n - 1) else 0#
  num  <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
#
  pi01 <- ifelse((S[, 2] + S[, 4]) > 0,#
                 S[, 4] / (S[, 2] + S[, 4]), 1)#
  pi11 <- ifelse((S[, 3] + S[, 5]) > 0,#
                 S[, 5] / (S[, 3] + S[, 5]), 1)#
  den  <- S[, 2] * safe_log(1 - pi01) + S[, 4] * safe_log(pi01) +#
          S[, 3] * safe_log(1 - pi11) + S[, 5] * safe_log(pi11)#
#
  LR <- -2 * (num - den)#
#
  out <- cbind(LR, S[, 6])#
  out <- out[order(out[, 1]), , drop = FALSE]#
#
  ## --- 关键修改：用容差 tol 合并 -----------------------------------------#
  tol <- 1e-15                           # 与 C++ 版相同的判等公差#
  d   <- c(diff(out[, 1]), 1)#
  d[abs(d) < tol] <- 0                   # 相差 < tol 视为同值#
  idx <- c(which(d != 0), nrow(out))#
#
  final <- out[idx, , drop = FALSE]#
  start <- 1#
  for (i in seq_along(idx)) {#
    s <- start; e <- idx[i]#
    if (s < e) final[i, 2] <- sum(out[s:e, 2])#
    start <- e + 1#
  }#
#
  list(LR = final[, 1], prob = final[, 2])#
}
main <- function() {#
  alpha_test <- 0.05#
  for (n_ in c(15, 100, 500, 1000, 2000)) {#
    cat(sprintf("\n=== n= %d, alpha= %g ===\n", n_, alpha_test))#
    t1 <- proc.time()#
    fb_res <- fb_lrind(n_, alpha_test, 1e-15)#
    tfb <- proc.time() - t1#
    cat(sprintf("FB time= %.3fs, #distinct LR= %d, sum(prob)= %.6f\n",#
                tfb["elapsed"], length(fb_res$LR), sum(fb_res$prob)))#
  }#
}#
main()
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
fb_lrind <- function(n, alpha = 0.05, prune_threshold = 1e-15) {#
  combine_states <- function(mat) {#
    if (!nrow(mat)) return(mat)#
    o <- do.call(order, lapply(seq_len(5), function(i) mat[, i]))#
    mat <- mat[o, , drop = FALSE]#
    d  <- abs(diff(mat[, 1])) + abs(diff(mat[, 2])) + abs(diff(mat[, 3])) +#
          abs(diff(mat[, 4])) + abs(diff(mat[, 5]))#
    idx <- c(which(d > 0), nrow(mat))#
    out <- mat[idx, , drop = FALSE]#
    start <- 1#
    for (i in seq_along(idx)) {#
      s <- start; e <- idx[i]#
      if (s < e) out[i, 6] <- sum(mat[s:e, 6])#
      start <- e + 1#
    }#
    out#
  }#
#
  S <- matrix(c(0, 0, 0, 0, 0, 1 - alpha,#
                1, 0, 0, 0, 0, alpha),#
              nrow = 2, ncol = 6, byrow = TRUE)#
#
  for (k in seq_len(n - 1)) {#
    S <- S[S[, 6] >= prune_threshold, , drop = FALSE]#
    if (!nrow(S)) break#
#
    tmp0 <- S; tmp1 <- S#
    tmp0[, 2] <- tmp0[, 2] + ifelse(tmp0[, 1] == 0, 1, 0)#
    tmp0[, 3] <- tmp0[, 3] + ifelse(tmp0[, 1] == 1, 1, 0)#
    tmp0[, 1] <- 0#
    tmp0[, 6] <- tmp0[, 6] * (1 - alpha)#
#
    tmp1[, 4] <- tmp1[, 4] + ifelse(tmp1[, 1] == 0, 1, 0)#
    tmp1[, 5] <- tmp1[, 5] + ifelse(tmp1[, 1] == 1, 1, 0)#
    tmp1[, 1] <- 1#
    tmp1[, 6] <- tmp1[, 6] * alpha#
#
    S <- rbind(tmp0, tmp1)#
    S <- combine_states(S)#
  }#
#
  S <- S[S[, 6] > 0, , drop = FALSE]#
  if (!nrow(S)) return(list(LR = numeric(0), prob = numeric(0)))#
#
  T0 <- S[, 2] + S[, 3]#
  T1 <- S[, 4] + S[, 5]#
  pHat <- if (n > 1) T1 / (n - 1) else 0#
  num <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
#
  pi01 <- ifelse((S[, 2] + S[, 4]) > 0, S[, 4] / (S[, 2] + S[, 4]), 1)#
  pi11 <- ifelse((S[, 3] + S[, 5]) > 0, S[, 5] / (S[, 3] + S[, 5]), 1)#
  den <- S[, 2] * safe_log(1 - pi01) + S[, 4] * safe_log(pi01) +#
         S[, 3] * safe_log(1 - pi11) + S[, 5] * safe_log(pi11)#
#
  LR <- -2 * (num - den)#
  out <- cbind(LR, S[, 6])#
  o <- order(out[, 1]); out <- out[o, , drop = FALSE]#
#
  d <- c(diff(out[, 1]), 1)#
  idx <- c(which(d != 0), nrow(out))#
  final <- out[idx, , drop = FALSE]#
#
  start <- 1#
  for (i in seq_along(idx)) {#
    s <- start; e <- idx[i]#
    if (s < e) final[i, 2] <- sum(out[s:e, 2])#
    start <- e + 1#
  }#
#
  list(LR = final[, 1], prob = final[, 2])#
}#
#
main <- function() {#
  alpha_test <- 0.05#
  for (n_ in c(15, 100, 500, 1000, 2000)) {#
    cat(sprintf("\n=== n= %d, alpha= %g ===\n", n_, alpha_test))#
    t1 <- proc.time()#
    fb_res <- fb_lrind(n_, alpha_test, 1e-15)#
    tfb <- proc.time() - t1#
    cat(sprintf("FB time= %.3fs, #distinct LR= %d, sum(prob)= %.6f\n",#
                tfb["elapsed"], length(fb_res$LR), sum(fb_res$prob)))#
  }#
}#
main()
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x) {#
  return std::log( x > EPS ? x : EPS );#
}#
#
struct State {#
  long long code;#
  int last;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_state(int last, int s00, int s10, int s01, int s11,#
                                     long long SHIFT2, long long SHIFT3,#
                                     long long SHIFT4, long long SHIFT5) {#
  return (long long)last#
         + SHIFT2*(long long)s00#
         + SHIFT3*(long long)s10#
         + SHIFT4*(long long)s01#
         + SHIFT5*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15) {#
  if(n < 1) {#
    return List::create(Named("LR")=NumericVector(0), Named("prob")=NumericVector(0));#
  }#
  long long SHIFT2 = 2LL;#
  long long SHIFT3 = SHIFT2 * (n+1);#
  long long SHIFT4 = SHIFT3 * (n+1);#
  long long SHIFT5 = SHIFT4 * (n+1);#
#
  std::vector<State> states;#
  states.reserve(2);#
#
  {#
    State s0;#
    s0.last=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0 - alpha;#
    s0.code = encode_state(s0.last, s0.s00, s0.s10, s0.s01, s0.s11, SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
    states.push_back(s0);#
    State s1;#
    s1.last=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
    s1.code = encode_state(s1.last, s1.s00, s1.s10, s1.s01, s1.s11, SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
    states.push_back(s1);#
  }#
#
  for(int k=1; k<n; k++) {#
    {#
      int idx=0;#
      for(int i=0; i<(int)states.size(); i++){#
        if(states[i].prob >= prune_threshold) {#
          states[idx++] = states[i];#
        }#
      }#
      states.resize(idx);#
    }#
    if(states.empty()) break;#
#
    std::unordered_map<long long, State, LLHash> newMap;#
    newMap.reserve(states.size()*2);#
#
    for(std::size_t i=0; i<states.size(); i++){#
      const State &st = states[i];#
      double p = st.prob;#
      if(p <= 0) continue;#
#
      {#
        State ns = st;#
        int inc00 = (ns.last==0)?1:0;#
        int inc10 = (ns.last==1)?1:0;#
        ns.s00 += inc00;#
        ns.s10 += inc10;#
        ns.last = 0;#
        ns.prob = p*(1.0 - alpha);#
        ns.code = encode_state(ns.last, ns.s00, ns.s10, ns.s01, ns.s11,#
                               SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
        auto it = newMap.find(ns.code);#
        if(it == newMap.end()){#
          newMap[ns.code] = ns;#
        } else {#
          it->second.prob += ns.prob;#
        }#
      }#
#
      {#
        State ns = st;#
        int inc01 = (ns.last==0)?1:0;#
        int inc11 = (ns.last==1)?1:0;#
        ns.s01 += inc01;#
        ns.s11 += inc11;#
        ns.last = 1;#
        ns.prob = p*alpha;#
        ns.code = encode_state(ns.last, ns.s00, ns.s10, ns.s01, ns.s11,#
                               SHIFT2, SHIFT3, SHIFT4, SHIFT5);#
        auto it = newMap.find(ns.code);#
        if(it == newMap.end()){#
          newMap[ns.code] = ns;#
        } else {#
          it->second.prob += ns.prob;#
        }#
      }#
    }#
#
    states.clear();#
    states.reserve(newMap.size());#
    for(auto &kv : newMap) {#
      if(kv.second.prob>0) {#
        states.push_back(kv.second);#
      }#
    }#
  }#
#
  {#
    int idx=0;#
    for(int i=0; i<(int)states.size(); i++){#
      if(states[i].prob >= prune_threshold) {#
        states[idx++] = states[i];#
      }#
    }#
    states.resize(idx);#
  }#
  if(states.empty()) {#
    return List::create(Named("LR")=NumericVector(0), Named("prob")=NumericVector(0));#
  }#
#
  std::vector<double> LR; LR.reserve(states.size());#
  std::vector<double> PR; PR.reserve(states.size());#
  for(std::size_t i=0; i<states.size(); i++){#
    State &st = states[i];#
    int T0 = st.s00 + st.s10;#
    int T1 = st.s01 + st.s11;#
    double pHat = (n>1)? ( (double)T1 / (double)(n-1) ) : 0.0;#
    double num = T0*safe_log(1 - pHat) + T1*safe_log(pHat);#
    double denom=0.0;#
    int sum01 = st.s00 + st.s01;#
    double pi01 = (sum01>0)? ((double)st.s01/(double)sum01):1.0;#
    int sum11 = st.s10 + st.s11;#
    double pi11 = (sum11>0)? ((double)st.s11/(double)sum11):1.0;#
    denom += st.s00*safe_log(1 - pi01) + st.s01*safe_log(pi01);#
    denom += st.s10*safe_log(1 - pi11) + st.s11*safe_log(pi11);#
    double lrval = -2.0*(num - denom);#
    LR.push_back(lrval);#
    PR.push_back(st.prob);#
  }#
#
  std::vector<int> idx(states.size());#
  for(int i=0; i<(int)idx.size(); i++) idx[i]=i;#
  std::sort(idx.begin(), idx.end(), [&](int a, int b){ return LR[a] < LR[b]; });#
#
  std::vector<double> sortedLR; sortedLR.reserve(idx.size());#
  std::vector<double> sortedPR; sortedPR.reserve(idx.size());#
  for(auto i : idx){ sortedLR.push_back(LR[i]); sortedPR.push_back(PR[i]); }#
#
  NumericVector outLR, outProb;#
  if(!sortedLR.empty()){#
    double curLR = sortedLR[0];#
    double curP  = sortedPR[0];#
    for(int i=1; i<(int)sortedLR.size(); i++){#
      if(std::fabs(sortedLR[i] - curLR) < 1e-15) {#
        curP += sortedPR[i];#
      } else {#
        outLR.push_back(curLR);#
        outProb.push_back(curP);#
        curLR = sortedLR[i];#
        curP  = sortedPR[i];#
      }#
    }#
    outLR.push_back(curLR);#
    outProb.push_back(curP);#
  }#
  return List::create(Named("LR")=outLR, Named("prob")=outProb);#
}#
')#
#
fb_lrind <- function(n, alpha=0.05, prune_threshold=1e-15) {#
  fb_lrind_fastcpp(n, alpha, prune_threshold)#
}#
#
main <- function() {#
  alpha_test <- 0.05#
  for(n_ in c(15,100,500,1000,2000)) {#
    cat(sprintf("\n=== n= %d, alpha= %g ===\n", n_, alpha_test))#
    t1 <- proc.time()#
    fb_res <- fb_lrind(n_, alpha_test, 1e-15)#
    tfb <- proc.time() - t1#
    cat(sprintf("FB time= %.3fs, #distinct LR= %d, sum(prob)= %.6f\n",#
                tfb["elapsed"], length(fb_res$LR), sum(fb_res$prob)))#
  }#
}#
main()
main <- function() {#
   alpha_list <- c(0.01, 0.025, 0.05, 0.10)#
   n_list <- c(250, 500, 1000, 2000)#
   prune_threshold <- 1e-15#
   cat("   n     alpha   #distinct_LR    sum(prob)       time(s)\n")#
   for(alpha_ in alpha_list) {#
     for(n_ in n_list) {#
       t0 <- proc.time()#
       res <- fb_lrind(n_, alpha_, prune_threshold)#
       elapsed <- proc.time() - t0#
       LRvals <- res$LR#
       probvals <- res$prob#
       sumprob <- sum(probvals)#
       cat(sprintf("%5d  %7.3f  %12d  %10.8f  %10.4f\n",#
                   n_, alpha_, length(LRvals), sumprob, elapsed["elapsed"]))#
     }#
     cat("\n")#
   }#
 }#
main()
main <- function() {#
   thresholds <- c(1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10)#
   alpha_list <- c(0.01, 0.05, 0.10)#
   n_list <- c(500, 1000)#
   for(n_ in n_list) {#
     cat(sprintf("\nn = %d\n", n_))#
     for(alpha_ in alpha_list) {#
       cat(sprintf("\n=== alpha = %g ===\n", alpha_))#
       cat("prune_threshold     #distinct_LR     sum(prob)        time(s)\n")#
       for(th in thresholds) {#
         t0 <- proc.time()#
         res <- fb_lrind(n_, alpha_, th) #
         elapsed <- proc.time() - t0#
         LRvals <- res$LR#
         probvals <- res$prob#
         sumprob <- sum(probvals)#
         distinct_LR <- length(LRvals)#
         cat(sprintf("%-14g %14d %12.8f %12.4f\n",#
                     th, distinct_LR, sumprob, elapsed["elapsed"]))#
       }#
     }#
   }#
 }#
main()
# ---------- helper functions 保持不变 ----------#
safe_log <- function(x) log(pmax(x, 1e-15))#
#
mc_lrind <- function(n, alpha = 0.05, Nrep = 20000) {#
  LR_values <- numeric(Nrep)#
  for (i in seq_len(Nrep)) {#
    path <- rbinom(n, 1, alpha)#
    T00 <- T01 <- T10 <- T11 <- 0L#
    for (t in 2:n) {#
      if (path[t - 1] == 0L && path[t] == 0L)       T00 <- T00 + 1L#
      else if (path[t - 1] == 0L && path[t] == 1L)  T01 <- T01 + 1L#
      else if (path[t - 1] == 1L && path[t] == 0L)  T10 <- T10 + 1L#
      else                                          T11 <- T11 + 1L#
    }#
    T0 <- T00 + T10;  T1 <- T01 + T11#
    pHat <- if (n > 1) T1 / (n - 1) else 0#
#
    num <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
    pi01 <- if (T00 + T01 > 0) T01 / (T00 + T01) else 1#
    pi11 <- if (T10 + T11 > 0) T11 / (T10 + T11) else 1#
    den <- T00 * safe_log(1 - pi01) + T01 * safe_log(pi01) +#
           T10 * safe_log(1 - pi11) + T11 * safe_log(pi11)#
#
    LR_values[i] <- -2 * (num - den)#
  }#
#
  arr <- sort(LR_values)#
  idx_diff <- which(diff(arr) > 0)#
  uniq_idx <- c(idx_diff, length(arr))#
  list(LR   = arr[uniq_idx],#
       prob = diff(c(0, uniq_idx)) / Nrep)#
}#
#
step_cdf_plot <- function(LRvals, probs, col = "blue", lty = 1) {#
  cdf <- cumsum(probs)#
  x <- c(0, LRvals)#
  y <- c(0, cdf)#
  lines(x, y, type = "s", col = col, lty = lty)#
  points(x, y, pch = 16, cex = 0.4, col = col)#
}#
#
plot_three_distributions <- function(n, alpha, fb_res, mc_res) {#
  plot(0, 0, type = "n",#
       xlab = "LR value", ylab = "CDF",#
       xlim = c(0, max(c(fb_res$LR, mc_res$LR, 10))),#
       ylim = c(0, 1.02),#
       main = sprintf("n=%d, α=%.3f", n, alpha))#
  step_cdf_plot(fb_res$LR, fb_res$prob,  col = "blue",  lty = 1)#
  step_cdf_plot(mc_res$LR, mc_res$prob,  col = "green", lty = 2)#
#
  x_max <- max(c(fb_res$LR, mc_res$LR, 10))#
  x_chi <- seq(0, x_max + 0.2, length.out = 300)#
  lines(x_chi, pchisq(x_chi, df = 1), col = "red")#
  legend("bottomright",#
         legend = c("True (DP)", "Empirical (MC)", "χ²(1)"),#
         lty = c(1, 2, 1), col = c("blue", "green", "red"),#
         bty = "n", cex = 0.8)#
}#
#
# ---------- main routine ----------#
main <- function(file = "LRind_cdf_grid.pdf") {#
  set.seed(42)#
  alpha_list <- c(0.01, 0.05, 0.10)#
  n_list     <- c(15, 100, 500)#
  prune_threshold <- 1e-15#
  Nrep <- 20000#
#
  # 打开一个图形设备，可改为 png() / svg() 等#
  pdf(file, width = 8, height = 8)#
  par(mfrow = c(3, 3), mar = c(3.5, 3.5, 2.5, 1), cex.axis = 0.9, cex.lab = 0.9)#
#
  for (alpha_ in alpha_list) {#
    for (n_ in n_list) {#
      fb_res <- fb_lrind(n_, alpha_, prune_threshold)#
      mc_res <- mc_lrind(n_, alpha_, Nrep)#
      plot_three_distributions(n_, alpha_, fb_res, mc_res)#
    }#
  }#
#
  dev.off()#
  message("Saved 3×3 CDF grid to: ", file)#
}#
#
main()   # 运行后将生成 LRind_cdf_grid.pdf
mc_lrind <- function(n, alpha = 0.05, Nrep = 20000) {#
  LR_values <- numeric(Nrep)#
  for (i in seq_len(Nrep)) {#
    path <- rbinom(n, 1, alpha)#
    T00 <- T01 <- T10 <- T11 <- 0#
    for (t in 2:n) {#
      if (path[t - 1] == 0 && path[t] == 0)       T00 <- T00 + 1#
      else if (path[t - 1] == 0 && path[t] == 1)  T01 <- T01 + 1#
      else if (path[t - 1] == 1 && path[t] == 0)  T10 <- T10 + 1#
      else                                        T11 <- T11 + 1#
    }#
    T0   <- T00 + T10#
    T1   <- T01 + T11#
    pHat <- if (n > 1) T1 / (n - 1) else 0#
#
    num   <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
    pi01  <- if ((T00 + T01) > 0) T01 / (T00 + T01) else 1#
    pi11  <- if ((T10 + T11) > 0) T11 / (T10 + T11) else 1#
    den   <- T00 * safe_log(1 - pi01) + T01 * safe_log(pi01) +#
             T10 * safe_log(1 - pi11) + T11 * safe_log(pi11)#
#
    LR_values[i] <- -2 * (num - den)#
  }#
#
  arr      <- sort(LR_values)#
  idx_diff <- which(diff(arr) > 0)#
  uniq_idx <- c(idx_diff, length(arr))#
  LRuniq   <- arr[uniq_idx]#
  prob_    <- diff(c(0, uniq_idx)) / Nrep#
  list(LR = LRuniq, prob = prob_)#
}#
#
step_cdf_plot <- function(LRvals, probs, col = "blue", lty = 1) {#
  cdf <- cumsum(probs)#
  x   <- c(0, LRvals)#
  y   <- c(0, cdf)#
  lines(x, y, type = "s", col = col, lty = lty)#
  points(x, y, pch = 16, cex = 0.5, col = col)#
}#
#
plot_three_distributions <- function(n, alpha, fb_res, mc_res) {#
  plot(0, 0, type = "n",#
       xlab = "LR value", ylab = "CDF",#
       xlim = c(0, max(c(fb_res$LR, mc_res$LR, 10))),#
       ylim = c(0, 1.02),#
       main = sprintf("Ind Test CDF\nn=%d, alpha=%.3f", n, alpha))#
  step_cdf_plot(fb_res$LR, fb_res$prob,  col = "blue",  lty = 1)#
  step_cdf_plot(mc_res$LR, mc_res$prob,  col = "green", lty = 2)#
  x_max <- max(c(fb_res$LR, mc_res$LR, 10))#
  x_chi <- seq(0, x_max + 0.2, length.out = 300)#
  y_chi <- pchisq(x_chi, df = 1)#
  lines(x_chi, y_chi, col = "red")#
  legend("bottomright",#
         legend = c("True(FB)", "Empirical(MC)", "Chi2(1)"),#
         lty = c(1, 2, 1), col = c("blue", "green", "red"), bty = "n")#
}#
#
main <- function() {#
  set.seed(42)#
  alpha_list <- c(0.01, 0.05, 0.10)#
  n_list     <- c(15, 100, 500)#
  prune_threshold <- 1e-15#
  Nrep <- 20000#
  cat("   n     alpha   #distinct_LR    sum(prob)       time(s)\n")#
  for (alpha_ in alpha_list) {#
    for (n_ in n_list) {#
      t0      <- proc.time()#
      fb_res  <- fb_lrind(n_, alpha_, prune_threshold)#
      elapsed <- proc.time() - t0#
      cat(sprintf("%5d  %7.3f  %12d  %10.8f  %10.4f\n",#
                  n_, alpha_, length(fb_res$LR), sum(fb_res$prob), elapsed["elapsed"]))#
#
      mc_res <- mc_lrind(n_, alpha_, Nrep)#
#
      dev.new(width = 5.5, height = 4)#
      plot_three_distributions(n_, alpha_, fb_res, mc_res)#
    }#
  }#
  cat("\nDone. Generated 9 figures (3 values of alpha x 3 values of n).\n")#
}#
main()
cdf_xy <- function(LRvals, probvals) {#
  list(x = c(0, LRvals), y = c(0, cumsum(probvals)))#
}#
#
cdf_val <- function(x, xx, yy) {#
  idx <- findInterval(x, xx, rightmost.closed = TRUE)#
  yy[pmax.int(idx, 1L)]#
}#
#
cdf_diff <- function(LRvals, probvals, df = 1) {#
  if (!length(LRvals)) return(0)#
  ord <- order(LRvals)#
  cxy <- cdf_xy(LRvals[ord], probvals[ord])#
  xmax <- tail(cxy$x, 1) + 1#
  xs   <- seq(0, xmax, length.out = 600)#
  max(abs(cdf_val(xs, cxy$x, cxy$y) - pchisq(xs, df)))#
}#
#
main <- function() {#
  n <- 500#
  alpha_list <- c(0.01, 0.025, 0.05)#
  thresholds  <- c(1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10)#
  cat("n=500\n")#
  cat(" alpha    prune_threshold     #distinct_LR     sum(prob)     KS_distance\n")#
#
  results_df <- data.frame(alpha = numeric(),#
                           threshold = numeric(),#
                           distinct_LR = integer(),#
                           sumprob = numeric(),#
                           ks = numeric())#
#
  for (a_ in alpha_list) {#
    for (th in thresholds) {#
      dist_ <- fb_lrind(n, a_, th)#
      ks_   <- cdf_diff(dist_$LR, dist_$prob, 1)#
      cat(sprintf(" %6.3f   %-12g   %12d   %10.8f   %9.6f\n",#
                  a_, th, length(dist_$LR), sum(dist_$prob), ks_))#
      results_df <- rbind(results_df,#
                          data.frame(alpha = a_, threshold = th,#
                                     distinct_LR = length(dist_$LR),#
                                     sumprob = sum(dist_$prob), ks = ks_))#
    }#
    cat("\n")#
  }#
#
  plot(NULL, xlim = range(thresholds), ylim = c(0, 1), log = "x",#
       xlab = "prune_threshold", ylab = "KS distance",#
       main = "KS distance vs prune_threshold (n=500)")#
  clrs <- c("blue", "red", "green")#
  i <- 1#
  for (a_ in alpha_list) {#
    subdf <- subset(results_df, alpha == a_)#
    lines(subdf$threshold, subdf$ks, col = clrs[i], type = "b",#
          pch = 19, lwd = 2)#
    i <- i + 1#
  }#
  legend("topright", legend = paste0("alpha=", alpha_list),#
         col = clrs, pch = 19, lwd = 2)#
}#
#
main()
cdf_xy <- function(LRvals, probvals) {#
  list(x = c(0, LRvals), y = c(0, cumsum(probvals)))#
}#
#
cdf_val <- function(x, xx, yy) {#
  idx <- findInterval(x, xx, rightmost.closed = TRUE)#
  yy[pmax.int(idx, 1L)]#
}#
#
cdf_diff <- function(LRvals, probvals, df = 1) {#
  if (!length(LRvals)) return(0)#
  ord <- order(LRvals)#
  cxy <- cdf_xy(LRvals[ord], probvals[ord])#
  xm  <- tail(cxy$x, 1) + 1#
  xs  <- seq(0, xm, length.out = 600)#
  max(abs(cdf_val(xs, cxy$x, cxy$y) - pchisq(xs, df)))#
}#
#
main <- function() {#
  n_list      <- c(250, 500, 1000)#
  alpha_vals  <- seq(0.01, 0.1, length.out = 21)#
  curves <- lapply(n_list, function(n_) {#
    sapply(alpha_vals, function(alpha_) {#
      dist_ <- fb_lrind(n_, alpha_, 1e-15)#
      cdf_diff(dist_$LR, dist_$prob, 1)#
    })#
  })#
#
  plot(NA, NA, type = "n", xlim = range(alpha_vals), ylim = c(0, 1),#
       xlab = "alpha", ylab = "KS distance",#
       main = "KS distance vs alpha")#
  cols <- c("blue", "red", "green")#
  for (i in seq_along(n_list)) {#
    lines(alpha_vals, curves[[i]], col = cols[i], lwd = 2)#
  }#
  legend("topright", legend = paste("n=", n_list), col = cols, lty = 1, lwd = 2)#
}#
main()
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log(x < EPS ? EPS : x); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct LLHash{ std::size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
#
static inline long long ENC(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL, s3=s2*(n+1), s4=s3*(n+1), s5=s4*(n+1);#
  return l + s2*a + s3*b + s4*c + s5*d;#
}#
#
[[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05){#
  State s0{0,0,0,0,0,1.0-alpha}, s1{1,0,0,0,0,alpha};#
  return List::create(_["last"]={s0.last,s1.last},#
                      _["s00"] ={s0.s00,s1.s00},#
                      _["s10"] ={s0.s10,s1.s10},#
                      _["s01"] ={s0.s01,s1.s01},#
                      _["s11"] ={s0.s11,s1.s11},#
                      _["prob"]={s0.prob,s1.prob});#
}#
#
[[Rcpp::export]]#
List step_forward_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<long long,State,LLHash> mp;#
  mp.reserve(l.size()*2);#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    State st{l[i],a[i],b[i],c[i],d[i],p[i]};#
    State t=st; if(t.last==0) t.s00++; else t.s10++; t.last=0; t.prob*=1.0-alpha;#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob+=t.prob;#
    t=st; if(t.last==0) t.s01++; else t.s11++; t.last=1; t.prob*=alpha;#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob+=t.prob;#
  }#
  int m=mp.size();#
  IntegerVector L(m),A(m),B(m),C(m),D(m); NumericVector P(m);#
  int idx=0;#
  for(auto &kv:mp){#
    if(kv.second.prob<th) continue;#
    L[idx]=kv.second.last; A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;  D[idx]=kv.second.s11; P[idx]=kv.second.prob; idx++;#
  }#
  L.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
[[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
  for(int i=0;i<l.size();i++){#
    if(p[i]==0.0) continue;#
    int x00=a[i],x10=b[i],x01=c[i],x11=d[i];#
    int T0=x00+x10, T1=x01+x11;#
    double ph=(t>1)?(double)T1/(t-1):0.0;#
    double num=T0*safe_log(1.0-ph)+T1*safe_log(ph);#
    int s01=x00+x01,s11=x10+x11;#
    double pi01=(s01>0)?(double)x01/s01:1.0;#
    double pi11=(s11>0)?(double)x11/s11:1.0;#
    double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+#
               x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
    mp[-2.0*(num-den)]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0;#
    while(i<v.size()&&std::fabs(v[i].first-cur)<1e-15){sum+=v[i].second;i++;}#
    LR.push_back(cur);Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
cdf_xy  <- function(LR, pr){#
  o  <- order(LR)#
  x0 <- c(LR[o], 0)#
  y0 <- c(cumsum(pr[o]), 0)#
  o2 <- order(x0)#
  list(x = x0[o2], y = y0[o2])#
}#
cdf_val <- function(x, xs, ys) ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
ks_diff <- function(LR, pr, df = 1){#
  if(!length(LR)) return(0)#
  d  <- cdf_xy(LR, pr)#
  xs <- seq(0, tail(d$x,1)+1, length.out = 800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
main <- function(){#
  alpha <- c(0.01,0.025,0.05); cols <- c("red","blue","green")#
  nmax <- 2000; plot(NULL,xlim=c(1,nmax),ylim=c(0,1),xlab="n",ylab="KS distance",main="KS distance vs n")#
  for(i in seq_along(alpha)){#
    dist <- initialize_dist_fastcpp(alpha[i])#
    nvals <- 1:nmax; ks <- numeric(nmax)#
    for(t in nvals){#
      res <- dist_at_current_fastcpp(dist,t); ks[t] <- ks_diff(res$LR,res$prob,1)#
      if(t<nmax) dist <- step_forward_fastcpp(dist,alpha[i],1e-15,nmax)#
    }#
    lines(nvals,ks,col=cols[i],lwd=2)#
  }#
  legend("topright",legend=paste0("alpha=",alpha),col=cols,lty=1,lwd=2)#
}#
main()
library(Rcpp)#
library(stats)#
#
# ---------- C++ functions ----------#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log(x < EPS ? EPS : x); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct LLHash{ std::size_t operator()(long long x) const { return std::hash<long long>()(x);}};#
#
static inline long long ENC(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL, s3=s2*(n+1), s4=s3*(n+1), s5=s4*(n+1);#
  return l + s2*a + s3*b + s4*c + s5*d;#
}#
#
// initial distribution#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05){#
  State s0{0,0,0,0,0,1.0-alpha}, s1{1,0,0,0,0,alpha};#
  return List::create(_["last"]={s0.last,s1.last},#
                      _["s00"] ={s0.s00,s1.s00},#
                      _["s10"] ={s0.s10,s1.s10},#
                      _["s01"] ={s0.s01,s1.s01},#
                      _["s11"] ={s0.s11,s1.s11},#
                      _["prob"]={s0.prob,s1.prob});#
}#
#
// one-step forward#
// [[Rcpp::export]]#
List step_forward_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<long long,State,LLHash> mp; mp.reserve(l.size()*2);#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    State st{l[i],a[i],b[i],c[i],d[i],p[i]};#
#
    // hit = 0#
    State t=st;#
    if(t.last==0) t.s00++; else t.s10++;#
    t.last=0; t.prob *= (1.0-alpha);#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob += t.prob;#
#
    // hit = 1#
    t=st;#
    if(t.last==0) t.s01++; else t.s11++;#
    t.last=1; t.prob *= alpha;#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob += t.prob;#
  }#
#
  // pack back to R list#
  int m = mp.size();#
  IntegerVector L(m),A(m),B(m),C(m),D(m); NumericVector P(m);#
  int idx=0;#
  for(auto &kv: mp){#
    if(kv.second.prob < th) continue;#
    L[idx]=kv.second.last;  A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;   D[idx]=kv.second.s11; P[idx]=kv.second.prob;#
    ++idx;#
  }#
  L.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
// distribution at step t#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]==0.0) continue;#
    int x00=a[i],x10=b[i],x01=c[i],x11=d[i];#
    int T0=x00+x10, T1=x01+x11;#
    double ph=(t>1)?(double)T1/(t-1):0.0;#
    double num=T0*safe_log(1.0-ph)+T1*safe_log(ph);#
#
    int s01=x00+x01, s11=x10+x11;#
    double pi01=(s01>0)?(double)x01/s01:1.0;#
    double pi11=(s11>0)?(double)x11/s11:1.0;#
    double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+#
               x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
#
    mp[-2.0*(num-den)] += p[i];#
  }#
#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first, sum=0.0;#
    while(i<v.size() && fabs(v[i].first-cur)<1e-15){ sum+=v[i].second; ++i; }#
    LR.push_back(cur); Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
# ---------- R helper for KS distance ----------#
cdf_xy <- function(LR, pr){#
  o <- order(LR)#
  x <- c(0, LR[o]);  y <- c(0, cumsum(pr[o]))#
  list(x = x, y = y)#
}#
cdf_val <- function(x, xs, ys){#
  ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
}#
ks_diff <- function(LR, pr, df=1){#
  if(!length(LR)) return(0)#
  d <- cdf_xy(LR, pr)#
  xs <- seq(0, tail(d$x,1)+1, length.out=800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
# ---------- main ----------#
main <- function(){#
  alpha_vec <- c(0.01, 0.025, 0.05)#
  cols <- c("red","blue","green")#
  nmax <- 2000#
#
  plot(NULL, xlim=c(1,nmax), ylim=c(0,1),#
       xlab="n", ylab="KS distance", main="KS distance vs n")#
#
  for(i in seq_along(alpha_vec)){#
    a <- alpha_vec[i]#
    dist <- initialize_dist_fastcpp(a)#
    ks <- numeric(nmax)#
#
    for(t in 1:nmax){#
      res <- dist_at_current_fastcpp(dist, t)#
      ks[t] <- ks_diff(res$LR, res$prob, 1)#
      if(t < nmax) dist <- step_forward_fastcpp(dist, a, 1e-15, nmax)#
    }#
#
    lines(1:nmax, ks, col=cols[i], lwd=2)#
  }#
  legend("topright", legend=paste0("alpha=", alpha_vec),#
         col=cols, lty=1, lwd=2)#
}#
#
main()
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log(x < EPS ? EPS : x); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct LLHash{ std::size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
#
static inline long long ENC(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL, s3=s2*(n+1), s4=s3*(n+1), s5=s4*(n+1);#
  return l + s2*a + s3*b + s4*c + s5*d;#
}#
#
[[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05){#
  State s0{0,0,0,0,0,1.0-alpha}, s1{1,0,0,0,0,alpha};#
  return List::create(_["last"]={s0.last,s1.last},#
                      _["s00"] ={s0.s00,s1.s00},#
                      _["s10"] ={s0.s10,s1.s10},#
                      _["s01"] ={s0.s01,s1.s01},#
                      _["s11"] ={s0.s11,s1.s11},#
                      _["prob"]={s0.prob,s1.prob});#
}#
#
[[Rcpp::export]]#
List step_forward_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<long long,State,LLHash> mp;#
  mp.reserve(l.size()*2);#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    State st{l[i],a[i],b[i],c[i],d[i],p[i]};#
    State t=st; if(t.last==0) t.s00++; else t.s10++; t.last=0; t.prob*=1.0-alpha;#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob+=t.prob;#
    t=st; if(t.last==0) t.s01++; else t.s11++; t.last=1; t.prob*=alpha;#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob+=t.prob;#
  }#
  int m=mp.size();#
  IntegerVector L(m),A(m),B(m),C(m),D(m); NumericVector P(m);#
  int idx=0;#
  for(auto &kv:mp){#
    if(kv.second.prob<th) continue;#
    L[idx]=kv.second.last; A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;  D[idx]=kv.second.s11; P[idx]=kv.second.prob; idx++;#
  }#
  L.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
[[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
  for(int i=0;i<l.size();i++){#
    if(p[i]==0.0) continue;#
    int x00=a[i],x10=b[i],x01=c[i],x11=d[i];#
    int T0=x00+x10, T1=x01+x11;#
    double ph=(t>1)?(double)T1/(t-1):0.0;#
    double num=T0*safe_log(1.0-ph)+T1*safe_log(ph);#
    int s01=x00+x01,s11=x10+x11;#
    double pi01=(s01>0)?(double)x01/s01:1.0;#
    double pi11=(s11>0)?(double)x11/s11:1.0;#
    double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+#
               x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
    mp[-2.0*(num-den)]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0;#
    while(i<v.size()&&std::fabs(v[i].first-cur)<1e-15){sum+=v[i].second;i++;}#
    LR.push_back(cur);Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
cdf_xy  <- function(LR, pr){#
  o  <- order(LR)#
  x0 <- c(LR[o], 0)#
  y0 <- c(cumsum(pr[o]), 0)#
  o2 <- order(x0)#
  list(x = x0[o2], y = y0[o2])#
}#
cdf_val <- function(x, xs, ys) ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
ks_diff <- function(LR, pr, df = 1){#
  if(!length(LR)) return(0)#
  d  <- cdf_xy(LR, pr)#
  xs <- seq(0, tail(d$x,1)+1, length.out = 800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
main <- function(){#
  alpha <- c(0.01,0.025,0.05); cols <- c("red","blue","green")#
  nmax <- 2000; plot(NULL,xlim=c(1,nmax),ylim=c(0,1),xlab="n",ylab="KS distance",main="KS distance vs n")#
  for(i in seq_along(alpha)){#
    dist <- initialize_dist_fastcpp(alpha[i])#
    nvals <- 1:nmax; ks <- numeric(nmax)#
    for(t in nvals){#
      res <- dist_at_current_fastcpp(dist,t); ks[t] <- ks_diff(res$LR,res$prob,1)#
      if(t<nmax) dist <- step_forward_fastcpp(dist,alpha[i],1e-15,nmax)#
    }#
    lines(nvals,ks,col=cols[i],lwd=2)#
  }#
  legend("topright",legend=paste0("alpha=",alpha),col=cols,lty=1,lwd=2)#
}#
main()
library(Rcpp)#
library(stats)#
#
# ---------- C++ functions ----------#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log(x < EPS ? EPS : x); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct LLHash{ std::size_t operator()(long long x) const { return std::hash<long long>()(x);}};#
#
static inline long long ENC(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL, s3=s2*(n+1), s4=s3*(n+1), s5=s4*(n+1);#
  return l + s2*a + s3*b + s4*c + s5*d;#
}#
#
// initial distribution#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05){#
  State s0{0,0,0,0,0,1.0-alpha}, s1{1,0,0,0,0,alpha};#
  return List::create(_["last"]={s0.last,s1.last},#
                      _["s00"] ={s0.s00,s1.s00},#
                      _["s10"] ={s0.s10,s1.s10},#
                      _["s01"] ={s0.s01,s1.s01},#
                      _["s11"] ={s0.s11,s1.s11},#
                      _["prob"]={s0.prob,s1.prob});#
}#
#
// one-step forward#
// [[Rcpp::export]]#
List step_forward_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<long long,State,LLHash> mp; mp.reserve(l.size()*2);#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    State st{l[i],a[i],b[i],c[i],d[i],p[i]};#
#
    // hit = 0#
    State t=st;#
    if(t.last==0) t.s00++; else t.s10++;#
    t.last=0; t.prob *= (1.0-alpha);#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob += t.prob;#
#
    // hit = 1#
    t=st;#
    if(t.last==0) t.s01++; else t.s11++;#
    t.last=1; t.prob *= alpha;#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob += t.prob;#
  }#
#
  // pack back to R list#
  int m = mp.size();#
  IntegerVector L(m),A(m),B(m),C(m),D(m); NumericVector P(m);#
  int idx=0;#
  for(auto &kv: mp){#
    if(kv.second.prob < th) continue;#
    L[idx]=kv.second.last;  A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;   D[idx]=kv.second.s11; P[idx]=kv.second.prob;#
    ++idx;#
  }#
  L.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
// distribution at step t#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]==0.0) continue;#
    int x00=a[i],x10=b[i],x01=c[i],x11=d[i];#
    int T0=x00+x10, T1=x01+x11;#
    double ph=(t>1)?(double)T1/(t-1):0.0;#
    double num=T0*safe_log(1.0-ph)+T1*safe_log(ph);#
#
    int s01=x00+x01, s11=x10+x11;#
    double pi01=(s01>0)?(double)x01/s01:1.0;#
    double pi11=(s11>0)?(double)x11/s11:1.0;#
    double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+#
               x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
#
    mp[-2.0*(num-den)] += p[i];#
  }#
#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first, sum=0.0;#
    while(i<v.size() && fabs(v[i].first-cur)<1e-15){ sum+=v[i].second; ++i; }#
    LR.push_back(cur); Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
# ---------- R helper for KS distance ----------#
cdf_xy <- function(LR, pr){#
  o <- order(LR)#
  x <- c(0, LR[o]);  y <- c(0, cumsum(pr[o]))#
  list(x = x, y = y)#
}#
cdf_val <- function(x, xs, ys){#
  ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
}#
ks_diff <- function(LR, pr, df=1){#
  if(!length(LR)) return(0)#
  d <- cdf_xy(LR, pr)#
  xs <- seq(0, tail(d$x,1)+1, length.out=800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
# ---------- main ----------#
main <- function(){#
  alpha_vec <- c(0.01, 0.025, 0.05)#
  cols <- c("red","blue","green")#
  nmax <- 2000#
#
  plot(NULL, xlim=c(1,nmax), ylim=c(0,1),#
       xlab="n", ylab="KS distance", main="KS distance vs n")#
#
  for(i in seq_along(alpha_vec)){#
    a <- alpha_vec[i]#
    dist <- initialize_dist_fastcpp(a)#
    ks <- numeric(nmax)#
#
    for(t in 1:nmax){#
      res <- dist_at_current_fastcpp(dist, t)#
      ks[t] <- ks_diff(res$LR, res$prob, 1)#
      if(t < nmax) dist <- step_forward_fastcpp(dist, a, 1e-15, nmax)#
    }#
#
    lines(1:nmax, ks, col=cols[i], lwd=2)#
  }#
  legend("topright", legend=paste0("alpha=", alpha_vec),#
         col=cols, lty=1, lwd=2)#
}#
#
main()
exists("initialize_dist_fastcpp")#
exists("step_forward_fastcpp")
library(Rcpp)#
#
## 如遇 “C++17/14 not supported” 之类信息，再加一行：#
Rcpp::plugins(cpp11)     # 或 cpp14
cppFunction('int add(int x, int y){ return x + y; }')#
add(2, 3)    # ➜ 若返回 5，则说明 R 能调用 C++ 编译器
exists("initialize_dist_fastcpp")   # TRUE#
exists("step_forward_fastcpp")      # TRUE
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct CCState { int last,c1,s00,s10,s01,s11; double prob; };#
struct LLHash  { std::size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long ENC(int l,int c1,int a,int b,int c,int d,int n){#
  long long step=(long long)n+10, s2=step,s3=s2*step,s4=s3*step,s5=s4*step,s6=s5*step;#
  return l + s2*c1 + s3*a + s4*b + s5*c + s6*d;#
}#
#
[[Rcpp::export]]#
List initialize_cc_fastcpp(double alpha=0.05){#
  CCState s0{0,0,0,0,0,0,1.0-alpha}, s1{1,1,0,0,0,0,alpha};#
  return List::create(_["last"]={s0.last,s1.last},#
                      _["c1"]  ={s0.c1 ,s1.c1 },#
                      _["s00"] ={s0.s00,s1.s00},#
                      _["s10"] ={s0.s10,s1.s10},#
                      _["s01"] ={s0.s01,s1.s01},#
                      _["s11"] ={s0.s11,s1.s11},#
                      _["prob"]={s0.prob,s1.prob});#
}#
#
[[Rcpp::export]]#
List step_forward_cc_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"], c1=cur["c1"], a=cur["s00"], b=cur["s10"],#
                c=cur["s01"], d=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<long long,CCState,LLHash> mp; mp.reserve(l.size()*2);#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    CCState st{l[i],c1[i],a[i],b[i],c[i],d[i],p[i]};#
    { CCState ns=st; (ns.last==0?ns.s00:ns.s10)++; ns.last=0; ns.prob*=1.0-alpha;#
      mp[ENC(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax)].prob+=ns.prob; }#
    { CCState ns=st; (ns.last==0?ns.s01:ns.s11)++; ns.c1++; ns.last=1; ns.prob*=alpha;#
      mp[ENC(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax)].prob+=ns.prob; }#
  }#
  int m=mp.size();#
  IntegerVector L(m),C1(m),A(m),B(m),C(m),D(m); NumericVector P(m); int idx=0;#
  for(auto &kv:mp){#
    if(kv.second.prob<th) continue;#
    L[idx]=kv.second.last; C1[idx]=kv.second.c1; A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;  D[idx]=kv.second.s11; P[idx]=kv.second.prob; idx++;#
  }#
  L.resize(idx);C1.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["c1"]=C1,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
[[Rcpp::export]]#
List dist_cc_at_current_fastcpp(List cur,int t,double alpha=0.05){#
  IntegerVector l=cur["last"], c1=cur["c1"], a=cur["s00"], b=cur["s10"],#
                c=cur["s01"], d=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<=0.0) continue;#
    int n1=c1[i], x00=a[i], x10=b[i], x01=c[i], x11=d[i];#
    double phat=(n1==0)?0.0:((n1==t)?1.0:(double)n1/t);#
    double p_  = std::max(std::min(alpha,1.0-EPS),EPS);#
    double ph_ = std::max(std::min(phat ,1.0-EPS),EPS);#
    double lruc=-2.0*( n1*safe_log(p_) + (t-n1)*safe_log(1.0-p_)#
                     - n1*safe_log(ph_) - (t-n1)*safe_log(1.0-ph_) );#
    double lrind=0.0;#
    if(t>1){#
      int T0=x00+x10, T1=x01+x11;#
      double pH=(double)T1/(t-1);#
      double num=T0*safe_log(1.0-pH)+T1*safe_log(pH);#
      int s01_=x00+x01, s11_=x10+x11;#
      double pi01=(s01_>0)?(double)x01/s01_:1.0;#
      double pi11=(s11_>0)?(double)x11/s11_:1.0;#
      double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+#
                 x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
      lrind=-2.0*(num - den);#
    }#
    mp[lruc+lrind]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0;#
    while(i<v.size() && std::fabs(v[i].first-cur)<1e-15){ sum+=v[i].second; i++; }#
    LR.push_back(cur); Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  o  <- order(LRvals)#
  x0 <- c(LRvals[o], 0)#
  y0 <- c(cumsum(probvals[o]), 0)#
  o2 <- order(x0)#
  list(x = x0[o2], y = y0[o2])#
}#
#
cdf_val <- function(x, xs, ys){#
  ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
}#
#
ks_diff <- function(LRvals, probvals, df = 2){#
  if(!length(LRvals)) return(0)#
  d   <- cdf_xy(LRvals, probvals)#
  xs  <- seq(0, tail(d$x,1)+1, length.out = 800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
main_cc <- function(){#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax <- 2000#
  plot(NA, xlim=c(1, nmax), ylim=c(0,1), xlab="n", ylab="KS distance",#
       main="CDF difference (LRcc vs Chi2) vs n")#
  cols <- c("red","blue","green"); i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_cc_fastcpp(a)#
    ksvals <- numeric(nmax)#
    for(t in 1:nmax){#
      res <- dist_cc_at_current_fastcpp(dist_k, t, a)#
      ksvals[t] <- ks_diff(res$LR, res$prob, 2)#
      if(t < nmax) dist_k <- step_forward_cc_fastcpp(dist_k, a, 1e-15, nmax)#
    }#
    lines(1:nmax, ksvals, col=cols[i], lwd=2); i <- i + 1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list),#
         col=cols, lty=1, lwd=2, bty="n")#
}#
#
main_cc()
library(Rcpp)#
library(stats)#
#
# ---------- C++ 部分 ----------#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log(x < EPS ? EPS : x); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct LLHash{ std::size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
#
static inline long long ENC(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL, s3=s2*(n+1), s4=s3*(n+1), s5=s4*(n+1);#
  return l + s2*a + s3*b + s4*c + s5*d;#
}#
#
// ---------- 1) 初始分布 ----------#
[[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05){#
  State s0{0,0,0,0,0,1.0-alpha}, s1{1,0,0,0,0,alpha};#
  return List::create(_["last"] ={s0.last ,s1.last},#
                      _["s00"]  ={s0.s00  ,s1.s00 },#
                      _["s10"]  ={s0.s10  ,s1.s10 },#
                      _["s01"]  ={s0.s01  ,s1.s01 },#
                      _["s11"]  ={s0.s11  ,s1.s11 },#
                      _["prob"] ={s0.prob ,s1.prob});#
}#
#
// ---------- 2) 单步前推（修正后的合并逻辑） ----------#
[[Rcpp::export]]#
List step_forward_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"], a=cur["s00"], b=cur["s10"], c=cur["s01"], d=cur["s11"];#
  NumericVector p=cur["prob"];#
#
  std::unordered_map<long long,State,LLHash> mp;#
  mp.reserve(l.size()*2);#
#
  for(int i=0;i<l.size();i++){#
    if(p[i] < th) continue;#
    State st{l[i],a[i],b[i],c[i],d[i],p[i]};#
#
    // ---- (hit = 0) ----#
    State t = st;#
    if(t.last==0) t.s00++; else t.s10++;#
    t.last = 0; t.prob *= (1.0-alpha);#
    long long key = ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax);#
    auto it = mp.find(key);#
    if(it == mp.end()){#
      mp[key] = t;                   // 首次出现：整条 State 存进去#
    } else {#
      it->second.prob += t.prob;     // 已有：仅累加 probability#
    }#
#
    // ---- (hit = 1) ----#
    t = st;#
    if(t.last==0) t.s01++; else t.s11++;#
    t.last = 1; t.prob *= alpha;#
    key = ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax);#
    it = mp.find(key);#
    if(it == mp.end()){#
      mp[key] = t;#
    } else {#
      it->second.prob += t.prob;#
    }#
  }#
#
  // 打包回 R list#
  int m = mp.size();#
  IntegerVector L(m),A(m),B(m),C(m),D(m); NumericVector P(m);#
  int idx=0;#
  for(auto &kv : mp){#
    if(kv.second.prob < th) continue;#
    L[idx]=kv.second.last; A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;  D[idx]=kv.second.s11; P[idx]=kv.second.prob;#
    ++idx;#
  }#
  L.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
// ---------- 3) 给定 t 的 LR 分布 ----------#
[[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]==0.0) continue;#
    int x00=a[i],x10=b[i],x01=c[i],x11=d[i];#
    int T0=x00+x10, T1=x01+x11;#
    double ph=(t>1)?(double)T1/(t-1):0.0;#
    double num=T0*safe_log(1.0-ph)+T1*safe_log(ph);#
#
    int s01=x00+x01,s11=x10+x11;#
    double pi01=(s01>0)?(double)x01/s01:1.0;#
    double pi11=(s11>0)?(double)x11/s11:1.0;#
    double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+#
               x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
#
    mp[-2.0*(num-den)] += p[i];#
  }#
#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto &a,auto &b){return a.first<b.first;});#
#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0.0;#
    while(i<v.size() && std::fabs(v[i].first-cur)<1e-15){ sum+=v[i].second; ++i; }#
    LR.push_back(cur); Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
# ---------- R 辅助函数 ----------#
cdf_xy <- function(LR, pr){#
  o  <- order(LR)#
  list(x = c(0, LR[o]), y = c(0, cumsum(pr[o])))#
}#
cdf_val <- function(x, xs, ys){#
  ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
}#
ks_diff <- function(LR, pr, df = 1){#
  if(!length(LR)) return(0)#
  d <- cdf_xy(LR, pr)#
  xs <- seq(0, tail(d$x,1)+1, length.out = 800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
# ---------- main ----------#
main <- function(){#
  alpha <- c(0.01,0.025,0.05)#
  cols  <- c("red","blue","green")#
  nmax  <- 2000#
#
  plot(NULL, xlim=c(1,nmax), ylim=c(0,1),#
       xlab="n", ylab="KS distance", main="KS distance vs n")#
#
  for(i in seq_along(alpha)){#
    dist <- initialize_dist_fastcpp(alpha[i])#
    ks <- numeric(nmax)#
#
    for(t in 1:nmax){#
      res <- dist_at_current_fastcpp(dist, t)#
      ks[t] <- ks_diff(res$LR, res$prob, 1)#
      if(t < nmax) dist <- step_forward_fastcpp(dist, alpha[i], 1e-15, nmax)#
    }#
    lines(1:nmax, ks, col=cols[i], lwd=2)#
  }#
  legend("topright", legend=paste0("alpha=", alpha),#
         col=cols, lty=1, lwd=2)#
}#
#
main()
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
struct State {#
  int last;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_state(int last, int s00, int s10, int s01, int s11, int nmax){#
  long long SHIFT2 = 2LL;#
  long long SHIFT3 = SHIFT2*(nmax+1);#
  long long SHIFT4 = SHIFT3*(nmax+1);#
  long long SHIFT5 = SHIFT4*(nmax+1);#
  return (long long)last#
       + SHIFT2*(long long)s00#
       + SHIFT3*(long long)s10#
       + SHIFT4*(long long)s01#
       + SHIFT5*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05) {#
  State s0; s0.last=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0-alpha;#
  State s1; s1.last=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
  IntegerVector vl(2), vs00(2), vs10(2), vs01(2), vs11(2);#
  NumericVector vp(2);#
  vl[0]=s0.last; vs00[0]=s0.s00; vs10[0]=s0.s10; vs01[0]=s0.s01; vs11[0]=s0.s11; vp[0]=s0.prob;#
  vl[1]=s1.last; vs00[1]=s1.s00; vs10[1]=s1.s10; vs01[1]=s1.s01; vs11[1]=s1.s11; vp[1]=s1.prob;#
  return List::create(Named("last")=vl, Named("s00")=vs00, Named("s10")=vs10,#
                      Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_fastcpp(List curDist, double alpha=0.05, double prune_threshold=1e-15, int nmax=2000) {#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<long long, State, LLHash> newMap;#
  newMap.reserve(last.size()*2);#
  for(int i=0;i<last.size();i++){#
    double p=prob[i];#
    if(p<prune_threshold) continue;#
    State st; st.last=last[i]; st.s00=s00[i]; st.s10=s10[i]; st.s01=s01[i]; st.s11=s11[i]; st.prob=p;#
    {#
      State ns=st;#
      if(ns.last==0) ns.s00++; else ns.s10++;#
      ns.last=0; ns.prob=p*(1.0-alpha);#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=newMap.find(code);#
      if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
    }#
    {#
      State ns=st;#
      if(ns.last==0) ns.s01++; else ns.s11++;#
      ns.last=1; ns.prob=p*alpha;#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=newMap.find(code);#
      if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
    }#
  }#
  std::vector<State> vec; vec.reserve(newMap.size());#
  for(auto &kv:newMap){#
    if(kv.second.prob>=prune_threshold) vec.push_back(kv.second);#
  }#
  int sz=vec.size();#
  IntegerVector vl(sz), vs00(sz), vs10(sz), vs01(sz), vs11(sz);#
  NumericVector vp(sz);#
  for(int i=0;i<sz;i++){#
    vl[i]=vec[i].last; vs00[i]=vec[i].s00; vs10[i]=vec[i].s10;#
    vs01[i]=vec[i].s01; vs11[i]=vec[i].s11; vp[i]=vec[i].prob;#
  }#
  return List::create(Named("last")=vl, Named("s00")=vs00, Named("s10")=vs10,#
                      Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List curDist, int t) {#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<double,double> dmap;#
  dmap.reserve(last.size());#
  for(int i=0;i<last.size();i++){#
    double p=prob[i];#
    if(p<=0.0) continue;#
    int x00=s00[i], x10=s10[i], x01=s01[i], x11=s11[i];#
    int T0=x00+x10, T1=x01+x11;#
    double pHat=(t>1)?((double)T1/(double)(t-1)):0.0;#
    double num=0.0; #
    if(1.0-pHat>0.0) num += T0*std::log(1.0-pHat);#
    if(pHat>0.0)      num += T1*std::log(pHat);#
    int sum01=x00+x01; double pi01=(sum01>0)?((double)x01/sum01):1.0;#
    int sum11=x10+x11; double pi11=(sum11>0)?((double)x11/sum11):1.0;#
    double den=0.0;#
    if(1.0-pi01>0.0) den+=x00*std::log(1.0-pi01);#
    if(pi01>0.0)     den+=x01*std::log(pi01);#
    if(1.0-pi11>0.0) den+=x10*std::log(1.0-pi11);#
    if(pi11>0.0)     den+=x11*std::log(pi11);#
    double LR=-2.0*(num - den);#
    dmap[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vp; vp.reserve(dmap.size());#
  for(auto &kv:dmap) vp.push_back(std::make_pair(kv.first, kv.second));#
  std::sort(vp.begin(), vp.end(), [](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LRvals, probvals;#
  if(!vp.empty()){#
    double curLR=vp[0].first, curP=vp[0].second;#
    for(size_t i=1;i<vp.size();i++){#
      if(std::fabs(vp[i].first - curLR)<1e-15) curP+=vp[i].second;#
      else {#
        LRvals.push_back(curLR); probvals.push_back(curP);#
        curLR=vp[i].first; curP=vp[i].second;#
      }#
    }#
    LRvals.push_back(curLR); probvals.push_back(curP);#
  }#
  return List::create(Named("LR")=LRvals, Named("prob")=probvals);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  if(!length(LRvals)) return(list(x=numeric(0),y=numeric(0)))#
  cum <- cumsum(probvals)#
  if(LRvals[1]>=0) {#
    x <- c(0, LRvals)#
    y <- c(0, cum)#
  } else {#
    x <- LRvals#
    y <- cum#
  }#
  list(x=x,y=y)#
}#
#
cdf_val <- function(x, xs, ys){#
  if(!length(xs)) return(0)#
  if(x<=xs[1]) return(0)#
  if(x>=xs[length(xs)]) return(ys[length(xs)])#
  idx <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[idx]#
}#
#
ks_diff <- function(LRvals, probvals, df=1){#
  d <- cdf_xy(LRvals, probvals)#
  xs <- d$x; ys <- d$y#
  if(!length(xs)) return(0)#
  xmax <- xs[length(xs)] + 1#
  xsample <- seq(0, xmax, length.out=800)#
  supd <- 0#
  for(xv in xsample){#
    Ft <- cdf_val(xv, xs, ys)#
    Fc <- pchisq(xv, df)#
    dd <- abs(Ft - Fc)#
    if(dd>supd) supd<-dd#
  }#
  supd#
}#
#
main <- function(){#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax <- 2000#
  nmin <- 1#
  step <- 1#
  res_dict <- list()#
  plot(NULL, xlim=c(nmin,nmax), ylim=c(0,1), xlab="n", ylab="KS distance", main="KS distance vs n")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_dist_fastcpp(a)#
    nvals <- seq(nmin,nmax,by=step)#
    ksvals <- numeric(length(nvals))#
    for(ix in seq_along(nvals)){#
      t <- nvals[ix]#
      lrres <- dist_at_current_fastcpp(dist_k, t)#
      kd <- ks_diff(lrres$LR, lrres$prob, 1)#
      ksvals[ix] <- kd#
      if(t < nmax) dist_k <- step_forward_fastcpp(dist_k, a, 1e-15, nmax)#
    }#
    lines(nvals, ksvals, col=cols[i], lwd=2)#
    res_dict[[as.character(a)]] <- list(nvals=nvals, ksvals=ksvals)#
    i <- i+1#
  }#
  legend("topright", legend=paste0("alpha=",alpha_list), col=cols, lty=1, lwd=2)#
}#
#
main()
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log(x < EPS ? EPS : x); }#
#
struct State{ int last,s00,s10,s01,s11; double prob; };#
struct LLHash{ std::size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
#
static inline long long ENC(int l,int a,int b,int c,int d,int n){#
  long long s2=2LL, s3=s2*(n+1), s4=s3*(n+1), s5=s4*(n+1);#
  return l + s2*a + s3*b + s4*c + s5*d;#
}#
#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05){#
  State s0{0,0,0,0,0,1.0-alpha}, s1{1,0,0,0,0,alpha};#
  return List::create(_["last"]={s0.last,s1.last},#
                      _["s00"] ={s0.s00,s1.s00},#
                      _["s10"] ={s0.s10,s1.s10},#
                      _["s01"] ={s0.s01,s1.s01},#
                      _["s11"] ={s0.s11,s1.s11},#
                      _["prob"]={s0.prob,s1.prob});#
}#
#
// [[Rcpp::export]]#
List step_forward_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<long long,State,LLHash> mp;#
  mp.reserve(l.size()*2);#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    State st{l[i],a[i],b[i],c[i],d[i],p[i]};#
    State t=st; if(t.last==0) t.s00++; else t.s10++; t.last=0; t.prob*=1.0-alpha;#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob+=t.prob;#
    t=st; if(t.last==0) t.s01++; else t.s11++; t.last=1; t.prob*=alpha;#
    mp[ENC(t.last,t.s00,t.s10,t.s01,t.s11,nmax)].prob+=t.prob;#
  }#
  int m=mp.size();#
  IntegerVector L(m),A(m),B(m),C(m),D(m); NumericVector P(m);#
  int idx=0;#
  for(auto &kv:mp){#
    if(kv.second.prob<th) continue;#
    L[idx]=kv.second.last; A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;  D[idx]=kv.second.s11; P[idx]=kv.second.prob; idx++;#
  }#
  L.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List cur,int t){#
  IntegerVector l=cur["last"],a=cur["s00"],b=cur["s10"],c=cur["s01"],d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
  for(int i=0;i<l.size();i++){#
    if(p[i]==0.0) continue;#
    int x00=a[i],x10=b[i],x01=c[i],x11=d[i];#
    int T0=x00+x10, T1=x01+x11;#
    double ph=(t>1)?(double)T1/(t-1):0.0;#
    double num=T0*safe_log(1.0-ph)+T1*safe_log(ph);#
    int s01=x00+x01,s11=x10+x11;#
    double pi01=(s01>0)?(double)x01/s01:1.0;#
    double pi11=(s11>0)?(double)x11/s11:1.0;#
    double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+#
               x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
    mp[-2.0*(num-den)]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0;#
    while(i<v.size()&&std::fabs(v[i].first-cur)<1e-15){sum+=v[i].second;i++;}#
    LR.push_back(cur);Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
cdf_xy  <- function(LR, pr){#
  o  <- order(LR)#
  x0 <- c(LR[o], 0)#
  y0 <- c(cumsum(pr[o]), 0)#
  o2 <- order(x0)#
  list(x = x0[o2], y = y0[o2])#
}#
cdf_val <- function(x, xs, ys) ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
ks_diff <- function(LR, pr, df = 1){#
  if(!length(LR)) return(0)#
  d  <- cdf_xy(LR, pr)#
  xs <- seq(0, tail(d$x,1)+1, length.out = 800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
main <- function(){#
  alpha <- c(0.01,0.025,0.05); cols <- c("red","blue","green")#
  nmax <- 2000; plot(NULL,xlim=c(1,nmax),ylim=c(0,1),xlab="n",ylab="KS distance",main="KS distance vs n")#
  for(i in seq_along(alpha)){#
    dist <- initialize_dist_fastcpp(alpha[i])#
    nvals <- 1:nmax; ks <- numeric(nmax)#
    for(t in nvals){#
      res <- dist_at_current_fastcpp(dist,t); ks[t] <- ks_diff(res$LR,res$prob,1)#
      if(t<nmax) dist <- step_forward_fastcpp(dist,alpha[i],1e-15,nmax)#
    }#
    lines(nvals,ks,col=cols[i],lwd=2)#
  }#
  legend("topright",legend=paste0("alpha=",alpha),col=cols,lty=1,lwd=2)#
}#
main()
library(Rcpp)#
#
heatmap_ks_no_fields <- function(alpha_seq = seq(0.01, 0.05, by=0.005), nmax = 2000, prune_threshold = 1e-15) {#
  t_start <- proc.time()[3]#
  ks_mat <- matrix(NA_real_, nrow = nmax, ncol = length(alpha_seq))#
  for (i in seq_along(alpha_seq)) {#
    a <- alpha_seq[i]#
    dist_k <- initialize_dist_fastcpp(a)#
    for (n in 1:nmax) {#
      lrres <- dist_at_current_fastcpp(dist_k, n)#
      ks_mat[n, i] <- ks_diff(lrres$LR, lrres$prob, 1)#
      if (n < nmax) {#
        dist_k <- step_forward_fastcpp(dist_k, a, prune_threshold, nmax)#
      }#
    }#
    elapsed <- proc.time()[3] - t_start#
    pct_done <- i / length(alpha_seq)#
    est_total <- elapsed / pct_done#
    est_left <- est_total - elapsed#
    cat(sprintf("alpha=%6.3f done. (%.1f%%). elapsed=%.2fs, est. time left=%.2fs\n",#
                a, 100*pct_done, elapsed, est_left))#
  }#
  ks_mat[ks_mat > 0.1] <- 0.1#
  ks_mat[is.na(ks_mat)] <- 0.1#
  xvals <- alpha_seq#
  yvals <- 1:nmax#
  col_fun <- colorRampPalette(c("blue","green","yellow","red"))(256)#
  zlim <- c(0, 0.1)#
  layout(matrix(c(1,2), nrow=1), widths=c(4,0.8))#
  par(mar=c(5,4,4,1))#
  image(xvals, yvals, t(ks_mat), col=col_fun, zlim=zlim, xlab="alpha", ylab="n", main="CDF difference (True vs Chi2)")#
  par(mar=c(5,1,4,3))#
  xx <- c(0,1)#
  yy <- seq(zlim[1], zlim[2], length.out=256)#
  zz <- matrix(rep(yy, each=length(xx)), nrow=length(xx), ncol=length(yy))#
  image(xx, yy, zz, col=col_fun, zlim=zlim, xlab="", ylab="", xaxt="n", yaxt="n")#
  axis(4, at=seq(zlim[1], zlim[2], by=0.02), las=1)#
  box()#
  invisible(ks_mat)#
}#
#
res_matrix_no_fields <- heatmap_ks_no_fields()
library(Rcpp)#
#
forward_all_t <- function(nmax, alpha, prune_threshold = 1e-15) {#
  fw <- vector("list", nmax + 1L)#
  fw[[1]] <- initialize_dist_fastcpp(alpha)#
  for (t in 2L:(nmax + 1L))#
    fw[[t]] <- step_forward_fastcpp(fw[[t - 1L]], alpha, prune_threshold, nmax)#
  fw#
}#
#
LR_dist_from_forward <- function(fw, t) {#
  if (t <= 1L) return(list(LR = 0, prob = 1))#
  dist_at_current_fastcpp(fw[[t]], t)#
}#
#
cdf_val <- function(x, xs, ys) ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
#
cdf_diff <- function(LRvals, probvals, df = 1) {#
  o  <- order(LRvals)#
  xs <- c(0,  LRvals[o])#
  ys <- c(0, cumsum(probvals[o]))#
  testx <- seq(0, tail(xs, 1) + 1, length.out = 400)#
  max(abs(cdf_val(testx, xs, ys) - pchisq(testx, df)))#
}#
#
generate_data_points <- function() {#
  n_list    <- c(250, 500, 1000, 2000)#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax      <- 2000#
  res <- matrix(0, nrow = length(n_list) * length(alpha_list), ncol = 3L)#
  idx <- 1L#
  for (n_ in n_list) {#
    for (a_ in alpha_list) {#
      fw   <- forward_all_t(nmax, a_)#
      diff <- cdf_diff(LR_dist_from_forward(fw, n_)$LR,#
                       LR_dist_from_forward(fw, n_)$prob, 1)#
      res[idx, ] <- c(n_, a_, diff); idx <- idx + 1L#
    }#
  }#
  split(as.data.frame(res), seq_len(nrow(res)))#
}#
#
plot_grouped_bar <- function(results) {#
  vals <- do.call(rbind, results)#
  n_list     <- sort(unique(vals[, 1]))#
  alpha_list <- sort(unique(vals[, 2]))#
  m <- matrix(0, nrow = length(n_list), ncol = length(alpha_list))#
  for (i in seq_len(nrow(vals))) {#
    m[which(n_list == vals[i, 1]), which(alpha_list == vals[i, 2])] <- vals[i, 3]#
  }#
  colset <- c("blue", "orange", "green3")#
  barplot(t(m), beside = TRUE, names.arg = n_list, col = colset,#
          xlab = "n", ylab = "KS distance",#
          main = "Histogram of KS distance")#
  abline(h = c(0.05, 0.1), col = "red", lty = 2)#
  legend("topright", legend = paste0("alpha=", alpha_list),#
         fill = colset, bty = "n")#
}#
#
main <- function() {#
  results <- generate_data_points()#
  for (x in results)#
    cat(sprintf("n=%d, alpha=%.3f, KS=%.5f\n", x[1], x[2], x[3]))#
  plot_grouped_bar(results)#
}#
#
res <- main()
forward_all_t <- function(nmax, alpha, prune_threshold = 1e-15) {#
  fw <- vector("list", nmax + 1L)#
  fw[[1]] <- initialize_dist_fastcpp(alpha)#
  for (t in 2L:(nmax + 1L))#
    fw[[t]] <- step_forward_fastcpp(fw[[t - 1L]], alpha, prune_threshold, nmax)#
  fw#
}#
#
LR_dist_from_forward <- function(fw, t) {#
  if (t <= 1L) return(list(LR = 0, prob = 1))#
  dist_at_current_fastcpp(fw[[t]], t)#
}#
#
cdf_val <- function(x, xs, ys) ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
#
cdf_diff <- function(LRvals, probvals, df = 1) {#
  o  <- order(LRvals)#
  xs <- c(0,  LRvals[o])#
  ys <- c(0, cumsum(probvals[o]))#
  testx <- seq(0, tail(xs, 1) + 1, length.out = 400)#
  max(abs(cdf_val(testx, xs, ys) - pchisq(testx, df)))#
}#
#
generate_data_points <- function() {#
  n_list    <- c(250, 500, 1000, 2000)#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax      <- 2000#
  res <- matrix(0, nrow = length(n_list) * length(alpha_list), ncol = 3L)#
  idx <- 1L#
  for (n_ in n_list) {#
    for (a_ in alpha_list) {#
      fw   <- forward_all_t(nmax, a_)#
      diff <- cdf_diff(LR_dist_from_forward(fw, n_)$LR,#
                       LR_dist_from_forward(fw, n_)$prob, 1)#
      res[idx, ] <- c(n_, a_, diff); idx <- idx + 1L#
    }#
  }#
  asplit(res, 1)#
}#
#
plot_grouped_bar <- function(results) {#
  vals <- do.call(rbind, results)#
  n_list     <- sort(unique(vals[, 1]))#
  alpha_list <- sort(unique(vals[, 2]))#
  m <- matrix(0, nrow = length(n_list), ncol = length(alpha_list))#
  for (i in seq_len(nrow(vals))) {#
    m[which(n_list == vals[i, 1]), which(alpha_list == vals[i, 2])] <- vals[i, 3]#
  }#
  colset <- c("blue", "orange", "green3")#
  barplot(t(m), beside = TRUE, names.arg = n_list, col = colset,#
          xlab = "n", ylab = "KS distance",#
          main = "Histogram of KS distance")#
  abline(h = c(0.05, 0.1), col = "red", lty = 2)#
  legend("topright", legend = paste0("alpha=", alpha_list),#
         fill = colset, bty = "n")#
}#
#
main <- function() {#
  results <- generate_data_points()#
  for (x in results)#
    cat(sprintf("n=%d, alpha=%.3f, KS=%.5f\n", x[1], x[2], x[3]))#
  plot_grouped_bar(results)#
}#
#
main()
library(Rcpp)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
struct State {#
  int last;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_state(int last, int s00, int s10, int s01, int s11, int nmax){#
  long long SHIFT2 = 2LL;#
  long long SHIFT3 = SHIFT2*(nmax+1);#
  long long SHIFT4 = SHIFT3*(nmax+1);#
  long long SHIFT5 = SHIFT4*(nmax+1);#
  return (long long)last#
       + SHIFT2*(long long)s00#
       + SHIFT3*(long long)s10#
       + SHIFT4*(long long)s01#
       + SHIFT5*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List initialize_dist_fastcpp(double alpha=0.05) {#
  State s0; s0.last=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0-alpha;#
  State s1; s1.last=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
  IntegerVector vl(2), vs00(2), vs10(2), vs01(2), vs11(2);#
  NumericVector vp(2);#
  vl[0]=s0.last; vs00[0]=s0.s00; vs10[0]=s0.s10; vs01[0]=s0.s01; vs11[0]=s0.s11; vp[0]=s0.prob;#
  vl[1]=s1.last; vs00[1]=s1.s00; vs10[1]=s1.s10; vs01[1]=s1.s01; vs11[1]=s1.s11; vp[1]=s1.prob;#
  return List::create(Named("last")=vl, Named("s00")=vs00, Named("s10")=vs10,#
                      Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_fastcpp(List curDist, double alpha=0.05, double prune_threshold=1e-15, int nmax=2000) {#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<long long, State, LLHash> newMap;#
  newMap.reserve(last.size()*2);#
  for(int i=0;i<last.size();i++){#
    double p=prob[i];#
    if(p<prune_threshold) continue;#
    State st; st.last=last[i]; st.s00=s00[i]; st.s10=s10[i]; st.s01=s01[i]; st.s11=s11[i]; st.prob=p;#
    {#
      State ns=st;#
      if(ns.last==0) ns.s00++; else ns.s10++;#
      ns.last=0; ns.prob=p*(1.0-alpha);#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=newMap.find(code);#
      if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
    }#
    {#
      State ns=st;#
      if(ns.last==0) ns.s01++; else ns.s11++;#
      ns.last=1; ns.prob=p*alpha;#
      long long code=encode_state(ns.last,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=newMap.find(code);#
      if(it==newMap.end()) newMap[code]=ns; else it->second.prob+=ns.prob;#
    }#
  }#
  std::vector<State> vec; vec.reserve(newMap.size());#
  for(auto &kv:newMap){#
    if(kv.second.prob>=prune_threshold) vec.push_back(kv.second);#
  }#
  int sz=vec.size();#
  IntegerVector vl(sz), vs00(sz), vs10(sz), vs01(sz), vs11(sz);#
  NumericVector vp(sz);#
  for(int i=0;i<sz;i++){#
    vl[i]=vec[i].last; vs00[i]=vec[i].s00; vs10[i]=vec[i].s10;#
    vs01[i]=vec[i].s01; vs11[i]=vec[i].s11; vp[i]=vec[i].prob;#
  }#
  return List::create(Named("last")=vl, Named("s00")=vs00, Named("s10")=vs10,#
                      Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List dist_at_current_fastcpp(List curDist, int t) {#
  IntegerVector last=curDist["last"], s00=curDist["s00"], s10=curDist["s10"],#
                s01=curDist["s01"], s11=curDist["s11"];#
  NumericVector prob=curDist["prob"];#
  std::unordered_map<double,double> dmap;#
  dmap.reserve(last.size());#
  for(int i=0;i<last.size();i++){#
    double p=prob[i];#
    if(p<=0.0) continue;#
    int x00=s00[i], x10=s10[i], x01=s01[i], x11=s11[i];#
    if(t<2){#
      double LR=0.0;#
      dmap[LR]+=p;#
      continue;#
    }#
    double T0=x00+x10, T1=x01+x11;#
    double pHat=(double)T1/(double)(t-1);#
    double num=0.0;#
    if((1.0-pHat)>0.0) num += T0*std::log(1.0-pHat);#
    if(pHat>0.0)       num += T1*std::log(pHat);#
    int sum01=x00+x01;#
    double pi01= (sum01>0)? (double)x01/(double)sum01 : 1.0;#
    int sum11=x10+x11;#
    double pi11= (sum11>0)? (double)x11/(double)sum11 : 1.0;#
    double den=0.0;#
    if((1.0-pi01)>0.0) den += x00*std::log(1.0-pi01);#
    if(pi01>0.0)       den += x01*std::log(pi01);#
    if((1.0-pi11)>0.0) den += x10*std::log(1.0-pi11);#
    if(pi11>0.0)       den += x11*std::log(pi11);#
    double LR=-2.0*(num - den);#
    dmap[LR]+=p;#
  }#
  std::vector<double> LRvals, probvals;#
  LRvals.reserve(dmap.size());#
  probvals.reserve(dmap.size());#
  for(auto &kv : dmap){#
    LRvals.push_back(kv.first);#
    probvals.push_back(kv.second);#
  }#
  std::vector<int> idx(LRvals.size());#
  for(int i=0;i<(int)idx.size();i++) idx[i]=i;#
  std::sort(idx.begin(), idx.end(), [&](int a, int b){return LRvals[a]<LRvals[b];});#
  NumericVector LRout, Pout;#
  if(!idx.empty()){#
    double curLR=LRvals[idx[0]];#
    double curP=probvals[idx[0]];#
    for(size_t i=1;i<idx.size();i++){#
      double tmpLR=LRvals[idx[i]];#
      double tmpP=probvals[idx[i]];#
      if(std::fabs(tmpLR - curLR)<1e-15){#
        curP += tmpP;#
      } else {#
        LRout.push_back(curLR);#
        Pout.push_back(curP);#
        curLR=tmpLR;#
        curP=tmpP;#
      }#
    }#
    LRout.push_back(curLR);#
    Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout, Named("prob")=Pout);#
}#
')#
#
fwd_all_t_R <- function(nmax, alpha, prune_threshold=1e-15) {#
  dist_t <- initialize_dist_fastcpp(alpha)#
  fwd_list <- vector("list", nmax+1)#
  fwd_list[[1]] <- dist_t#
  for (k in 1:(nmax - 1)) {#
    dist_t_next <- step_forward_fastcpp(dist_t, alpha, prune_threshold, nmax)#
    fwd_list[[k+1]] <- dist_t_next#
    dist_t <- dist_t_next#
  }#
  fwd_list#
}#
#
dist_at_t_R <- function(fwd_list, t) {#
  lrres <- dist_at_current_fastcpp(fwd_list[[t]], t)#
  list(LR = lrres$LR, prob = lrres$prob)#
}#
#
cdf_xy <- function(LRvals, probvals) {#
  ok <- !is.na(LRvals) & !is.na(probvals)#
  LRvals <- LRvals[ok]#
  probvals <- probvals[ok]#
  if(!length(LRvals)) return(list(x=numeric(0), y=numeric(0)))#
  o <- order(LRvals)#
  LRsorted <- LRvals[o]#
  p_sorted <- probvals[o]#
  cum_p <- cumsum(p_sorted)#
  list(x = LRsorted, y = cum_p)#
}#
#
cdf_val <- function(x, xs, ys) {#
  if(!length(xs)) return(0)#
  if(x <= xs[1]) return(0)#
  if(x >= xs[length(xs)]) return(ys[length(ys)])#
  i <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[i]#
}#
#
size_dist_val <- function(LRvals, probvals, alpha_p = 0.05) {#
  c_chi2 <- qchisq(1 - alpha_p, df=1)#
  tmp <- cdf_xy(LRvals, probvals)#
  pr_rej <- 1 - cdf_val(c_chi2, tmp$x, tmp$y)#
  pr_rej - alpha_p#
}#
#
main_size_distortion <- function() {#
  alpha_list <- c(0.01, 0.025, 0.05)#
  alpha_p <- 0.05#
  nmax <- 2000#
  nmin <- 1#
  step <- 10#
  res_dict <- list()#
  for(a_ in alpha_list) {#
    f_list <- fwd_all_t_R(nmax, a_, 1e-15)#
    nvals <- seq(nmin, nmax, by=step)#
    sdvals <- numeric(length(nvals))#
    for(i in seq_along(nvals)) {#
      t <- nvals[i]#
      dist_res <- dist_at_t_R(f_list, t)#
      sdvals[i] <- size_dist_val(dist_res$LR, dist_res$prob, alpha_p)#
    }#
    df_alpha <- data.frame(n = nvals, size_distortion = sdvals)#
    res_dict[[as.character(a_)]] <- df_alpha#
  }#
  plot(NA, NA, xlim = c(nmin, nmax), ylim = c(-0.1, 0.1),#
       xlab = "n", ylab = "Size Distortion",#
       main = paste0("Size Distortion vs n (alpha'=", alpha_p, ")"))#
  abline(h=0, col="gray", lty=2)#
  cols <- c("red","blue","forestgreen")#
  leg <- character(0)#
  for(j in seq_along(alpha_list)) {#
    a_ <- alpha_list[j]#
    dfp <- res_dict[[as.character(a_)]]#
    lines(dfp$n, dfp$size_distortion, col=cols[j], lwd=2)#
    points(dfp$n, dfp$size_distortion, col=cols[j], pch=19, cex=0.5)#
    leg <- c(leg, paste0("alpha=", a_))#
  }#
  legend("topright", legend=leg, col=cols, lty=1, lwd=2, pch=19, bty="n")#
}#
#
main_size_distortion()
main_size_distortion_vs_alpha <- function() {#
  n_list <- c(250, 500, 1000)#
  alpha_p <- 0.05#
  alpha_array <- seq(0.01, 0.1, length.out=10)#
  results <- list()#
#
  for(n_ in n_list) {#
    sd_list <- numeric(length(alpha_array))#
    for(i in seq_along(alpha_array)) {#
      alpha_ <- alpha_array[i]#
      f_list <- fwd_all_t_R(n_, alpha_, prune_threshold=1e-15)#
      dist_res <- dist_at_t_R(f_list, n_)#
      sd_list[i] <- size_dist_val(dist_res$LR, dist_res$prob, alpha_p)#
    }#
    results[[as.character(n_)]] <- sd_list#
  }#
#
  plot(NA, NA, xlim = range(alpha_array), ylim = c(-0.1, 0.1),#
       xlab = "alpha", ylab = "Size Distortion",#
       main = paste0("Size Distortion vs alpha (alpha'=", alpha_p, ")"))#
  abline(h=0, col="gray", lty=2)#
  cols <- c("red","blue","forestgreen")#
  leg <- character(0)#
  i <- 1#
  for(n_ in n_list) {#
    lines(alpha_array, results[[as.character(n_)]], col=cols[i], lwd=2)#
    points(alpha_array, results[[as.character(n_)]], col=cols[i], pch=19, cex=0.5)#
    leg <- c(leg, paste0("n=", n_))#
    i <- i + 1#
  }#
  legend("topright", legend=leg, col=cols, lty=1, lwd=2, pch=19, bty="n")#
}#
#
main_size_distortion_vs_alpha()
main_size_distortion_vs_prune <- function() {#
  alpha_list <- c(0.01, 0.025, 0.05)#
  prune_list <- c(1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10)#
  n <- 500#
  alpha_p <- 0.05#
  res <- list()#
  lr_counts <- list()#
  sum_probs <- list()#
  for(a_ in alpha_list) {#
    sd_vals <- numeric(length(prune_list))#
    distinct_vals <- integer(length(prune_list))#
    prob_sums <- numeric(length(prune_list))#
    for(i in seq_along(prune_list)) {#
      prth <- prune_list[i]#
      f_list <- fwd_all_t_R(n, a_, prune_threshold=prth)#
      dist_res <- dist_at_t_R(f_list, n)#
      LRv <- dist_res$LR#
      pv <- dist_res$prob#
      sd_vals[i] <- size_dist_val(LRv, pv, alpha_p)#
      distinct_vals[i] <- length(LRv)#
      prob_sums[i] <- sum(pv)#
    }#
    res[[as.character(a_)]] <- sd_vals#
    lr_counts[[as.character(a_)]] <- distinct_vals#
    sum_probs[[as.character(a_)]] <- prob_sums#
  }#
  plot(NA, NA, xlim=range(prune_list), ylim=c(-0.1,0.1),#
       log="x", xlab="Pruning Threshold (log scale)",#
       ylab="Size Distortion",#
       main=paste0("Size Distortion vs Pruning Threshold (n=", n, ", alpha'=", alpha_p, ")"))#
  abline(h=0, col="gray", lty=2)#
  cols <- c("red","blue","forestgreen")#
  leg <- character(0)#
  i <- 1#
  for(a_ in alpha_list) {#
    lines(prune_list, res[[as.character(a_)]], col=cols[i], lwd=2)#
    points(prune_list, res[[as.character(a_)]], col=cols[i], pch=19, cex=0.7)#
    leg <- c(leg, paste0("alpha=", a_))#
    i <- i + 1#
  }#
  legend("bottomleft", legend=leg, col=cols, lty=1, lwd=2, pch=19, bty="n")#
  cat(paste0("n=", n, "\n"))#
  cat(" alpha    prune_threshold  #distinct_LR    sum(prob)      size_distortion\n")#
  for(a_ in alpha_list) {#
    sd_vals <- res[[as.character(a_)]]#
    dcts <- lr_counts[[as.character(a_)]]#
    sps <- sum_probs[[as.character(a_)]]#
    for(j in seq_along(prune_list)) {#
      cat(sprintf("%-8.3f %-14.1e %-14d %-14.8f %-14.8f\n",#
                  a_, prune_list[j], dcts[j], sps[j], sd_vals[j]))#
    }#
    cat("\n")#
  }#
}#
#
main_size_distortion_vs_prune()
heatmap_size_distortion <- function() {#
  alpha_array <- seq(0.01, 0.05, by=0.005)#
  nmax <- 2000#
  alpha_p <- 0.05#
  data_mat <- matrix(0, nrow=length(alpha_array), ncol=nmax)#
  for(i in seq_along(alpha_array)) {#
    alpha_ <- alpha_array[i]#
    cat(sprintf("alpha=%.3f done. (%.1f%%)\n", alpha_, 100*i/length(alpha_array)))#
    fwd_result <- fwd_all_t_R(nmax, alpha_, 1e-15)#
    for(t in 1:nmax) {#
      dist_res <- dist_at_t_R(fwd_result, t)#
      data_mat[i, t] <- size_dist_val(dist_res$LR, dist_res$prob, alpha_p)#
    }#
  }#
  val_min <- min(data_mat)#
  val_max <- max(data_mat)#
  abs_max <- max(abs(val_min), abs(val_max))#
  col_fun <- colorRampPalette(c("blue","white","red"))(256)#
  zlim <- c(-abs_max, abs_max)#
  layout(matrix(c(1,2), nrow=1), widths=c(4,1.2))#
  par(mar=c(5,4,4,1))#
  image(1:nmax, alpha_array, t(data_mat),#
        col=col_fun, zlim=zlim, xlab="n", ylab="alpha",#
        main=paste0("Heatmap of Size Distortion (alpha'=", alpha_p, ")"),#
        ylim=range(alpha_array), xlim=c(1, nmax), useRaster=TRUE)#
  par(mar=c(5,1,4,6))#
  lcol <- length(col_fun)#
  scale_y <- seq(zlim[1], zlim[2], length.out=lcol)#
  image(x=1:2, y=scale_y, z=matrix(rep(scale_y, each=2), nrow=2),#
        col=col_fun, zlim=zlim, xaxt="n", xlab="", ylab="", main="")#
  axis(4, at=seq(zlim[1], zlim[2], length.out=5), las=1)#
  box()#
}#
heatmap_size_distortion()
main_size_distortion_bars <- function() {#
  alpha_list <- c(0.01, 0.025, 0.05)#
  n_list <- c(250, 500, 1000, 2000)#
  alpha_prime <- 0.05#
  results_mat <- matrix(0, nrow=length(n_list), ncol=length(alpha_list))#
  for(i in seq_along(n_list)) {#
    n_ <- n_list[i]#
    for(j in seq_along(alpha_list)) {#
      alpha_ <- alpha_list[j]#
      fwd_result <- fwd_all_t_R(n_, alpha_, 1e-15)#
      dist_res <- dist_at_t_R(fwd_result, n_)#
      sd_ <- size_dist_val(dist_res$LR, dist_res$prob, alpha_prime)#
      results_mat[i, j] <- sd_#
    }#
  }#
  for(i in seq_along(n_list)) {#
    n_ <- n_list[i]#
    cat(sprintf("n=%d:\n", n_))#
    for(j in seq_along(alpha_list)) {#
      alpha_ <- alpha_list[j]#
      cat(sprintf("  alpha=%.3f, SizeDist=%.6f\n", alpha_, results_mat[i, j]))#
    }#
    cat("\n")#
  }#
  par(mar=c(5,4,4,2))#
  bp <- barplot(#
    t(results_mat),#
    beside=TRUE,#
    names.arg=n_list,#
    col=c("blue","orange","green"),#
    xlab="n",#
    ylab="Size Distortion",#
    main=paste0("Size Distortion (alpha'=", alpha_prime, ")")#
  )#
  abline(h=0.01, col="red", lty=2)#
  abline(h=-0.01, col="red", lty=2)#
  legend(#
    "topleft",#
    legend=c(#
      paste0("alpha=", alpha_list),#
      "Threshold=+0.01",#
      "Threshold=-0.01"#
    ),#
    fill=c("blue","orange","green", NA, NA),#
    lty=c(NA,NA,NA,2,2),#
    col=c("blue","orange","green","red","red"),#
    bty="n"#
  )#
}#
#
main_size_distortion_bars()
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);}#
struct State{int la,T00,T10,T01,T11;double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);}};#
#
static inline long long encode5(int la,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M;#
  return la+S2*T00+S3*T10+S4*T01+S5*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrind_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  {#
    State s0{0,0,0,0,0,1.0-alpha};#
    cur[encode5(0,0,0,0,0,NMAX)]=s0;#
    State s1{1,0,0,0,0,alpha};#
    cur[encode5(1,0,0,0,0,NMAX)]=s1;#
  }#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[encode5(ns.la,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double LR=0.0;#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat = (double)T1 / (double)(n-1);#
      double num = T0*s_log(1.0-pHat) + T1*s_log(pHat);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      LR=-2.0*(num-den);#
    }#
    dist[LR]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first,curP=0.0;#
    while(i<vec.size()&&fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrind <- function(n, alpha) fb_lrind_fastcpp(n, alpha, 1e-15)#
#
my_compute_LRind <- function(X, alpha){#
  n <- length(X); if(n < 2) return(0)#
  T00 <- T01 <- T10 <- T11 <- 0#
  for(i in 2:n){#
    if(X[i-1]==0&&X[i]==0) T00 <- T00 + 1 else#
    if(X[i-1]==0&&X[i]==1) T01 <- T01 + 1 else#
    if(X[i-1]==1&&X[i]==0) T10 <- T10 + 1 else T11 <- T11 + 1#
  }#
  T0 <- T00 + T10; T1 <- T01 + T11#
  pHat <- if(n > 1) T1 / (n - 1) else 0#
  num  <- T0*safe_log(1 - pHat) + T1*safe_log(pHat)#
  s01 <- T00 + T01; pi01 <- if(s01 > 0) T01/s01 else 1#
  s11 <- T10 + T11; pi11 <- if(s11 > 0) T11/s11 else 1#
  den <- T00*safe_log(1 - pi01) + T01*safe_log(pi01) +#
         T10*safe_log(1 - pi11) + T11*safe_log(pi11)#
  -2*(num - den)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
gen_markov <- function(n, alpha, phi = 0.6){#
  p11 <- phi; p01 <- alpha*(1 - phi)/(1 - alpha)#
  X <- numeric(n); X[1] <- rbinom(1, 1, alpha)#
  for(i in 2:n) X[i] <- rbinom(1, 1, ifelse(X[i-1]==1, p11, p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results_size <- data.frame(); results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrind(n_, alpha_)#
    LRvals <- dist$LR; probvals <- dist$prob#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      rej_ex[i] <- (p_ex < 0.05); rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex)#
    se_ex <- sqrt(size_ex*(1 - size_ex)/Nrep)#
    size_ch <- mean(rej_ch)#
    se_ch <- sqrt(size_ch*(1 - size_ch)/Nrep)#
    results_size <- rbind(results_size,#
      data.frame(n = n_, alpha = alpha_, size_exact = size_ex, se_size_exact = se_ex,#
                 size_chi2_1 = size_ch, se_size_chi2_1 = se_ch))#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRind(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 1)#
      pow_ex[i] <- (p_ex < 0.05); pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex <- mean(pow_ex)#
    se_pe <- sqrt(p_ex*(1 - p_ex)/Nrep)#
    p_ch <- mean(pow_ch)#
    se_pc <- sqrt(p_ch*(1 - p_ch)/Nrep)#
    results_power <- rbind(results_power,#
      data.frame(n = n_, alpha = alpha_, power_exact = p_ex, se_power_exact = se_pe,#
                 power_chi2_1 = p_ch, se_power_chi2_1 = se_pc))#
  }#
}#
#
size_df <- pivot_longer(results_size, cols = c(size_exact, size_chi2_1),#
                        names_to = "method", values_to = "value")#
size_df$method[size_df$method == "size_chi2_1"] <- "size_chi2(1)"#
#
power_df <- pivot_longer(results_power, cols = c(power_exact, power_chi2_1),#
                         names_to = "method", values_to = "value")#
power_df$method[power_df$method == "power_chi2_1"] <- "power_chi2(1)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill = method))+#
  geom_bar(stat = "identity", position = "dodge")+#
  geom_errorbar(aes(ymin = value - 1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1),#
                    ymax = value + 1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_1)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_wrap(~alpha, labeller = label_both)+#
  geom_hline(yintercept = 0.05, colour = "red", linetype = "dashed")+#
  labs(x = "n", y = "empirical size (significance level = 5%)")+#
  theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill = method))+#
  geom_bar(stat = "identity", position = "dodge")+#
  geom_errorbar(aes(ymin = value - 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1),#
                    ymax = value + 1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_1)),#
                position = position_dodge(0.9), width = 0.25)+#
  facet_wrap(~alpha, labeller = label_both)+#
  labs(x = "n", y = "empirical power (φ=0.6)")+#
  theme_minimal()#
#
print(p_power / p_size)
n_phi <- 250#
alpha_phi <- 0.05#
phi_list <- c(0.2,0.4,0.6,0.8,0.9)#
dist_phi <- fb_lrind(n_phi, alpha_phi)#
LRv <- dist_phi$LR; Pv <- dist_phi$prob#
phi_df <- data.frame()#
for(ph in phi_list){#
  ex <- ch <- numeric(Nrep)#
  for(i in 1:Nrep){#
    X <- gen_markov(n_phi, alpha_phi, ph)#
    LR <- my_compute_LRind(X, alpha_phi)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 1)#
    ex[i] <- (p_e < 0.05)#
    ch[i] <- (p_c < 0.05)#
  }#
  phi_df <- rbind(phi_df,#
    data.frame(phi = ph, method = "exact",   power = mean(ex),#
               se = sqrt(mean(ex)*(1 - mean(ex))/Nrep)),#
    data.frame(phi = ph, method = "chi2(1)", power = mean(ch),#
               se = sqrt(mean(ch)*(1 - mean(ch))/Nrep)))#
}#
#
ggplot(phi_df, aes(phi, power, color = method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin = power - 1.96*se, ymax = power + 1.96*se), width = 0.02)+#
  scale_x_continuous(breaks = phi_list)+#
  labs(x = "phi", y = "empirical power (n=250, α=0.05)")+#
  theme_minimal()
exception_df <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names = 1)#
alpha_vec <- c(0.05,0.025,0.01)#
colnames(exception_df) <- as.character(alpha_vec)#
n_win <- 250#
series_len <- nrow(exception_df)#
plot_df <- data.frame()#
for(a in alpha_vec){#
  X <- exception_df[[as.character(a)]]#
  dist <- fb_lrind(n_win, a)#
  LRv <- dist$LR; Pv <- dist$prob#
  idx_max <- series_len - n_win + 1#
  for(idx in 1:idx_max){#
    seg <- X[idx:(idx + n_win - 1)]#
    LR <- my_compute_LRind(seg, a)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 1)#
    plot_df <- rbind(plot_df,#
      data.frame(idx = idx, alpha = a, method = "exact",   p_value = p_e),#
      data.frame(idx = idx, alpha = a, method = "chi2(1)", p_value = p_c))#
  }#
}#
ggplot(plot_df, aes(idx, p_value, color = method))+#
  geom_line()+#
  facet_wrap(~alpha, labeller = label_both, ncol = 1)+#
  geom_hline(yintercept = 0.05, linetype = "dashed", colour = "red")+#
  labs(x = "window start index", y = "p-value")+#
  theme_minimal()
library(Rcpp)#
library(stats)#
#
safe_log <- function(x){#
  eps <- 1e-15#
  log(ifelse(x > eps, x, eps))#
}#
#
LRuc_count <- function(x, n, p){#
  eps  <- 1e-15#
  p_   <- max(min(p, 1 - eps), eps)#
  phat <- if (x == 0) 0 else if (x == n) 1 else x / n#
  ph_  <- max(min(phat, 1 - eps), eps)#
  num  <- x * safe_log(p_) + (n - x) * safe_log(1 - p_)#
  den  <- x * safe_log(ph_) + (n - x) * safe_log(1 - ph_)#
  -2 * (num - den)#
}#
#
LRind_counts_loc <- function(T00, T10, T01, T11, n){#
  if (n <= 1) return(0)#
  T0   <- T00 + T10#
  T1   <- T01 + T11#
  pHat <- if ((n - 1) > 0) T1 / (n - 1) else 0#
  num  <- T0 * safe_log(1 - pHat) + T1 * safe_log(pHat)#
  pi01 <- if ((T00 + T01) > 0) T01 / (T00 + T01) else 1#
  pi11 <- if ((T10 + T11) > 0) T11 / (T10 + T11) else 1#
  den  <- T00 * safe_log(1 - pi01) + T01 * safe_log(pi01) +#
          T10 * safe_log(1 - pi11) + T11 * safe_log(pi11)#
  -2 * (num - den)#
}#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double s_log(double x){ return std::log(x > EPS ? x : EPS); }#
#
struct State{#
  int la, c1, T00, T10, T01, T11;#
  double prob;#
};#
#
struct LLHash{#
  std::size_t operator()(long long x) const{ return std::hash<long long>()(x); }#
};#
#
static inline long long encode6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long S2 = NMAX + 10;#
  long long S3 = S2 * (NMAX + 10);#
  long long S4 = S3 * (NMAX + 10);#
  long long S5 = S4 * (NMAX + 10);#
  long long S6 = S5 * (NMAX + 10);#
  return (long long)la + S2*c1 + S3*T00 + S4*T10 + S5*T01 + S6*T11;#
}#
#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n, double alpha=0.05, double prune_threshold=1e-15){#
  if(n < 1) return List::create(_["LR"]=NumericVector(0), _["prob"]=NumericVector(0));#
  int NMAX = n + 5;#
  std::unordered_map<long long, State, LLHash> cur;#
#
  State s0{0,0,0,0,0,0,1.0-alpha};#
  cur[encode6(s0.la,s0.c1,s0.T00,s0.T10,s0.T01,s0.T11,NMAX)] = s0;#
  State s1{1,1,0,0,0,0,alpha};#
  cur[encode6(s1.la,s1.c1,s1.T00,s1.T10,s1.T01,s1.T11,NMAX)] = s1;#
#
  for(int k=1; k<n; ++k){#
    std::unordered_map<long long, State, LLHash> nxt;#
    nxt.reserve(cur.size()*2);#
    for(auto &kv: cur){#
      if(kv.second.prob < prune_threshold) continue;#
      const State &st = kv.second;#
      double p0 = 1.0 - alpha, p1 = alpha;#
#
      State ns = st;#
      (ns.la==0 ? ns.T00 : ns.T10)++; ns.la = 0; ns.prob = st.prob * p0;#
      long long c = encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
      nxt[c].prob += ns.prob; if(nxt[c].prob == ns.prob) nxt[c] = ns;#
#
      ns = st;#
      (ns.la==0 ? ns.T01 : ns.T11)++; ns.c1++; ns.la = 1; ns.prob = st.prob * p1;#
      c = encode6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX);#
      nxt[c].prob += ns.prob; if(nxt[c].prob == ns.prob) nxt[c] = ns;#
    }#
    cur.clear();#
    for(auto &kv: nxt) if(kv.second.prob >= prune_threshold) cur[kv.first] = kv.second;#
  }#
#
  std::unordered_map<double,double> LRmap;#
  for(auto &kv: cur){#
    if(kv.second.prob <= 0.0) continue;#
    const State &st = kv.second;#
    int c1=st.c1, T00=st.T00, T10=st.T10, T01=st.T01, T11=st.T11;#
#
    double phat = c1==0 ? 0.0 : (c1==n ? 1.0 : (double)c1/n);#
    double p_ = std::max(std::min(alpha,1.0-EPS),EPS);#
    double ph_= std::max(std::min(phat ,1.0-EPS),EPS);#
    double lruc = -2.0*( c1*std::log(p_)+(n-c1)*std::log(1.0-p_)#
                       - c1*std::log(ph_)-(n-c1)*std::log(1.0-ph_) );#
#
    double lrind = 0.0;#
    if(n > 1){#
      int T0=T00+T10, T1=T01+T11;#
      double pH = (double)T1/(n-1);#
      double num = T0*s_log(1.0-pH)+T1*s_log(pH);#
      int s01=T00+T01, s11=T10+T11;#
      double pi01 = s01>0 ? (double)T01/s01 : 1.0;#
      double pi11 = s11>0 ? (double)T11/s11 : 1.0;#
      double den = T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind = -2.0*(num - den);#
    }#
    LRmap[lruc + lrind] += st.prob;#
  }#
#
  std::vector<std::pair<double,double>> v(LRmap.begin(), LRmap.end());#
  std::sort(v.begin(), v.end(), [](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR, Pr;#
  if(!v.empty()){#
    double curLR=v[0].first, curP=v[0].second;#
    for(size_t i=1;i<v.size();++i){#
      if(std::fabs(v[i].first-curLR)<1e-15) curP += v[i].second;#
      else{ LR.push_back(curLR); Pr.push_back(curP); curLR=v[i].first; curP=v[i].second; }#
    }#
    LR.push_back(curLR); Pr.push_back(curP);#
  }#
  return List::create(_["LR"]=LR, _["prob"]=Pr);#
}#
')#
#
fb_lrcc <- function(n, alpha=0.05, prune_threshold=1e-15){#
  fb_lrcc_fastcpp(n, alpha, prune_threshold)#
}#
#
main <- function(){#
  alpha_test <- 0.05#
  for(n_ in c(15,100,500,1000)){#
    t0 <- proc.time()#
    res <- fb_lrcc(n_, alpha_test)#
    dt <- proc.time() - t0#
    cat(sprintf("\n=== n = %d, alpha = %.3f ===\n", n_, alpha_test))#
    cat(sprintf("time = %.3fs, #LR = %d, sum(prob) = %.6f\n",#
                dt["elapsed"], length(res$LR), sum(res$prob)))#
  }#
}#
main()
main <- function() {#
  alpha_list <- c(0.01,0.025,0.05,0.10)#
  n_list <- c(250,500,1000,2000)#
  cat("   n     alpha   #distinct_LR    sum(prob)       time(s)\n")#
  for(alpha_ in alpha_list) {#
    for(n_ in n_list) {#
      t0 <- proc.time()#
      res <- fb_lrcc(n_, alpha_, 1e-15)#
      elapsed <- proc.time() - t0#
      LRvals <- res$LR#
      probvals <- res$prob#
      sumprob <- sum(probvals)#
      cat(sprintf("%5d  %7.3f  %12d  %10.8f  %10.4f\n",#
                  n_, alpha_, length(LRvals), sumprob, elapsed["elapsed"]))#
    }#
    cat("\n")#
  }#
}#
main()
main <- function() {#
  thresholds <- c(1e-17,1e-16,1e-15,1e-14,1e-13,1e-12,1e-11,1e-10)#
  alpha_list <- c(0.01,0.05,0.10)#
  n_list <- c(500,1000)#
  for(n_ in n_list) {#
    cat(sprintf("\nn = %d\n", n_))#
    for(alpha_ in alpha_list) {#
      cat(sprintf("\n=== alpha = %.3f ===\n", alpha_))#
      cat("prune_threshold     #distinct_LR     sum(prob)        time(s)\n")#
      for(th in thresholds) {#
        t0 <- proc.time()#
        res <- fb_lrcc(n_, alpha_, th)#
        elapsed <- proc.time() - t0#
        LRvals <- res$LR#
        probvals <- res$prob#
        sumprob <- sum(probvals)#
        distinct_LR <- length(LRvals)#
        cat(sprintf("%-14g %14d %12.8f %12.4f\n",#
                    th, distinct_LR, sumprob, elapsed["elapsed"]))#
      }#
    }#
  }#
}#
main()
mc_lrcc <- function(n, alpha=0.05, Nrep=20000) {#
  LR_values <- numeric(Nrep)#
  for(i in seq_len(Nrep)) {#
    path <- rbinom(n, 1, alpha)#
    T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
    for(t in 2:n) {#
      if(path[t-1]==0 && path[t]==0) T00 <- T00+1#
      else if(path[t-1]==0 && path[t]==1) T01 <- T01+1#
      else if(path[t-1]==1 && path[t]==0) T10 <- T10+1#
      else T11 <- T11+1#
    }#
    x <- sum(path)#
    lruc  <- LRuc_count(x, n, alpha)#
    lrind <- LRind_counts_loc(T00, T10, T01, T11, n)#
    LR_values[i] <- lruc + lrind#
  }#
  arr <- sort(LR_values)#
  idx_diff <- which(diff(arr) > 0)#
  uniq_idx <- c(idx_diff, length(arr))#
  LRuniq <- arr[uniq_idx]#
  prob_ <- numeric(length(uniq_idx))#
  start <- 1#
  for(j in seq_along(uniq_idx)) {#
    e <- uniq_idx[j]#
    prob_[j] <- (e - start + 1) / Nrep#
    start <- e + 1#
  }#
  list(LR = LRuniq, prob = prob_)#
}#
#
step_cdf_plot <- function(LRvals, probs, col="blue", lty=1) {#
  cdf <- cumsum(probs)#
  x <- c(0, LRvals)#
  y <- c(0, cdf)#
  lines(x, y, type="s", col=col, lty=lty)#
  points(x, y, pch=16, cex=0.5, col=col)#
}#
#
plot_three_distributions_cc <- function(n, alpha, fb_res, mc_res) {#
  plot(0, 0, type="n", xlab="LRcc value", ylab="CDF",#
       xlim=c(0, max(c(fb_res$LR, mc_res$LR, 10))), ylim=c(0, 1.02),#
       main=sprintf("LRcc CDF\nn=%d, alpha=%.3f", n, alpha))#
  step_cdf_plot(fb_res$LR, fb_res$prob, col="blue", lty=1)#
  step_cdf_plot(mc_res$LR, mc_res$prob, col="green", lty=2)#
  xm <- max(c(fb_res$LR, mc_res$LR, 10))#
  xseq <- seq(0, xm + 0.2, length.out=300)#
  chi_cdf <- pchisq(xseq, df=2)#
  lines(xseq, chi_cdf, col="red")#
  legend("bottomright",#
         legend=c("Exact(DP)", "Empirical(MC)", "Chi2(2)"),#
         col=c("blue", "green", "red"), lty=c(1, 2, 1), bty="n")#
}#
#
main <- function() {#
  set.seed(42)#
  alpha_list <- c(0.01, 0.05, 0.10)#
  n_list <- c(15, 100, 500)#
  prune_threshold <- 1e-15#
  Nrep <- 20000#
  cat("   n     alpha   #distinct_LR    sum(prob)       time(s)\n")#
  for(alpha_ in alpha_list) {#
    for(n_ in n_list) {#
      t0 <- proc.time()#
      fb_res <- fb_lrcc(n_, alpha_, prune_threshold)#
      t1 <- proc.time() - t0#
      cat(sprintf("%5d  %7.3f  %12d  %10.8f  %10.4f\n",#
                  n_, alpha_, length(fb_res$LR), sum(fb_res$prob), t1["elapsed"]))#
      t2 <- proc.time()#
      mc_res <- mc_lrcc(n_, alpha_, Nrep)#
      t3 <- proc.time() - t2#
      dev.new(width=5.5, height=4)#
      plot_three_distributions_cc(n_, alpha_, fb_res, mc_res)#
    }#
  }#
  cat("\nDone. Generated 9 figures (3 values of alpha x 3 values of n).\n")#
}#
#
main()#
#
# KS distance v.s. pruning thresholds#
#
cdf_xy <- function(LRvals, probvals) {#
  csum <- cumsum(probvals)#
  x <- c(0, LRvals)#
  y <- c(0, csum)#
  list(x=x, y=y)#
}#
#
cdf_val <- function(x, xx, yy) {#
  if(x <= xx[1]) return(0)#
  if(x >= xx[length(xx)]) return(yy[length(yy)])#
  i <- findInterval(x, xx, rightmost.closed=TRUE)#
  yy[i]#
}#
#
cdf_diff <- function(LRvals, probvals, df=2) {#
  tmp <- cdf_xy(LRvals, probvals)#
  xs <- tmp$x#
  ys <- tmp$y#
  if(!length(xs)) return(0)#
  xm <- xs[length(xs)] + 1#
  seqx <- seq(0, xm, length.out=600)#
  supd <- 0#
  for(xx in seqx) {#
    Ft <- cdf_val(xx, xs, ys)#
    Fc <- pchisq(xx, df)#
    d <- abs(Ft - Fc)#
    if(d > supd) supd <- d#
  }#
  supd#
}#
#
main <- function() {#
  n <- 500#
  alpha_list <- c(0.01, 0.025, 0.05)#
  thresholds <- c(1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10)#
  cat("n=500\n")#
  cat(" alpha    prune_threshold     #distinct_LR     sum(prob)     KS_distance\n")#
  results <- list()#
  for(alpha_ in alpha_list) {#
    thr_vals <- numeric(length(thresholds))#
    ks_vals <- numeric(length(thresholds))#
    for(i in seq_along(thresholds)) {#
      th <- thresholds[i]#
      dist_ <- fb_lrcc(n, alpha_, th)#
      LRvals <- dist_$LR#
      probvals <- dist_$prob#
      sum_prob <- sum(probvals)#
      distinct_LR <- length(LRvals)#
      ks_d <- cdf_diff(LRvals, probvals, 2)#
      cat(sprintf(" %6.3f   %-12g   %12d   %10.8f   %9.6f\n",#
                  alpha_, th, distinct_LR, sum_prob, ks_d))#
      thr_vals[i] <- th#
      ks_vals[i] <- ks_d#
    }#
    results[[as.character(alpha_)]] <- list(th=thr_vals, ks=ks_vals)#
    cat("\n")#
  }#
  plot(NULL, xlim=range(thresholds), ylim=c(0,1), log="x",#
       xlab="prune_threshold", ylab="KS distance",#
       main="KS distance vs prune_threshold (n=500) - LRcc")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(alpha_ in alpha_list) {#
    lines(results[[as.character(alpha_)]]$th, results[[as.character(alpha_)]]$ks,#
          type="b", pch=19, col=cols[i])#
    i <- i + 1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list),#
         col=cols, pch=19, lty=1, bty="n")#
}#
#
main()
mc_lrcc <- function(n, alpha=0.05, Nrep=20000) {#
  LR_values <- numeric(Nrep)#
  for(i in seq_len(Nrep)) {#
    path <- rbinom(n, 1, alpha)#
    T00 <- 0; T01 <- 0; T10 <- 0; T11 <- 0#
    for(t in 2:n) {#
      if(path[t-1]==0 && path[t]==0) T00 <- T00+1#
      else if(path[t-1]==0 && path[t]==1) T01 <- T01+1#
      else if(path[t-1]==1 && path[t]==0) T10 <- T10+1#
      else T11 <- T11+1#
    }#
    x <- sum(path)#
    lruc  <- LRuc_count(x, n, alpha)#
    lrind <- LRind_counts_loc(T00, T10, T01, T11, n)#
    LR_values[i] <- lruc + lrind#
  }#
  arr <- sort(LR_values)#
  idx_diff <- which(diff(arr) > 0)#
  uniq_idx <- c(idx_diff, length(arr))#
  LRuniq <- arr[uniq_idx]#
  prob_ <- numeric(length(uniq_idx))#
  start <- 1#
  for(j in seq_along(uniq_idx)) {#
    e <- uniq_idx[j]#
    prob_[j] <- (e - start + 1) / Nrep#
    start <- e + 1#
  }#
  list(LR = LRuniq, prob = prob_)#
}#
#
step_cdf_plot <- function(LRvals, probs, col="blue", lty=1) {#
  cdf <- cumsum(probs)#
  x <- c(0, LRvals)#
  y <- c(0, cdf)#
  lines(x, y, type="s", col=col, lty=lty)#
  points(x, y, pch=16, cex=0.5, col=col)#
}#
#
plot_three_distributions_cc <- function(n, alpha, fb_res, mc_res) {#
  plot(0, 0, type="n", xlab="LRcc value", ylab="CDF",#
       xlim=c(0, max(c(fb_res$LR, mc_res$LR, 10))), ylim=c(0, 1.02),#
       main=sprintf("LRcc CDF\nn=%d, alpha=%.3f", n, alpha))#
  step_cdf_plot(fb_res$LR, fb_res$prob, col="blue", lty=1)#
  step_cdf_plot(mc_res$LR, mc_res$prob, col="green", lty=2)#
  xm <- max(c(fb_res$LR, mc_res$LR, 10))#
  xseq <- seq(0, xm + 0.2, length.out=300)#
  chi_cdf <- pchisq(xseq, df=2)#
  lines(xseq, chi_cdf, col="red")#
  legend("bottomright",#
         legend=c("Exact(DP)", "Empirical(MC)", "Chi2(2)"),#
         col=c("blue", "green", "red"), lty=c(1, 2, 1), bty="n")#
}#
#
main <- function() {#
  set.seed(42)#
  alpha_list <- c(0.01, 0.05, 0.10)#
  n_list <- c(15, 100, 500)#
  prune_threshold <- 1e-15#
  Nrep <- 20000#
  cat("   n     alpha   #distinct_LR    sum(prob)       time(s)\n")#
  for(alpha_ in alpha_list) {#
    for(n_ in n_list) {#
      t0 <- proc.time()#
      fb_res <- fb_lrcc(n_, alpha_, prune_threshold)#
      t1 <- proc.time() - t0#
      cat(sprintf("%5d  %7.3f  %12d  %10.8f  %10.4f\n",#
                  n_, alpha_, length(fb_res$LR), sum(fb_res$prob), t1["elapsed"]))#
      t2 <- proc.time()#
      mc_res <- mc_lrcc(n_, alpha_, Nrep)#
      t3 <- proc.time() - t2#
      dev.new(width=5.5, height=4)#
      plot_three_distributions_cc(n_, alpha_, fb_res, mc_res)#
    }#
  }#
  cat("\nDone. Generated 9 figures (3 values of alpha x 3 values of n).\n")#
}#
#
main()
main <- function() {#
  n_list <- c(250, 500, 1000)#
  alpha_vals <- seq(0.01, 0.1, length.out=21)#
  curves <- list()#
  for(n_ in n_list) {#
    diffs <- numeric(length(alpha_vals))#
    for(i in seq_along(alpha_vals)) {#
      alpha_ <- alpha_vals[i]#
      dist_ <- fb_lrcc(n_, alpha_)#
      diffs[i] <- cdf_diff(dist_$LR, dist_$prob, 2)#
    }#
    curves[[as.character(n_)]] <- diffs#
  }#
  plot(NA, NA, xlim=range(alpha_vals), ylim=c(0,1),#
       xlab="alpha", ylab="KS distance",#
       main="CDF difference (LRcc vs Chi2) vs alpha")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(n_ in n_list) {#
    lines(alpha_vals, curves[[as.character(n_)]], col=cols[i], lwd=2)#
    points(alpha_vals, curves[[as.character(n_)]], col=cols[i], pch=19, cex=0.7)#
    i <- i+1#
  }#
  legend("topright", legend=paste("n=", n_list), col=cols, pch=19, lty=1, bty="n")#
}#
#
main()
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log( x > EPS ? x : EPS ); }#
#
struct CCState { int last,c1,s00,s10,s01,s11; double prob; };#
struct LLHash  { std::size_t operator()(long long x) const { return std::hash<long long>()(x); } };#
#
static inline long long ENC(int l,int c1,int a,int b,int c,int d,int n){#
  long long step=(long long)n+10, s2=step,s3=s2*step,s4=s3*step,s5=s4*step,s6=s5*step;#
  return l + s2*c1 + s3*a + s4*b + s5*c + s6*d;#
}#
#
// [[Rcpp::export]]#
List initialize_cc_fastcpp(double alpha=0.05){#
  CCState s0{0,0,0,0,0,0,1.0-alpha}, s1{1,1,0,0,0,0,alpha};#
  return List::create(_["last"]={s0.last,s1.last},#
                      _["c1"]  ={s0.c1 ,s1.c1 },#
                      _["s00"] ={s0.s00,s1.s00},#
                      _["s10"] ={s0.s10,s1.s10},#
                      _["s01"] ={s0.s01,s1.s01},#
                      _["s11"] ={s0.s11,s1.s11},#
                      _["prob"]={s0.prob,s1.prob});#
}#
#
// [[Rcpp::export]]#
List step_forward_cc_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"], c1=cur["c1"], a=cur["s00"], b=cur["s10"],#
                c=cur["s01"], d=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<long long,CCState,LLHash> mp; mp.reserve(l.size()*2);#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    CCState st{l[i],c1[i],a[i],b[i],c[i],d[i],p[i]};#
    { CCState ns=st; (ns.last==0?ns.s00:ns.s10)++; ns.last=0; ns.prob*=1.0-alpha;#
      mp[ENC(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax)].prob+=ns.prob; }#
    { CCState ns=st; (ns.last==0?ns.s01:ns.s11)++; ns.c1++; ns.last=1; ns.prob*=alpha;#
      mp[ENC(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax)].prob+=ns.prob; }#
  }#
  int m=mp.size();#
  IntegerVector L(m),C1(m),A(m),B(m),C(m),D(m); NumericVector P(m); int idx=0;#
  for(auto &kv:mp){#
    if(kv.second.prob<th) continue;#
    L[idx]=kv.second.last; C1[idx]=kv.second.c1; A[idx]=kv.second.s00; B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;  D[idx]=kv.second.s11; P[idx]=kv.second.prob; idx++;#
  }#
  L.resize(idx);C1.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["c1"]=C1,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
// [[Rcpp::export]]#
List dist_cc_at_current_fastcpp(List cur,int t,double alpha=0.05){#
  IntegerVector l=cur["last"], c1=cur["c1"], a=cur["s00"], b=cur["s10"],#
                c=cur["s01"], d=cur["s11"]; NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp; mp.reserve(l.size());#
#
  for(int i=0;i<l.size();i++){#
    if(p[i]<=0.0) continue;#
    int n1=c1[i], x00=a[i], x10=b[i], x01=c[i], x11=d[i];#
    double phat=(n1==0)?0.0:((n1==t)?1.0:(double)n1/t);#
    double p_  = std::max(std::min(alpha,1.0-EPS),EPS);#
    double ph_ = std::max(std::min(phat ,1.0-EPS),EPS);#
    double lruc=-2.0*( n1*safe_log(p_) + (t-n1)*safe_log(1.0-p_)#
                     - n1*safe_log(ph_) - (t-n1)*safe_log(1.0-ph_) );#
    double lrind=0.0;#
    if(t>1){#
      int T0=x00+x10, T1=x01+x11;#
      double pH=(double)T1/(t-1);#
      double num=T0*safe_log(1.0-pH)+T1*safe_log(pH);#
      int s01_=x00+x01, s11_=x10+x11;#
      double pi01=(s01_>0)?(double)x01/s01_:1.0;#
      double pi11=(s11_>0)?(double)x11/s11_:1.0;#
      double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+#
                 x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
      lrind=-2.0*(num - den);#
    }#
    mp[lruc+lrind]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto&a,auto&b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0;#
    while(i<v.size() && std::fabs(v[i].first-cur)<1e-15){ sum+=v[i].second; i++; }#
    LR.push_back(cur); Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  o  <- order(LRvals)#
  x0 <- c(LRvals[o], 0)#
  y0 <- c(cumsum(probvals[o]), 0)#
  o2 <- order(x0)#
  list(x = x0[o2], y = y0[o2])#
}#
#
cdf_val <- function(x, xs, ys){#
  ys[pmax.int(findInterval(x, xs, rightmost.closed = TRUE), 1L)]#
}#
#
ks_diff <- function(LRvals, probvals, df = 2){#
  if(!length(LRvals)) return(0)#
  d   <- cdf_xy(LRvals, probvals)#
  xs  <- seq(0, tail(d$x,1)+1, length.out = 800)#
  max(abs(cdf_val(xs, d$x, d$y) - pchisq(xs, df)))#
}#
#
main_cc <- function(){#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax <- 2000#
  plot(NA, xlim=c(1, nmax), ylim=c(0,1), xlab="n", ylab="KS distance",#
       main="CDF difference (LRcc vs Chi2) vs n")#
  cols <- c("red","blue","green"); i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_cc_fastcpp(a)#
    ksvals <- numeric(nmax)#
    for(t in 1:nmax){#
      res <- dist_cc_at_current_fastcpp(dist_k, t, a)#
      ksvals[t] <- ks_diff(res$LR, res$prob, 2)#
      if(t < nmax) dist_k <- step_forward_cc_fastcpp(dist_k, a, 1e-15, nmax)#
    }#
    lines(1:nmax, ksvals, col=cols[i], lwd=2); i <- i + 1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list),#
         col=cols, lty=1, lwd=2, bty="n")#
}#
#
main_cc()
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
#
using namespace Rcpp;#
#
static inline double s_log(double x){#
  return (x>0.0)?std::log(x):0.0;#
}#
#
struct CCState {#
  int last;#
  int c1;#
  int s00;#
  int s10;#
  int s01;#
  int s11;#
  double prob;#
};#
#
struct LLHash {#
  std::size_t operator()(long long x) const {#
    return std::hash<long long>()(x);#
  }#
};#
#
static inline long long encode_cc_state(int last,int c1,int s00,int s10,int s01,int s11,int nmax){#
  long long NSTEP = (long long)nmax + 10;#
  long long SHIFT2 = NSTEP;#
  long long SHIFT3 = SHIFT2*NSTEP;#
  long long SHIFT4 = SHIFT3*NSTEP;#
  long long SHIFT5 = SHIFT4*NSTEP;#
  long long SHIFT6 = SHIFT5*NSTEP;#
  return (long long)last#
       + SHIFT2*(long long)c1#
       + SHIFT3*(long long)s00#
       + SHIFT4*(long long)s10#
       + SHIFT5*(long long)s01#
       + SHIFT6*(long long)s11;#
}#
#
// [[Rcpp::export]]#
List initialize_cc_fastcpp(double alpha=0.05) {#
  CCState s0; #
  s0.last=0; s0.c1=0; s0.s00=0; s0.s10=0; s0.s01=0; s0.s11=0; s0.prob=1.0 - alpha;#
  CCState s1; #
  s1.last=1; s1.c1=1; s1.s00=0; s1.s10=0; s1.s01=0; s1.s11=0; s1.prob=alpha;#
#
  IntegerVector vl(2), vc1(2), vs00(2), vs10(2), vs01(2), vs11(2);#
  NumericVector vp(2);#
  vl[0]   = s0.last;  vc1[0]  = s0.c1;  vs00[0] = s0.s00;  vs10[0] = s0.s10;  vs01[0] = s0.s01;  vs11[0] = s0.s11;  vp[0] = s0.prob;#
  vl[1]   = s1.last;  vc1[1]  = s1.c1;  vs00[1] = s1.s00;  vs10[1] = s1.s10;  vs01[1] = s1.s01;  vs11[1] = s1.s11;  vp[1] = s1.prob;#
  return List::create(Named("last")=vl, Named("c1")=vc1, Named("s00")=vs00, Named("s10")=vs10, Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List step_forward_cc_fastcpp(List curDist, double alpha=0.05, double prune_threshold=1e-15, int nmax=2000){#
  IntegerVector last  = curDist["last"];#
  IntegerVector c1v   = curDist["c1"];#
  IntegerVector s00v  = curDist["s00"];#
  IntegerVector s10v  = curDist["s10"];#
  IntegerVector s01v  = curDist["s01"];#
  IntegerVector s11v  = curDist["s11"];#
  NumericVector probv = curDist["prob"];#
#
  std::unordered_map<long long, CCState, LLHash> newMap;#
  newMap.reserve(last.size()*2);#
#
  for(int i=0; i<last.size(); i++){#
    double p = probv[i];#
    if(p < prune_threshold) continue;#
    CCState st;#
    st.last = last[i];#
    st.c1   = c1v[i];#
    st.s00  = s00v[i];#
    st.s10  = s10v[i];#
    st.s01  = s01v[i];#
    st.s11  = s11v[i];#
    st.prob = p;#
    {#
      CCState ns = st;#
      if(ns.last==0) ns.s00++; else ns.s10++;#
      ns.last=0;#
      ns.prob = p*(1.0 - alpha);#
      long long code = encode_cc_state(ns.last, ns.c1, ns.s00, ns.s10, ns.s01, ns.s11, nmax);#
      auto it = newMap.find(code);#
      if(it==newMap.end()) newMap[code] = ns; else it->second.prob += ns.prob;#
    }#
    {#
      CCState ns = st;#
      if(ns.last==0) ns.s01++; else ns.s11++;#
      ns.last=1;#
      ns.c1++;#
      ns.prob = p*alpha;#
      long long code = encode_cc_state(ns.last, ns.c1, ns.s00, ns.s10, ns.s01, ns.s11, nmax);#
      auto it = newMap.find(code);#
      if(it==newMap.end()) newMap[code] = ns; else it->second.prob += ns.prob;#
    }#
  }#
  std::vector<CCState> vec; #
  vec.reserve(newMap.size());#
  for(auto &kv : newMap){#
    if(kv.second.prob >= prune_threshold){#
      vec.push_back(kv.second);#
    }#
  }#
  int sz = vec.size();#
  IntegerVector vl(sz), vc1(sz), vs00(sz), vs10(sz), vs01(sz), vs11(sz);#
  NumericVector vp(sz);#
  for(int i=0; i<sz; i++){#
    vl[i]   = vec[i].last;#
    vc1[i]  = vec[i].c1;#
    vs00[i] = vec[i].s00;#
    vs10[i] = vec[i].s10;#
    vs01[i] = vec[i].s01;#
    vs11[i] = vec[i].s11;#
    vp[i]   = vec[i].prob;#
  }#
  return List::create(Named("last")=vl, Named("c1")=vc1, Named("s00")=vs00, Named("s10")=vs10, Named("s01")=vs01, Named("s11")=vs11, Named("prob")=vp);#
}#
#
// [[Rcpp::export]]#
List dist_cc_at_current_fastcpp(List curDist, int t, double alpha=0.05){#
  IntegerVector last  = curDist["last"];#
  IntegerVector c1v   = curDist["c1"];#
  IntegerVector s00v  = curDist["s00"];#
  IntegerVector s10v  = curDist["s10"];#
  IntegerVector s01v  = curDist["s01"];#
  IntegerVector s11v  = curDist["s11"];#
  NumericVector probv = curDist["prob"];#
#
  std::unordered_map<double,double> dmap;#
  dmap.reserve(last.size());#
#
  double eps=1e-15;#
  for(int i=0; i<last.size(); i++){#
    double p = probv[i];#
    if(p<=0.0) continue;#
    int c1  = c1v[i];#
    int x00 = s00v[i], x10 = s10v[i], x01 = s01v[i], x11 = s11v[i];#
    double phat=0.0;#
    if(c1==0)      phat=0.0;#
    else if(c1==t) phat=1.0;#
    else           phat=(double)c1/(double)t;#
    double p_ = std::max(std::min(alpha,1.0-eps),eps);#
    double ph_ = std::max(std::min(phat,1.0-eps),eps);#
    double num = c1*std::log(p_)+(t-c1)*std::log(1.0-p_);#
    double den = c1*std::log(ph_)+(t-c1)*std::log(1.0-ph_);#
    double lruc = -2.0*(num - den);#
    double lrind=0.0;#
    if(t>1){#
      int T0 = x00 + x10;#
      int T1 = x01 + x11;#
      double pHat = (t>1)?((double)T1/(double)(t-1)):0.0;#
      double numI=0.0;#
      if((1.0-pHat)>0.0) numI += T0*std::log(1.0-pHat);#
      if(pHat>0.0)       numI += T1*std::log(pHat);#
      int s01_ = x00+x01;#
      int s11_ = x10+x11;#
      double pi01=(s01_>0)?((double)x01/(double)s01_):1.0;#
      double pi11=(s11_>0)?((double)x11/(double)s11_):1.0;#
      double denI=0.0;#
      if((1.0-pi01)>0.0) denI += x00*std::log(1.0-pi01);#
      if(pi01>0.0)       denI += x01*std::log(pi01);#
      if((1.0-pi11)>0.0) denI += x10*std::log(1.0-pi11);#
      if(pi11>0.0)       denI += x11*std::log(pi11);#
      lrind = -2.0*(numI - denI);#
    }#
    double LRcc = lruc + lrind;#
    dmap[LRcc] += p;#
  }#
  std::vector<std::pair<double,double>> vec;#
  vec.reserve(dmap.size());#
  for(auto &kv: dmap){#
    vec.push_back(std::make_pair(kv.first, kv.second));#
  }#
  std::sort(vec.begin(), vec.end(), [](auto &a, auto &b){return a.first<b.first;});#
  NumericVector LRvals, Pvals;#
  if(!vec.empty()){#
    double curLR=vec[0].first;#
    double curP=vec[0].second;#
    for(size_t i=1; i<vec.size(); i++){#
      if(std::fabs(vec[i].first - curLR)<1e-15){#
        curP += vec[i].second;#
      } else {#
        LRvals.push_back(curLR);#
        Pvals.push_back(curP);#
        curLR=vec[i].first;#
        curP=vec[i].second;#
      }#
    }#
    LRvals.push_back(curLR);#
    Pvals.push_back(curP);#
  }#
  return List::create(Named("LR")=LRvals, Named("prob")=Pvals);#
}#
')#
#
cdf_xy <- function(LRvals, probvals){#
  if(!length(LRvals)) return(list(x=numeric(0),y=numeric(0)))#
  cum <- cumsum(probvals)#
  if(LRvals[1]>=0) {#
    x <- c(0, LRvals)#
    y <- c(0, cum)#
  } else {#
    x <- LRvals#
    y <- cum#
  }#
  list(x=x,y=y)#
}#
#
cdf_val <- function(x, xs, ys){#
  if(!length(xs)) return(0)#
  if(x<=xs[1]) return(0)#
  if(x>=xs[length(xs)]) return(ys[length(xs)])#
  i <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[i]#
}#
#
ks_diff <- function(LRvals, probvals, df=2){#
  d <- cdf_xy(LRvals, probvals)#
  xs <- d$x#
  ys <- d$y#
  if(!length(xs)) return(0)#
  xmax <- xs[length(xs)] + 1#
  seqx <- seq(0, xmax, length.out=800)#
  supd <- 0#
  for(xv in seqx){#
    Ft <- cdf_val(xv, xs, ys)#
    Fc <- pchisq(xv, df)#
    double_diff <- abs(Ft - Fc)#
    if(double_diff>supd) supd<-double_diff#
  }#
  supd#
}#
#
main_cc <- function(){#
  alpha_list <- c(0.01,0.025,0.05)#
  nmax <- 2000#
  nmin <- 1#
  step <- 1#
  plot(NA, xlim=c(nmin,nmax), ylim=c(0,1), xlab="n", ylab="KS distance", main="CDF difference (LRcc vs Chi2) vs n")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_cc_fastcpp(a)#
    nvals <- seq(nmin,nmax,by=step)#
    ksvals <- numeric(length(nvals))#
    for(ix in seq_along(nvals)){#
      t <- nvals[ix]#
      resNow <- dist_cc_at_current_fastcpp(dist_k, t, a)#
      kd <- ks_diff(resNow$LR, resNow$prob, 2)#
      ksvals[ix] <- kd#
      if(t < nmax) {#
        dist_k <- step_forward_cc_fastcpp(dist_k, a, 1e-15, nmax)#
      }#
    }#
    lines(nvals, ksvals, col=cols[i], lwd=2)#
    i <- i+1#
  }#
  legend("topright", legend=paste0("alpha=", alpha_list), col=cols, lty=1, lwd=2, bty="n")#
}#
#
main_cc()
library(Rcpp)#
library(stats)#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
#
const double EPS = 1e-15;#
static inline double safe_log(double x){ return std::log(x>EPS?x:EPS); }#
#
struct CCState{#
  int last,c1,s00,s10,s01,s11;#
  double prob;#
  CCState():last(0),c1(0),s00(0),s10(0),s01(0),s11(0),prob(0.0){}#
  CCState(int l,int c,int a,int b,int e,int f,double pr):last(l),c1(c),s00(a),s10(b),s01(e),s11(f),prob(pr){}#
};#
#
struct LLHash{ std::size_t operator()(long long x) const { return std::hash<long long>()(x);} };#
#
static inline long long ENC(int l,int c1,int a,int b,int c,int d,int n){#
  long long step=(long long)n+10;#
  long long s2=step,s3=s2*step,s4=s3*step,s5=s4*step,s6=s5*step;#
  return l + s2*c1 + s3*a + s4*b + s5*c + s6*d;#
}#
#
[[Rcpp::export]]#
List initialize_cc_fastcpp(double alpha=0.05){#
  CCState s0(0,0,0,0,0,0,1.0-alpha);#
  CCState s1(1,1,0,0,0,0,alpha);#
  return List::create(_["last"]=IntegerVector::create(s0.last,s1.last),#
                      _["c1"]  =IntegerVector::create(s0.c1 ,s1.c1 ),#
                      _["s00"] =IntegerVector::create(s0.s00,s1.s00),#
                      _["s10"] =IntegerVector::create(s0.s10,s1.s10),#
                      _["s01"] =IntegerVector::create(s0.s01,s1.s01),#
                      _["s11"] =IntegerVector::create(s0.s11,s1.s11),#
                      _["prob"]=NumericVector::create(s0.prob,s1.prob));#
}#
#
[[Rcpp::export]]#
List step_forward_cc_fastcpp(List cur,double alpha=0.05,double th=1e-15,int nmax=2000){#
  IntegerVector l=cur["last"], c1=cur["c1"], a=cur["s00"], b=cur["s10"], c=cur["s01"], d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<long long,CCState,LLHash> mp;#
  mp.reserve(l.size()*2);#
  for(int i=0;i<l.size();i++){#
    if(p[i]<th) continue;#
    CCState st(l[i],c1[i],a[i],b[i],c[i],d[i],p[i]);#
    {#
      CCState ns=st;#
      (ns.last==0?ns.s00:ns.s10)++;#
      ns.last=0;#
      ns.prob*=1.0-alpha;#
      long long key=ENC(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=mp.find(key);#
      if(it==mp.end()) mp.emplace(key,ns); else it->second.prob+=ns.prob;#
    }#
    {#
      CCState ns=st;#
      (ns.last==0?ns.s01:ns.s11)++;#
      ns.c1++;#
      ns.last=1;#
      ns.prob*=alpha;#
      long long key=ENC(ns.last,ns.c1,ns.s00,ns.s10,ns.s01,ns.s11,nmax);#
      auto it=mp.find(key);#
      if(it==mp.end()) mp.emplace(key,ns); else it->second.prob+=ns.prob;#
    }#
  }#
  int m=mp.size();#
  IntegerVector L(m),C1(m),A(m),B(m),C(m),D(m); NumericVector P(m); int idx=0;#
  for(auto &kv:mp){#
    if(kv.second.prob<th) continue;#
    L[idx]=kv.second.last;#
    C1[idx]=kv.second.c1;#
    A[idx]=kv.second.s00;#
    B[idx]=kv.second.s10;#
    C[idx]=kv.second.s01;#
    D[idx]=kv.second.s11;#
    P[idx]=kv.second.prob;#
    idx++;#
  }#
  L.resize(idx);C1.resize(idx);A.resize(idx);B.resize(idx);C.resize(idx);D.resize(idx);P.resize(idx);#
  return List::create(_["last"]=L,_["c1"]=C1,_["s00"]=A,_["s10"]=B,_["s01"]=C,_["s11"]=D,_["prob"]=P);#
}#
#
[[Rcpp::export]]#
List dist_cc_at_current_fastcpp(List cur,int t,double alpha=0.05){#
  IntegerVector l=cur["last"], c1=cur["c1"], a=cur["s00"], b=cur["s10"], c=cur["s01"], d=cur["s11"];#
  NumericVector p=cur["prob"];#
  std::unordered_map<double,double> mp;#
  mp.reserve(l.size());#
  for(int i=0;i<l.size();i++){#
    if(p[i]<=0.0) continue;#
    int n1=c1[i], x00=a[i], x10=b[i], x01=c[i], x11=d[i];#
    double phat=n1==0?0.0:(n1==t?1.0:(double)n1/t);#
    double p_=std::max(std::min(alpha,1.0-EPS),EPS);#
    double ph_=std::max(std::min(phat ,1.0-EPS),EPS);#
    double lruc=-2.0*( n1*safe_log(p_) + (t-n1)*safe_log(1.0-p_) - n1*safe_log(ph_) - (t-n1)*safe_log(1.0-ph_) );#
    double lrind=0.0;#
    if(t>1){#
      int T0=x00+x10, T1=x01+x11;#
      double pH=(double)T1/(t-1);#
      double num=T0*safe_log(1.0-pH)+T1*safe_log(pH);#
      int s01_=x00+x01, s11_=x10+x11;#
      double pi01=s01_>0?(double)x01/s01_:1.0;#
      double pi11=s11_>0?(double)x11/s11_:1.0;#
      double den=x00*safe_log(1.0-pi01)+x01*safe_log(pi01)+x10*safe_log(1.0-pi11)+x11*safe_log(pi11);#
      lrind=-2.0*(num-den);#
    }#
    mp[lruc+lrind]+=p[i];#
  }#
  std::vector<std::pair<double,double>> v(mp.begin(),mp.end());#
  std::sort(v.begin(),v.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LR,Pr;#
  for(size_t i=0;i<v.size();){#
    double cur=v[i].first,sum=0;#
    while(i<v.size() && std::fabs(v[i].first-cur)<1e-15){ sum+=v[i].second; i++; }#
    LR.push_back(cur);#
    Pr.push_back(sum);#
  }#
  return List::create(_["LR"]=LR,_["prob"]=Pr);#
}#
', plugins="cpp11", env=globalenv())#
#
cdf_xy <- function(LRvals, probvals){#
  if(!length(LRvals)) return(list(x=numeric(0),y=numeric(0)))#
  cum <- cumsum(probvals)#
  if(LRvals[1]>=0){#
    x <- c(0,LRvals)#
    y <- c(0,cum)#
  }else{#
    x <- LRvals#
    y <- cum#
  }#
  list(x=x,y=y)#
}#
#
cdf_val <- function(x, xs, ys){#
  if(!length(xs)) return(0)#
  if(x<=xs[1]) return(0)#
  if(x>=xs[length(xs)]) return(ys[length(xs)])#
  i <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[i]#
}#
#
ks_diff <- function(LRvals, probvals, df=2){#
  d <- cdf_xy(LRvals, probvals)#
  xs <- d$x#
  ys <- d$y#
  if(!length(xs)) return(0)#
  xmax <- xs[length(xs)]+1#
  seqx <- seq(0,xmax,length.out=800)#
  max(abs(sapply(seqx,function(xv)cdf_val(xv,xs,ys)-pchisq(xv,df))))#
}#
#
main_cc <- function(){#
  alpha_list <- c(0.01,0.025,0.05)#
  nmax <- 2000#
  plot(NA,xlim=c(1,nmax),ylim=c(0,1),xlab="n",ylab="KS distance",main="CDF difference (LRcc vs Chi2) vs n")#
  cols <- c("red","blue","green")#
  i <- 1#
  for(a in alpha_list){#
    dist_k <- initialize_cc_fastcpp(a)#
    ksvals <- numeric(nmax)#
    for(t in 1:nmax){#
      res <- dist_cc_at_current_fastcpp(dist_k,t,a)#
      ksvals[t] <- ks_diff(res$LR,res$prob,2)#
      if(t<nmax) dist_k <- step_forward_cc_fastcpp(dist_k,a,1e-15,nmax)#
    }#
    lines(1:nmax,ksvals,col=cols[i],lwd=2)#
    i <- i+1#
  }#
  legend("topright",legend=paste0("alpha=",alpha_list),col=cols,lty=1,lwd=2,bty="n")#
}#
#
main_cc()
library(Rcpp)#
#
heatmap_ks_LRcc <- function(alpha_seq = seq(0.01, 0.05, by=0.005), nmax = 2000, prune_threshold = 1e-15) {#
  t_start <- proc.time()[3]#
  ks_mat <- matrix(NA_real_, nrow = nmax, ncol = length(alpha_seq))#
  for (i in seq_along(alpha_seq)) {#
    a <- alpha_seq[i]#
    dist_k <- initialize_cc_fastcpp(a)#
    for (n in 1:nmax) {#
      lrres <- dist_cc_at_current_fastcpp(dist_k, n, a)#
      ks_mat[n, i] <- ks_diff(lrres$LR, lrres$prob, 2)#
      if (n < nmax) {#
        dist_k <- step_forward_cc_fastcpp(dist_k, a, prune_threshold, nmax)#
      }#
    }#
    elapsed <- proc.time()[3] - t_start#
    pct_done <- i / length(alpha_seq)#
    est_total <- elapsed / pct_done#
    est_left <- est_total - elapsed#
    cat(sprintf("alpha=%6.3f done. (%.1f%%). elapsed=%.2fs, est. time left=%.2fs\n",#
                a, 100*pct_done, elapsed, est_left))#
  }#
  ks_mat[ks_mat > 0.1] <- 0.1#
  ks_mat[is.na(ks_mat)] <- 0.1#
  xvals <- alpha_seq#
  yvals <- 1:nmax#
  col_fun <- colorRampPalette(c("blue","green","yellow","red"))(256)#
  zlim <- c(0, 0.1)#
  layout(matrix(c(1,2), nrow=1), widths=c(4,0.8))#
  par(mar=c(5,4,4,1))#
  image(xvals, yvals, t(ks_mat), col=col_fun, zlim=zlim, xlab="alpha", ylab="n", main="CDF difference (LRcc vs Chi2)")#
  par(mar=c(5,1,4,3))#
  xx <- c(0,1)#
  yy <- seq(zlim[1], zlim[2], length.out=256)#
  zz <- matrix(rep(yy, each=length(xx)), nrow=length(xx), ncol=length(yy))#
  image(xx, yy, zz, col=col_fun, zlim=zlim, xlab="", ylab="", xaxt="n", yaxt="n")#
  axis(4, at=seq(zlim[1], zlim[2], by=0.02), las=1)#
  box()#
  invisible(ks_mat)#
}#
#
res_LRcc_heatmap <- heatmap_ks_LRcc()
library(Rcpp)#
#
forward_all_t_cc <- function(nmax, alpha, prune_threshold=1e-15) {#
  fw <- vector("list", nmax+1)#
  dist0 <- initialize_cc_fastcpp(alpha)#
  fw[[1]] <- list(last=dist0$last, c1=dist0$c1, s00=dist0$s00, s10=dist0$s10, s01=dist0$s01, s11=dist0$s11, prob=dist0$prob)#
  for(t in 2:(nmax+1)){#
    fw[[t]] <- step_forward_cc_fastcpp(fw[[t-1]], alpha, prune_threshold, nmax)#
  }#
  fw#
}#
#
LR_dist_from_forward_cc <- function(fw, t, alpha) {#
  if(t<=1) return(list(LR=0, prob=1))#
  lrres <- dist_cc_at_current_fastcpp(fw[[t]], t, alpha)#
  list(LR=lrres$LR, prob=lrres$prob)#
}#
#
cdf_val_cc <- function(x, xs, ys){#
  if(x <= xs[1]) return(0)#
  if(x >= xs[length(xs)]) return(ys[length(ys)])#
  i <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[i]#
}#
#
cdf_diff_cc <- function(LRvals, probvals, df=2){#
  ok <- !is.na(LRvals) & !is.na(probvals) & (probvals > 0)#
  if(!any(ok)) return(0)#
  LRvals <- LRvals[ok]#
  probvals <- probvals[ok]#
  LRvals[LRvals < 0] <- 0#
  o <- order(LRvals)#
  LRvals <- LRvals[o]#
  probvals <- probvals[o]#
  csum <- cumsum(probvals)#
  xs <- c(0, LRvals)#
  ys <- c(0, csum)#
  testx <- seq(0, xs[length(xs)] + 1, length.out=400)#
  supd <- 0#
  for(xv in testx){#
    ft <- cdf_val_cc(xv, xs, ys)#
    fc <- pchisq(xv, df)#
    d <- abs(ft - fc)#
    if(d > supd) supd <- d#
  }#
  supd#
}#
#
generate_data_points_cc <- function(){#
  n_list <- c(250, 500, 1000, 2000)#
  alpha_list <- c(0.01, 0.025, 0.05)#
  nmax <- 2000#
  diff_mat <- matrix(0, nrow=nmax, ncol=length(alpha_list))#
  for(j in seq_along(alpha_list)){#
    fw <- forward_all_t_cc(nmax, alpha_list[j], 1e-15)#
    for(t in 1:nmax){#
      lp <- LR_dist_from_forward_cc(fw, t, alpha_list[j])#
      diff_mat[t, j] <- cdf_diff_cc(lp$LR, lp$prob, 2)#
    }#
  }#
  results <- list()#
  idx <- 1#
  for(n_ in n_list){#
    for(a_ in alpha_list){#
      j <- which(alpha_list==a_)#
      ks <- diff_mat[n_, j]#
      results[[idx]] <- c(n_, a_, ks)#
      idx <- idx + 1#
    }#
  }#
  results#
}#
#
plot_grouped_bar_cc <- function(results){#
  vals <- do.call(rbind, results)#
  n_list <- sort(unique(vals[,1]))#
  alpha_list <- sort(unique(vals[,2]))#
  m <- matrix(0, nrow=length(n_list), ncol=length(alpha_list))#
  for(i in seq_len(nrow(vals))){#
    rr <- vals[i,]#
    r_n <- which(n_list==rr[1])#
    c_a <- which(alpha_list==rr[2])#
    m[r_n, c_a] <- rr[3]#
  }#
  colset <- c("blue","orange","green3","red","purple")#
  barplot(t(m), beside=TRUE, names.arg=n_list, col=colset[1:length(alpha_list)],#
          xlab="n", ylab="KS distance", main="Histogram of KS distance (LRcc vs Chi2)")#
  abline(h=0.05, col="red", lty=2)#
  abline(h=0.1, col="red", lty=2)#
  legend_labels <- c(paste0("alpha=", alpha_list), "Threshold=0.05", "Threshold=0.1")#
  legend_colors <- c(colset[1:length(alpha_list)], "red", "red")#
  legend_lines <- c(rep(NA, length(alpha_list)), 2, 2)#
  legend_fill <- c(colset[1:length(alpha_list)], NA, NA)#
  legend("topright", legend=legend_labels, col=legend_colors, lty=legend_lines, fill=legend_fill, bty="n")#
}#
#
main_cc_bar <- function(){#
  results <- generate_data_points_cc()#
  for(i in seq_along(results)){#
    x <- results[[i]]#
    cat(sprintf("n=%d, alpha=%.3f, KS=%.5f\n", x[1], x[2], x[3]))#
    if(i %% 3 == 0) cat("\n")#
  }#
  plot_grouped_bar_cc(results)#
}#
#
res_cc <- main_cc_bar()
library(Rcpp)#
#
fwd_all_t_cc <- function(nmax, alpha, prune_threshold=1e-15) {#
  dist_t <- initialize_cc_fastcpp(alpha)#
  fwd_list <- vector("list", nmax+1)#
  fwd_list[[1]] <- dist_t#
  for(k in 1:(nmax - 1)) {#
    dist_t_next <- step_forward_cc_fastcpp(dist_t, alpha, prune_threshold, nmax)#
    fwd_list[[k+1]] <- dist_t_next#
    dist_t <- dist_t_next#
  }#
  fwd_list#
}#
#
dist_at_t_cc <- function(fwd_list, t, alpha) {#
  lrres <- dist_cc_at_current_fastcpp(fwd_list[[t]], t, alpha)#
  list(LR = lrres$LR, prob = lrres$prob)#
}#
#
cdf_xy_cc <- function(LRvals, probvals) {#
  ok <- !is.na(LRvals) & !is.na(probvals)#
  LRvals <- LRvals[ok]#
  probvals <- probvals[ok]#
  if(!length(LRvals)) return(list(x=numeric(0), y=numeric(0)))#
  o <- order(LRvals)#
  LRvals <- LRvals[o]#
  probvals <- probvals[o]#
  csum <- cumsum(probvals)#
  list(x = c(0, LRvals), y = c(0, csum))#
}#
#
cdf_val_cc <- function(x, xs, ys) {#
  if(!length(xs)) return(0)#
  if(x <= xs[1]) return(0)#
  if(x >= xs[length(xs)]) return(ys[length(ys)])#
  i <- findInterval(x, xs, rightmost.closed=TRUE)#
  ys[i]#
}#
#
size_dist_val_cc <- function(LRvals, probvals, alpha_p = 0.05) {#
  c_chi2 <- qchisq(1 - alpha_p, df=2)#
  tmp <- cdf_xy_cc(LRvals, probvals)#
  Ft <- cdf_val_cc(c_chi2, tmp$x, tmp$y)#
  pr_rej <- 1 - Ft#
  pr_rej - alpha_p#
}#
#
main_size_distortion_cc <- function() {#
  alpha_list <- c(0.01, 0.025, 0.05)#
  alpha_p <- 0.05#
  nmax <- 2000#
  nmin <- 1#
  step <- 10#
  res_dict <- list()#
  for(a_ in alpha_list) {#
    f_list <- fwd_all_t_cc(nmax, a_, 1e-15)#
    nvals <- seq(nmin, nmax, by=step)#
    sdvals <- numeric(length(nvals))#
    for(i in seq_along(nvals)) {#
      t <- nvals[i]#
      dist_res <- dist_at_t_cc(f_list, t, a_)#
      sdvals[i] <- size_dist_val_cc(dist_res$LR, dist_res$prob, alpha_p)#
    }#
    res_dict[[as.character(a_)]] <- data.frame(n = nvals, size_distortion = sdvals)#
  }#
  plot(NA, NA, xlim=c(nmin, nmax), ylim=c(-0.1, 0.1),#
       xlab="n", ylab="Size Distortion",#
       main=paste0("Size Distortion vs n (alpha'=", alpha_p, ") - LRcc"))#
  abline(h=0, col="gray", lty=2)#
  cols <- c("red","blue","forestgreen")#
  leg <- character(0)#
  for(j in seq_along(alpha_list)) {#
    a_ <- alpha_list[j]#
    dfp <- res_dict[[as.character(a_)]]#
    lines(dfp$n, dfp$size_distortion, col=cols[j], lwd=2)#
    points(dfp$n, dfp$size_distortion, col=cols[j], pch=19, cex=0.5)#
    leg <- c(leg, paste0("alpha=", a_))#
  }#
  legend("topright", legend=leg, col=cols, lty=1, lwd=2, pch=19, bty="n")#
}#
#
main_size_distortion_cc()
main_size_distortion_vs_alpha_cc <- function() {#
  n_list <- c(250, 500, 1000)#
  alpha_p <- 0.05#
  alpha_array <- seq(0.01, 0.1, length.out=10)#
  results <- list()#
  for(n_ in n_list) {#
    sd_list <- numeric(length(alpha_array))#
    for(i in seq_along(alpha_array)) {#
      alpha_ <- alpha_array[i]#
      f_list <- fwd_all_t_cc(n_, alpha_, 1e-15)#
      dist_res <- dist_at_t_cc(f_list, n_, alpha_)#
      sd_list[i] <- size_dist_val_cc(dist_res$LR, dist_res$prob, alpha_p)#
    }#
    results[[as.character(n_)]] <- sd_list#
  }#
  plot(NA, NA, xlim=range(alpha_array), ylim=c(-0.1, 0.1),#
       xlab="alpha", ylab="Size Distortion",#
       main=paste0("Size Distortion vs alpha (alpha'=", alpha_p, ") - LRcc"))#
  abline(h=0, col="gray", lty=2)#
  cols <- c("red","blue","forestgreen")#
  leg <- character(0)#
  i <- 1#
  for(n_ in n_list) {#
    lines(alpha_array, results[[as.character(n_)]], col=cols[i], lwd=2)#
    points(alpha_array, results[[as.character(n_)]], col=cols[i], pch=19, cex=0.7)#
    leg <- c(leg, paste0("n=", n_))#
    i <- i + 1#
  }#
  legend("topright", legend=leg, col=cols, lty=1, lwd=2, pch=19, bty="n")#
}#
#
main_size_distortion_vs_alpha_cc()
main_size_distortion_vs_prune_cc <- function() {#
  alpha_list <- c(0.01, 0.025, 0.05)#
  prune_list <- c(1e-17, 1e-16, 1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10)#
  n <- 500#
  alpha_p <- 0.05#
  res <- list()#
  lr_counts <- list()#
  sum_probs <- list()#
  for(a_ in alpha_list) {#
    sd_vals <- numeric(length(prune_list))#
    distinct_vals <- integer(length(prune_list))#
    prob_sums <- numeric(length(prune_list))#
    for(i in seq_along(prune_list)) {#
      prth <- prune_list[i]#
      f_list <- fwd_all_t_cc(n, a_, prth)#
      dist_res <- dist_at_t_cc(f_list, n, a_)#
      LRv <- dist_res$LR#
      pv <- dist_res$prob#
      sd_vals[i] <- size_dist_val_cc(LRv, pv, alpha_p)#
      distinct_vals[i] <- length(LRv)#
      prob_sums[i] <- sum(pv)#
    }#
    res[[as.character(a_)]] <- sd_vals#
    lr_counts[[as.character(a_)]] <- distinct_vals#
    sum_probs[[as.character(a_)]] <- prob_sums#
  }#
  plot(NA, NA, xlim=range(prune_list), ylim=c(-0.1, 0.1),#
       log="x", xlab="Pruning Threshold (log scale)",#
       ylab="Size Distortion",#
       main=paste0("Size Distortion vs Pruning Threshold (n=", n, ", alpha'=", alpha_p, ") - LRcc"))#
  abline(h=0, col="gray", lty=2)#
  cols <- c("red","blue","forestgreen")#
  leg <- character(0)#
  i <- 1#
  for(a_ in alpha_list) {#
    lines(prune_list, res[[as.character(a_)]], col=cols[i], lwd=2)#
    points(prune_list, res[[as.character(a_)]], col=cols[i], pch=19, cex=0.7)#
    leg <- c(leg, paste0("alpha=", a_))#
    i <- i + 1#
  }#
  legend("bottomleft", legend=leg, col=cols, lty=1, lwd=2, pch=19, bty="n")#
  cat(paste0("n=", n, "\n"))#
  cat(" alpha    prune_threshold  #distinct_LR    sum(prob)      size_distortion\n")#
  for(a_ in alpha_list) {#
    sd_vals <- res[[as.character(a_)]]#
    dcts <- lr_counts[[as.character(a_)]]#
    sps <- sum_probs[[as.character(a_)]]#
    for(j in seq_along(prune_list)) {#
      cat(sprintf("%-8.3f %-14.1e %-14d %-14.8f %-14.8f\n",#
                  a_, prune_list[j], dcts[j], sps[j], sd_vals[j]))#
    }#
    cat("\n")#
  }#
}#
#
main_size_distortion_vs_prune_cc()
heatmap_size_distortion_cc <- function() {#
  alpha_array <- seq(0.01, 0.05, by=0.005)#
  nmax <- 2000#
  alpha_p <- 0.05#
  data_mat <- matrix(0, nrow=length(alpha_array), ncol=nmax)#
  for(i in seq_along(alpha_array)) {#
    alpha_ <- alpha_array[i]#
    cat(sprintf("alpha=%.3f done. (%.1f%%)\n", alpha_, 100*i/length(alpha_array)))#
    fwd_result <- fwd_all_t_cc(nmax, alpha_, 1e-15)#
    for(t in 1:nmax) {#
      dist_res <- dist_at_t_cc(fwd_result, t, alpha_)#
      data_mat[i, t] <- size_dist_val_cc(dist_res$LR, dist_res$prob, alpha_p)#
    }#
  }#
  val_min <- min(data_mat)#
  val_max <- max(data_mat)#
  abs_max <- max(abs(val_min), abs(val_max))#
  col_fun <- colorRampPalette(c("blue","white","red"))(256)#
  zlim <- c(-abs_max, abs_max)#
  layout(matrix(c(1,2), nrow=1), widths=c(4,1.2))#
  par(mar=c(5,4,4,1))#
  image(1:nmax, alpha_array, t(data_mat),#
        col=col_fun, zlim=zlim, xlab="n", ylab="alpha",#
        main=paste0("Heatmap of Size Distortion (alpha'=", alpha_p, ") - LRcc"),#
        ylim=range(alpha_array), xlim=c(1, nmax), useRaster=TRUE)#
  par(mar=c(5,1,4,6))#
  lcol <- length(col_fun)#
  scale_y <- seq(zlim[1], zlim[2], length.out=lcol)#
  zz <- matrix(rep(scale_y, each=2), nrow=2)#
  image(x=1:2, y=scale_y, zz, col=col_fun, zlim=zlim, xaxt="n", xlab="", ylab="", main="")#
  axis(4, at=seq(zlim[1], zlim[2], length.out=5), las=1)#
  box()#
}#
#
heatmap_size_distortion_cc()
main_size_distortion_bars_cc <- function() {#
  alpha_list <- c(0.01, 0.025, 0.05)#
  n_list <- c(250, 500, 1000, 2000)#
  alpha_prime <- 0.05#
  results_mat <- matrix(0, nrow=length(n_list), ncol=length(alpha_list))#
#
  for(i in seq_along(n_list)) {#
    n_ <- n_list[i]#
    for(j in seq_along(alpha_list)) {#
      alpha_ <- alpha_list[j]#
      fwd_result <- fwd_all_t_cc(n_, alpha_, 1e-15)#
      dist_res <- dist_at_t_cc(fwd_result, n_, alpha_)#
      sd_ <- size_dist_val_cc(dist_res$LR, dist_res$prob, alpha_prime)#
      results_mat[i, j] <- sd_#
    }#
  }#
#
  for(i in seq_along(n_list)) {#
    n_ <- n_list[i]#
    cat(sprintf("n=%d:\n", n_))#
    for(j in seq_along(alpha_list)) {#
      alpha_ <- alpha_list[j]#
      cat(sprintf("  alpha=%.3f, SizeDist=%.6f\n", alpha_, results_mat[i, j]))#
    }#
    cat("\n")#
  }#
#
  par(mar=c(5,4,4,2))#
  ymax <- max(results_mat, 0.01)#
  ymin <- min(results_mat, -0.01)#
  bp <- barplot(#
    t(results_mat),#
    beside=TRUE,#
    names.arg=n_list,#
    col=c("blue","orange","green"),#
    xlab="n",#
    ylab="Size Distortion",#
    main="Size Distortion (LRcc, alpha'=0.05)",#
    ylim=c(min(ymin, -0.05), max(ymax, 0.01)),#
    cex.names=1.1,#
    las=1#
  )#
  abline(h=0.01, col="red", lty=2)#
  abline(h=-0.01, col="red", lty=2)#
  legend(#
    "bottomright",#
    legend=c(#
      "alpha=0.01",#
      "alpha=0.025",#
      "alpha=0.05",#
      "Threshold=+0.01",#
      "Threshold=-0.01"#
    ),#
    fill=c("blue","orange","green", NA, NA),#
    lty=c(NA,NA,NA,2,2),#
    col=c("blue","orange","green","red","red"),#
    bty="n"#
  )#
}#
#
main_size_distortion_bars_cc()
library(Rcpp)#
library(stats)#
library(ggplot2)#
library(patchwork)#
library(tidyr)#
#
EPS <- 1e-15#
safe_log <- function(x) log(pmax(x, EPS))#
#
cppFunction('#
#include <Rcpp.h>#
#include <unordered_map>#
#include <vector>#
#include <cmath>#
#include <algorithm>#
using namespace Rcpp;#
const double EPS = 1e-15;#
static inline double s_log(double x){return std::log(x>EPS?x:EPS);} #
struct State{int la,c1,T00,T10,T01,T11; double prob;};#
struct LLHash{size_t operator()(long long x)const{return std::hash<long long>()(x);} };#
static inline long long enc6(int la,int c1,int T00,int T10,int T01,int T11,int NMAX){#
  long long M=NMAX+10LL; long long S2=M,S3=S2*M,S4=S3*M,S5=S4*M,S6=S5*M;#
  return la+S2*c1+S3*T00+S4*T10+S5*T01+S6*T11;#
}#
// [[Rcpp::export]]#
List fb_lrcc_fastcpp(int n,double alpha=0.05,double prune=1e-15){#
  if(n<1) return List::create(Named("LR")=NumericVector(0),Named("prob")=NumericVector(0));#
  int NMAX=n+5;#
  std::unordered_map<long long,State,LLHash> cur;#
  State s0{0,0,0,0,0,0,1.0-alpha}; cur[enc6(0,0,0,0,0,0,NMAX)]=s0;#
  State s1{1,1,0,0,0,0,alpha};      cur[enc6(1,1,0,0,0,0,NMAX)]=s1;#
  for(int k=1;k<n;k++){#
    std::unordered_map<long long,State,LLHash> nx; nx.reserve(cur.size()*2);#
    for(auto &kv:cur){#
      double p=kv.second.prob; if(p<prune) continue;#
      int la=kv.second.la;#
      {#
        State ns=kv.second;#
        if(la==0) ns.T00++; else ns.T10++;#
        ns.la=0; ns.prob=p*(1.0-alpha);#
        auto &slot=nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
      {#
        State ns=kv.second;#
        if(la==0) ns.T01++; else ns.T11++;#
        ns.c1++; ns.la=1; ns.prob=p*alpha;#
        auto &slot=nx[enc6(ns.la,ns.c1,ns.T00,ns.T10,ns.T01,ns.T11,NMAX)];#
        if(slot.prob==0) slot=ns; else slot.prob+=ns.prob;#
      }#
    }#
    cur.swap(nx);#
  }#
  std::unordered_map<double,double> dist;#
  for(auto &kv:cur){#
    double p=kv.second.prob; if(p<=0) continue;#
    int c1=kv.second.c1,T00=kv.second.T00,T10=kv.second.T10,T01=kv.second.T01,T11=kv.second.T11;#
    double lruc=0.0,lrind=0.0;#
    {#
      double p_ = alpha; if(p_<EPS) p_=EPS; if(p_>1-EPS) p_=1-EPS;#
      double phat=c1==0?0.0:(c1==n?1.0:(double)c1/n);#
      double ph_=std::max(std::min(phat,1.0-EPS),EPS);#
      lruc = -2.0*( c1*std::log(p_) + (n-c1)*std::log(1.0-p_) - c1*std::log(ph_) - (n-c1)*std::log(1.0-ph_) );#
    }#
    if(n>1){#
      int T0=T00+T10, T1=T01+T11;#
      double pHat=(double)T1/(double)(n-1);#
      double num=T0*s_log(1.0-pHat)+T1*s_log(pHat);#
      int s01=T00+T01,s11=T10+T11;#
      double pi01=s01>0?(double)T01/s01:1.0;#
      double pi11=s11>0?(double)T11/s11:1.0;#
      double den=T00*s_log(1.0-pi01)+T01*s_log(pi01)+T10*s_log(1.0-pi11)+T11*s_log(pi11);#
      lrind = -2.0*(num-den);#
    }#
    dist[lruc+lrind]+=p;#
  }#
  std::vector<std::pair<double,double>> vec(dist.begin(),dist.end());#
  std::sort(vec.begin(),vec.end(),[](auto &a,auto &b){return a.first<b.first;});#
  NumericVector LRout,Pout;#
  for(size_t i=0;i<vec.size();){#
    double curLR=vec[i].first, curP=0.0;#
    while(i<vec.size() && fabs(vec[i].first-curLR)<1e-15){curP+=vec[i].second; ++i;}#
    LRout.push_back(curLR); Pout.push_back(curP);#
  }#
  return List::create(Named("LR")=LRout,Named("prob")=Pout);#
}#
')#
#
fb_lrcc <- function(n, alpha) fb_lrcc_fastcpp(n, alpha, 1e-15)#
#
LRuc_count <- function(x, n, p){#
  p_   <- pmax(pmin(p, 1 - EPS), EPS)#
  phat <- if(x==0) 0 else if(x==n) 1 else x/n#
  ph_  <- pmax(pmin(phat, 1 - EPS), EPS)#
  -2*(x*safe_log(p_) + (n-x)*safe_log(1-p_) - x*safe_log(ph_) - (n-x)*safe_log(1-ph_))#
}#
LRind_count <- function(T00,T10,T01,T11,n){#
  if(n<=1) return(0)#
  T0 <- T00+T10; T1<-T01+T11#
  pHat <- T1/(n-1)#
  num <- T0*safe_log(1-pHat)+T1*safe_log(pHat)#
  s01<-T00+T01; pi01<-if(s01>0) T01/s01 else 1#
  s11<-T10+T11; pi11<-if(s11>0) T11/s11 else 1#
  den <- T00*safe_log(1-pi01)+T01*safe_log(pi01)+T10*safe_log(1-pi11)+T11*safe_log(pi11)#
  -2*(num-den)#
}#
my_compute_LRcc <- function(X, alpha){#
  n <- length(X); if(n<1) return(0)#
  x <- sum(X)#
  counts <- matrix(0,2,2)#
  if(n>1){#
    for(t in 2:n){counts[X[t-1]+1, X[t]+1] <- counts[X[t-1]+1, X[t]+1]+1}#
  }#
  T00<-counts[1,1]; T01<-counts[1,2]; T10<-counts[2,1]; T11<-counts[2,2]#
  LRuc_count(x,n,alpha)+LRind_count(T00,T10,T01,T11,n)#
}#
#
get_pval_exact <- function(LRvals, probvals, LRobs) 1 - sum(probvals[LRvals < LRobs])#
#
gen_markov <- function(n, alpha, phi=0.6){#
  p11 <- phi; p01 <- alpha*(1-phi)/(1-alpha)#
  X <- numeric(n); X[1] <- rbinom(1,1,alpha)#
  for(i in 2:n) X[i] <- rbinom(1,1, ifelse(X[i-1]==1,p11,p01))#
  X#
}#
#
set.seed(123)#
n_list <- c(50,100,150,200,250,300,500)#
alpha_list <- c(0.01,0.025,0.05)#
Nrep <- 2000#
results_size <- data.frame(); results_power <- data.frame()#
#
for(n_ in n_list){#
  for(alpha_ in alpha_list){#
    dist <- fb_lrcc(n_, alpha_)#
    LRvals <- dist$LR; probvals <- dist$prob#
    rej_ex <- rej_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- rbinom(n_,1,alpha_)#
      LR <- my_compute_LRcc(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 2)#
      rej_ex[i] <- (p_ex < 0.05); rej_ch[i] <- (p_ch < 0.05)#
    }#
    size_ex <- mean(rej_ex); se_ex <- sqrt(size_ex*(1-size_ex)/Nrep)#
    size_ch <- mean(rej_ch); se_ch <- sqrt(size_ch*(1-size_ch)/Nrep)#
    results_size <- rbind(results_size, data.frame(n=n_, alpha=alpha_, size_exact=size_ex, se_size_exact=se_ex,#
                                                  size_chi2_2=size_ch, se_size_chi2_2=se_ch))#
    pow_ex <- pow_ch <- numeric(Nrep)#
    for(i in 1:Nrep){#
      X <- gen_markov(n_, alpha_, 0.6)#
      LR <- my_compute_LRcc(X, alpha_)#
      p_ex <- get_pval_exact(LRvals, probvals, LR)#
      p_ch <- 1 - pchisq(LR, 2)#
      pow_ex[i] <- (p_ex < 0.05); pow_ch[i] <- (p_ch < 0.05)#
    }#
    p_ex <- mean(pow_ex); se_pe <- sqrt(p_ex*(1-p_ex)/Nrep)#
    p_ch <- mean(pow_ch); se_pc <- sqrt(p_ch*(1-p_ch)/Nrep)#
    results_power <- rbind(results_power, data.frame(n=n_, alpha=alpha_, power_exact=p_ex, se_power_exact=se_pe,#
                                                    power_chi2_2=p_ch, se_power_chi2_2=se_pc))#
  }#
}#
#
size_df <- pivot_longer(results_size, cols=c(size_exact,size_chi2_2), names_to="method", values_to="value")#
size_df$method[size_df$method=="size_chi2_2"] <- "size_chi2(2)"#
#
power_df <- pivot_longer(results_power, cols=c(power_exact,power_chi2_2), names_to="method", values_to="value")#
power_df$method[power_df$method=="power_chi2_2"] <- "power_chi2(2)"#
#
p_size <- ggplot(size_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_2),#
                    ymax=value+1.96*ifelse(method=="size_exact", se_size_exact, se_size_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+geom_hline(yintercept=0.05, colour="red", linetype="dashed")+#
  labs(x="n", y="empirical size (significance level = 5%)")+theme_minimal()#
#
p_power <- ggplot(power_df, aes(factor(n), value, fill=method))+geom_bar(stat="identity", position="dodge")+#
  geom_errorbar(aes(ymin=value-1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2),#
                    ymax=value+1.96*ifelse(method=="power_exact", se_power_exact, se_power_chi2_2)),#
                position=position_dodge(0.9), width=0.25)+#
  facet_wrap(~alpha, labeller=label_both)+labs(x="n", y="empirical power (φ=0.6)")+theme_minimal()#
#
print(p_power / p_size)
n_phi <- 250#
alpha_phi <- 0.05#
phi_list <- c(0.2, 0.4, 0.6, 0.8, 0.9)#
dist_phi <- fb_lrcc(n_phi, alpha_phi)#
LRv <- dist_phi$LR; Pv <- dist_phi$prob#
phi_df <- data.frame()#
for(ph in phi_list){#
  ex <- ch <- numeric(Nrep)#
  for(i in 1:Nrep){#
    X  <- gen_markov(n_phi, alpha_phi, ph)#
    LR <- my_compute_LRcc(X, alpha_phi)#
    p_e <- get_pval_exact(LRv, Pv, LR)#
    p_c <- 1 - pchisq(LR, 2)#
    ex[i] <- (p_e < 0.05)#
    ch[i] <- (p_c < 0.05)#
  }#
  phi_df <- rbind(phi_df,#
    data.frame(phi=ph, method="exact",   power=mean(ex),#
               se=sqrt(mean(ex)*(1-mean(ex))/Nrep)),#
    data.frame(phi=ph, method="chi2(2)", power=mean(ch),#
               se=sqrt(mean(ch)*(1-mean(ch))/Nrep)))#
}#
#
ggplot(phi_df, aes(phi, power, color=method))+#
  geom_line()+geom_point()+#
  geom_errorbar(aes(ymin=power-1.96*se, ymax=power+1.96*se), width=0.02)+#
  scale_x_continuous(breaks=phi_list)+#
  labs(x="phi", y="empirical power (n=250, α=0.05)")+#
  theme_minimal()
exception_df <- read.csv("/Users/chenyujian/Downloads/VaR_exceptions.csv", row.names = 1)#
alpha_vec <- c(0.05, 0.025, 0.01)#
colnames(exception_df) <- as.character(alpha_vec)#
#
n_win <- 250#
series_len <- nrow(exception_df)#
plot_df <- data.frame()#
#
for(a in alpha_vec){#
  X_full <- exception_df[[as.character(a)]]#
  dist   <- fb_lrcc(n_win, a)#
  LRv    <- dist$LR; Pv <- dist$prob#
  idx_max <- series_len - n_win + 1#
  for(idx in 1:idx_max){#
    seg  <- X_full[idx:(idx + n_win - 1)]#
    LR   <- my_compute_LRcc(seg, a)#
    p_e  <- get_pval_exact(LRv, Pv, LR)#
    p_c  <- 1 - pchisq(LR, 2)#
    plot_df <- rbind(plot_df,#
      data.frame(idx = idx, alpha = a, method = "exact",   p_value = p_e),#
      data.frame(idx = idx, alpha = a, method = "chi2(2)", p_value = p_c))#
  }#
}#
#
ggplot(plot_df, aes(idx, p_value, color = method)) +#
  geom_line() +#
  facet_wrap(~alpha, labeller = label_both, ncol = 1) +#
  geom_hline(yintercept = 0.05, linetype = "dashed", colour = "red") +#
  labs(x = "window start index", y = "p-value") +#
  theme_minimal()
install.packages(c("devtools", "usethis", "roxygen2",#
                   "testthat", "Rcpp", "pkgdown"))
devtools::has_devel()
devtools::has_devel()
usethis::create_package("~/Documents/Rpackages/ExactVaRTest")
usethis::use_git()
devtools::load_all()    # 输出 Loading ExactVaRTest
usethis::use_description(fields = list(#
  Title       = "Exact Finite-Sample VaR Back-Testing",#
  Description = paste(#
    "Provides fast dynamic-programming algorithms to compute the exact",#
    "finite-sample distribution and p-values of the Christoffersen (1998)",#
    "Unconditional Coverage (UC), Independence (IND) and Conditional",#
    "Coverage (CC) tests for Value-at-Risk models."#
  ),#
  Version     = "0.0.0.9000",#
  License     = "MIT + file LICENSE",#
  `Authors@R` = c(#
    utils::person("YuJian", "Chen",#
                  email = "yujian.chen@polytechnique.edu",#
                  role  = c("aut", "cre"))       # aut = author, cre = maintainer#
  ),#
  URL         = "https://github.com/YourGitHub/ExactVaRTest",#
  BugReports  = "https://github.com/YourGitHub/ExactVaRTest/issues"#
))
# 如果你还没跑过 use_rcpp()，DESCRIPTION 里不会有 “Imports: Rcpp”#
# 先查看一次：#
readLines("DESCRIPTION")
usethis::use_rcpp()
devtools::document()   # 生成 NAMESPACE 等
readLines("NAMESPACE")
devtools::document()           # 或 Cmd + Shift + D
readLines("NAMESPACE")
